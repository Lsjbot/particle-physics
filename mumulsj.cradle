+USE,CRAY.                  Select machine.                     26.07.86
+USE,CERN.                  Switch on CERN flag.
+USE,*NA34CRA.              USE pilot-patch in NA34 cradle.
+EXE,*NA34CRA.              EXE pilot-patch in NA34 cradle.
+USE,SANDCDES.
+USE,P=EPPAC.               Use select for EPIO control COMMON.
+USE,P=EPIO,D= .            Use select for EPIO control COMMON.
&LIST,CRA*.
+USE,GENCOM.
+SELF.                      User KEEP sequences after this card
+REP,P=SANDCDES,D= ,C=2.    Increase the blank common from 200000
      COMMON / / IZSFS1(1),     ILBLNK(350000), LBFEND
+REP,P=SANDCDES,D= ,C=11.   Increase the HBOOK reserved area
      HBRSRV = 175000
C---------------------------------------------------------------------
C
C                       C O M M O N S
C
C---------------------------------------------------------------------
C                       MYINFO
C---------------------------------------------------------------------
+KEEP,MYINFO. My event information
      COMMON/MYCOUN/ JLEVEN,MUEVEN,NREPIN,NREP,JDEBU,JPRLVL,NWRIT,
     *               NBWRIT,NTAPES,NFILES,NCUT(24,10),XCUT(24),ETCUT
     *              ,NUMRUN(1000),MXRUN
      LOGICAL XCUT
      INTEGER ETCUT
 
      COMMON/MYVALU/ PKICKM,ETOT,ETOTMU,VETOEN,ETULAC,RCUT,PCUT,
     *               MULTSC,MULTS2,PTSUM,ETSUM
 
      COMMON/MYTITL/ T(9),COMMEN,FILEN
      CHARACTER*6    T
      CHARACTER*32   COMMEN
      CHARACTER*8    FILEN
 
      COMMON/MYCTRL/ MUFLAG,DSTFLG,ELFLAG,DCFLAG,NVFBTG,IVFBTG(10),
     *               PRITRI,NPRETG,IPRETG(10),PRIMU,MCFLAG,
     *               PRILAB,NSPYTG,ISPYTG(10),PRIDC,
     *               FRPRE(32),VFBTOT(51),PRISCA,YEAR
      LOGICAL   MUFLAG,DSTFLG,ELFLAG,DCFLAG,PRITRI,PRILAB,PRISCA,FRPRE,
     *          PRIMU,PRIDC,MCFLAG
      INTEGER   VFBTOT,YEAR
 
      COMMON/ZPOS/ XTARG,YTARG,ZTARG,ZM,ZSCIN,ZULAC,ZBEAM,ZVETO
C---------------------------------------------------------------------
C                       HISTO
C---------------------------------------------------------------------
+KEEP,HISTO.   Histogram flags
      COMMON/HISTO/JH(20),LH(20)
C---------------------------------------------------------------------
C                       KINEM
C---------------------------------------------------------------------
+KEEP,KINEM.   Kinematical constants
      COMMON/TLOR/TMB,TMT,TPBL,TPBC,TSS,TBET,TLOR(4)
      COMMON/CONST/EM,EEM,MUM,MUMUM,PIM,KAM,PRM,ROM,PI,PI2
      REAL MUM,MUMUM,KAM
C---------------------------------------------------------------------
C                       COMB
C---------------------------------------------------------------------
+KEEP,COMB.   Combinatorial background
      COMMON/COBACK/ IBN,IBP,CBN(4,1500),CBP(4,1500)
C---------------------------------------------------------------------
C                       TRACK
C---------------------------------------------------------------------
+KEEP,TRACK.   TRACK BANK
      COMMON/TRAKMU/  NMU,TRAKMU(4,10,25),PMU(10,10)
      DIMENSION       IRAKMU(4,10,25)
      EQUIVALENCE    (TRAKMU(1,1,1),IRAKMU(1,1,1))
      COMMON/TRACK/   NDC,TRAKDC(5,100,25),PDC(3,100,10),MULTDC(20)
      DIMENSION       IRAKDC(5,100,25)
      EQUIVALENCE    (TRAKDC(1,1,1),IRAKDC(1,1,1))
C---------------------------------------------------------------------
C                       MYSPAD
C---------------------------------------------------------------------
+KEEP,MYSPAD. MY SCINT. PAD INFO
      COMMON / MYSPDA / IRAWA(100),IRAWD(1024),JWDPM(80),ISCLOC(256),
     *                  ITEMP(256),IADC(80),IDISCR(4,80),XSCIL(80),
     *                  XSCIH(80),YSCIL(80),YSCIH(80),IVALX(80),
     *                  ICUT(80),JCUT(80),ISHIF(80),DOSHIF,
     *                  IHIST(80),IDISUP(256),SCIFAN(256),ISCSP(256)
      LOGICAL SCIFAN,DOSHIF
+SELF. =============================================================
+PAM,12,R=CDECRA,T=A,HOLD.   NA34CRA
+PAM,13,R=EPPAC,T=A      .   EPIO
+PAM,13,R=GCDES,T=A      .   GEANT309
+PAM,11,T=A              .   NA34PAM
+SELF. =============================================================
+USE,P=SALBMAIN,D=LBMAIN.  Fixes comes here:
+EXE,P=SALBMAIN,D=LBMAIN.
+SELF.
+PAM,12,T=RESUME      .  NA34CRA
+PAM,11.              .  NA34PAM
+SELF.
+SELF.
+PATCH,MYDECKS.
C*********************************************************************
C
C                         S E T E O I
C
C*********************************************************************
+DECK,SETEOI. Dummy routine which has to to with EOF.
      SUBROUTINE SETEOI(IUNIT)
      WRITE(6,*)'DUMMY SETEOI CALLED!  No action.'
      RETURN
      END
+EOD.
C*********************************************************************
C
C                         M Y E O F
C
C*********************************************************************
+DECK, MYEOF. Routine called after each end of file on input
      SUBROUTINE MYEOF(IUNIT)
+CDE,SALLIO.
+CDE,TAPCRAY.
+CDE,GENCHK.
 
      INTEGER JTAPE,NF
      SAVE JTAPE
      DATA JTAPE/1/
 
      WRITE(6,*)'MYEOF reached for tape ',JTAPE
      WRITE(6,*) NEVI   ,' events processed.'
      IF(IUNIT.NE.10) THEN
       WRITE(6,*)'STRANGE! EOF on unit ',IUNIT
      ELSE
 2      JTAPE = JTAPE + 1
        IF(JTAPE.LE.TAPMAX) THEN
         CALL SETNXI(10,TAPEN(JTAPE),IERR)
         IF(IERR.NE.0) GO TO 2
        ELSE
         IUNI = 10
         KK = IUCOMP(IUNI,LUNINS(1),NUNIN)
         EOIRED(KK) = .TRUE.
        ENDIF
      ENDIF
      RETURN
      END
+EOD.
C*********************************************************************
C
C                         Z E P I N
C
C*********************************************************************
+DECK,ZEPIN
      SUBROUTINE ZEPIN (IZ,LUN,KEYS,NKEYS,IDCAT,IERR)
C---------------------------------------------------------------------
C             READS NEXT LOGICAL EVENT IDENTIFIED BY THE
C             LIST OF NKEY  KEYWORDS
C             THE CURRENT CATALOG IDENTIFIER IS RETURNED IN IDCAT
C             IF ZEPCAT WAS CALLED PRIOR TO ZEPIN THEN
C             ZEPIN STARTS TO READ AT THE FIRST KEY
C             UNLESS IT READS THE NEXT CATALOG TOO
C---------------------------------------------------------------------
      COMMON/ZCFORM/NLFORM,JD(60)
      DIMENSION IFORBF(50)
      EQUIVALENCE (IFORBF(1),JD(11))
      DIMENSION IZ(1) , KEYS(1), IH(60)
      DIMENSION JL(10) , JM(10)
      DIMENSION MODSEP(8),NUM(40),LL(4)
      DATA MODSEP/11,12,13,13,13,12,13,13/
+SELF,IF=CDC
      DATA NBIT/60/
+SELF,IF=IBM
      DATA NBIT/32/
+SELF,IF=VAX
      DATA NBIT/32/
+SELF,IF=UNIVAC
      DATA NBIT/36/
+SELF,IF=BESM6
      DATA NBIT/48/
+SELF,IF=APOLLO
      DATA NBIT/32/
+SELF,IF=PDP10
      DATA NBIT/36/
+SELF,IF=NORD
      DATA NBIT/32/
+SELF,IF=CRAY
      DATA NBIT/64/
+SELF
      DATA IFIRST/0/
      NAMEL=0
      NWFORL=0
      NLFORM=10
      IF(IFIRST.EQ.0)  THEN
         IFIRST=1
         CALL ZLOCAL(IZ,NLFORM)
         CALL UCTOH('****',MISS,4,4)
         CALL UCTOH('    ',IBLANK,4,4)
         CALL UCTOH1(' 1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ*+-'
     +   ,NUM(1),40)
      ENDIF
 
      NKEY   = NKEYS
      IERR   = 0
      IDS    = IZ(1)
      IZ(IDS+6)= 0
C---------------------------------------------------------------------
C     DEFINE LASOPD (LAST OPERATION DONE)
C---------------------------------------------------------------------
      JBUF   = IZ(IDS - 3)
      IF (JBUF.LE.0)                             GO TO 10
 
      NUNIT  = IZ(JBUF) - 2
      LBUF=1
      DO 5 I=1,NUNIT
      IF(IZ(JBUF+I).NE.LUN)GO TO 5
      LBUF=I
      GO TO 7
   5  CONTINUE
      CALL ZERROR(IZ,900,'ZEPIN ',IDS)
      GO TO 180
 
   7  JBUF   = IZ(JBUF - LBUF) + 3
      LASOPD = IZ(JBUF - 2)
 
      IF (LASOPD.EQ.0)                           GO TO 10
      IF (LASOPD.EQ.3)                           GO TO 10
 
      IDCAT  = IZ(JBUF - 1)
      GO TO 20
C---------------------------------------------------------------------
C     READ IN NEXT CATALOG HEADER
C---------------------------------------------------------------------
   10 CALL ZEPNXT (IZ,LUN,IDCAT,IERR)
      IF (IERR.NE.0.AND.IERR.NE.6)               GO TO 180
C---------------------------------------------------------------------
C     PERFORM SYSTEMATIC GARBAGE COLLECTION
C---------------------------------------------------------------------
  20  IF(IZ(IDS+5).LE.0)GO TO 50
      CALL ZGARB(IZ)
   50 CONTINUE
      IDS=IZ(1)
      IF(IZ(IDS+6).NE.0)GO TO 180
      JBUF=IZ(IDS-3)
      JBUF=IZ(JBUF-LBUF)+3
 
      CALL EPFHDR (LUN,7,IH,IZ(JBUF),IERR)
      IF (IERR.NE.0.AND.IERR.NE.6)               GO TO 180
 
   60 IF (IH(2).EQ.4)                            GO TO 170
      IF (IH(2).NE.2)                            GO TO 50
      IF (NKEY.LE.0)                             GO TO 50
C---------------------------------------------------------------------
C     KEY HEADER
C---------------------------------------------------------------------
      CALL EPFRD (LUN,13,NW,IH,IZ(JBUF),IERR)
      IF (IERR.NE.0)                             GO TO 180
      CALL ZFRIBM(IH,NW,2)
 
      KEY    = IH(1)
 
      DO 62 I=1,NKEY
      IF(KEY.EQ.KEYS(I))GO TO 63
  62  CONTINUE
      GO TO 50
 
  63  CALL ZEPLOC (IZ,KEY,NID,NMEMB,ICODE)
      IF (NID.EQ.0)                              GO TO 50
      IF (NMEMB.EQ.0)                            GO TO 50
 
      ICODE  = MOD (IH(2),10)
      MODEP  = MODSEP(ICODE + 1)
      NMB    = 1
 
   70 NST    = 1
      JD(1)  = NID + NMB
      JL(1)  = 2
      JM(1)  = 1
 
   80 CONTINUE
      JBUF=IZ(IDS-3)
      JBUF=IZ(JBUF-LBUF)+3
      CALL EPFHDR (LUN,60,IH,IZ(JBUF),IERR)
      IF (IERR.NE.0.AND.IERR.NE.6)               GO TO 180
      IF (IH(2).NE.5)                            GO TO 83
C---------------------------------------------------------------------
C     SET OF MISSING BANKS
C---------------------------------------------------------------------
      NMSS   = IH(4)
      IF (NST.NE.1)                              GO TO 82
 
      NMB    = NMB + NMSS
      IF (NMB.GT.NMEMB)                          GO TO 50
      GO TO 70
 
   82 JL(NST) = JL(NST) - NMSS
      IF (JL(NST).GT.0)                          GO TO 80
 
      NST    = NST - 1
      GO TO 80
 
   83 IF (IH(2).NE.3)                            GO TO 60
C---------------------------------------------------------------------
C     BANK HEADER
C---------------------------------------------------------------------
      NWH    = IH(3)
      NDATA     = IH(1) - IH(3)
 
      NWFOR=0
      IF(NWH.LE.7)   GO TO 831
      NWFOR=IH(NWH)
      NWH=NWH-NWFOR-1
  831 CONTINUE
 
      ISIT   = NWH - 2
      IF (ISIT.GT.2) ISIT = ISIT - 1
 
      GO TO (84,85,86,87), ISIT
 
   84 NLINKS = 0
      NAME=IBLANK
      NUMB=0
      GO TO 89
 
   85 NLINKS = IH(4)
      NAME=IBLANK
      NUMB=0
      GO TO 89
 
   86 NLINKS = 0
      NUMB   = IH(6)
      JJ1=MOD(IH(4),256)
      JJ2=MOD(IH(4)/256,256)
      JJ3=MOD(IH(5),256)
      JJ4=MOD(IH(5)/256,256)
      LL(1)=NUM(JJ1)
      LL(2)=NUM(JJ2)
      LL(3)=NUM(JJ3)
      LL(4)=NUM(JJ4)
      CALL UBUNCH(LL,NAME,4)
      GO TO 89
 
   87 NLINKS = IH(4)
      NUMB   = IH(7)
      JJ1=MOD(IH(5),256)
      JJ2=MOD(IH(5)/256,256)
      JJ3=MOD(IH(6),256)
      JJ4=MOD(IH(6)/256,256)
      LL(1)=NUM(JJ1)
      LL(2)=NUM(JJ2)
      LL(3)=NUM(JJ3)
      LL(4)=NUM(JJ4)
      CALL UBUNCH(LL,NAME,4)
 
      IF (NAME.EQ.MISS)                          GO TO 130
 
   89 IF (ICODE.EQ.1)                            GO TO 100
      IF (ICODE.EQ.5)                            GO TO 100
      IF (ICODE.EQ.0)                            GO TO 90
 
      NDATA     = NDATA / 2
      GO TO 100
 
   90 NDATA     = (NDATA*16-1) / NBIT + 1
 
  100 J      = JD(NST) - JM(NST) + JL(NST) - 1
      IZ(IDS+17) = 1
      CALL ZBOOKN (IZ,IZ(J),NDATA,NLINKS,NAME,NUMB)
      IF(IZ(IDS+6).EQ.200)IZ(IDS+6)=0
      IF (IZ(IDS + 6).NE.0)                      GO TO 180
 
      J      = JD(NST) - JM(NST) + JL(NST) - 1
      K      = IZ(J)
      CALL EPFRD (LUN,MODEP,NW,IZ(K+1),IZ(JBUF),IERR)
      IF (IERR.NE.0)                             GO TO 180
 
      IF(NWFOR.NE.0)  THEN
C---------------------------------------------------------------------
C    BANK HAS A FORMAT - STORE IT AWAY
C---------------------------------------------------------------------
      CALL ZPTFOR(IZ,NAME,NWFOR,IH(NWH+1))
      J      = JD(NST) - JM(NST) + JL(NST) - 1
      K      = IZ(J)
      NWFORL=NWFOR
      CALL UCOPY(IH(NWH+1),IFORBF,NWFOR)
      ELSEIF(NWFORL.EQ.0.OR.NAME.NE.NAMEL)  THEN
      NWFORL=0
       GO TO 120
      ENDIF
      IF(NDATA.GT.0.AND.ICODE.NE.0)
     + CALL ZFCONV(IFORBF,NWFORL,IZ(K+1),NDATA,0)
       GO TO 130
  120 CONTINUE
 
      IF (ICODE.EQ.5.OR.ICODE.EQ.0)              GO TO 130
 
      J      = JD(NST) - JM(NST) + JL(NST) - 1
      K      = IZ(J)
 
      IF ( ICODE.EQ.7 ) THEN
           IANA34    = IZ(K)
           LANA34    = IZ(K+IANA34)
           IF ( LANA34.EQ.14227 )                GO TO 130
           IF ( LANA34.EQ.14327 )                GO TO 130
CVIH       IF ( LANA34.EQ.7627  )                GO TO 130
      ENDIF
 
      CALL ZFRIBM (IZ(K+1),NDATA,ICODE)
 
  130 NAMEL=NAME
      JL(NST) = JL(NST) - 1
      IF (JL(NST).NE.0)                          GO TO 140
 
      NST    = NST - 1
 
  140 IF (NLINKS.NE.0)                           GO TO 150
      IF (NST.NE.1)                              GO TO 80
      GO TO 160
 
  150 NST    = NST + 1
      JD(NST) = K
      JL(NST) = NLINKS
      JM(NST) = NLINKS
      GO TO 80
 
  160 NMB    = NMB + 1
      IF (NMB.GT.NMEMB)                          GO TO 50
      GO TO 70
 
  170 JF     = JBUF - 2
      IZ(JF) = 3
 
  180 IERR   = IERR + IZ(IDS + 6)
 
      NLFORM=0
      RETURN
      END
+EOD.
C*********************************************************************
C
C                    M U F I L T   J O B
C
C*********************************************************************
C
C                         M Y I N I
C
C*********************************************************************
+DECK, MYINI.  Routine called before anything is read
      SUBROUTINE MYINI (IRUN)
C---------------------------------------------------------------------
C     This is the first routine to be called
C---------------------------------------------------------------------
+CDE,TAPCRAY.
+CDE,MYINFO.
+CDE,COMB.
+CDE,MUCOUN.
+CDE,SABCOM.
+CDE,SAZBID.
+CDE,GCLINK.
+CDE,SAPCTL.
+CDE,SAIOCT.
+CDE,SASBIN.
+CDE,DISET.
+CDE,MUSTAT.
+CDE,UGMUCD.
+CDE,MUID.
+CDE,HISTO.
+CDE,MUGEOC.
+CDE,MUGNET.
      CHARACTER*40 CUTCOM(24)
      DATA CUTCOM/'Cuts on muon tracks                     ',
     *            'Cuts on DC tracks                       ',
     *            'Cuts on beam counters                   ',
     *            'Cuts on Etot & Eveto                    ',
     *            'Cuts on Si Pad                          ',
     *            'Cuts on Scint. pads                     ',
     *            'Cuts on cone cal.                       ',
     *            'Cuts on Muon hodoscope                  ',
     *            'Muon pairs - vertex cuts                ',
     *            'Muon pairs - DC match                   ',
     *         14*'                                        '/
C---------------------------------------------------------------------
C     Initialize
C---------------------------------------------------------------------
      TQUIT=20.
      EXPRTS(1) = .TRUE.
      JLEVEN = 0
      MUEVEN = 0
      IBN = 0
      IBP = 0
      CALL VZERO(CBN,6000)
      CALL VZERO(CBP,6000)
C---------------------------------------------------------------------
C     # of input streams in parallel
C---------------------------------------------------------------------
      NINPTS = 1
C---------------------------------------------------------------------
C     Read input tapes
C---------------------------------------------------------------------
      READ (16,5002) TAPMAX
 5002  FORMAT(I4)
      DO 5000 I=1,TAPMAX
       READ (16,5001) TAPEN(I)
 5001  FORMAT(A130)
 5000 CONTINUE
      CALL SETNXI(10,TAPEN(1),IERC)
C---------------------------------------------------------------------
C     Zero the scalers  (FRSCAL is a routine in FREJA)
C---------------------------------------------------------------------
      CALL FRSCAL(-1)
C---------------------------------------------------------------------
C     Set date and time
C---------------------------------------------------------------------
      IF(.NOT.MCFLAG) CALL UGDATE(1986,07,1,17.0010,1)
      IF(MCFLAG) CALL UGDATE(1988,07,11,17.0010,1)
C---------------------------------------------------------------------
C     Small printout
C---------------------------------------------------------------------
      CALL CEXIST('PRNT',.FALSE.)
C---------------------------------------------------------------------
C     Take out parts of the database to save time
C---------------------------------------------------------------------
      CALL CEXIST('ERRP',.FALSE.)
      CALL CEXIST('TRDF',.FALSE.)
      CALL CEXIST('DC1 ',.FALSE.)
      CALL CEXIST('DC2 ',.FALSE.)
      CALL CEXIST('DC3 ',.FALSE.)
      CALL CEXIST('XTSP',.FALSE.)
      CALL CEXIST('SILI',.FALSE.)
      CALL CEXIST('WALL',.FALSE.)
      CALL CEXIST('BCAL',.FALSE.)
C---------------------------------------------------------------------
C     Activate the muon detector in the database
C     DISETS: sets the maximum distance from target
C     UGSETS: sets the detector (IDISET(8)=muon spectrometer)
C     UGINIT: initialize the database
C---------------------------------------------------------------------
C     ZMAX = 20000.
C     CALL DISETS(ZMAX)
C     CALL UGSETS(IDISET(8),1)
C     CALL UGINIT
C---------------------------------------------------------------------
C     Fill MUREC commons with muon data (MUREC routine) e.g.
C     /MUGEOH/ is filled with hodoscope positions
C     /MUSTRC/ is filled with bank structure
C     /MULECT/ is filled with siren information
C     /MUGNET/ is filled with magnetic field stuff
C     /MUTRIG/ is filled with trigger information
C---------------------------------------------------------------------
C     CALL MUDATA
C---------------------------------------------------------------------
C     Calculate beam energy, c.m. energy etc
C---------------------------------------------------------------------
      CALL KINMAT
C---------------------------------------------------------------------
C      Read input values from runcard file
C---------------------------------------------------------------------
      READ(15,120) (T(I),I=1,9)
      READ(15,121) COMMEN
      READ(15,122) FILEN
      READ(15,110) MUDRAW
      READ(15,110) ZBKFMS(1)
      READ(15,110) MUFLAG
      READ(15,110) DSTFLG
      READ(15,110) ELFLAG
      READ(15,110) MCFLAG
      READ(15,110) DCFLAG
      READ(15,110) PRITRI
      READ(15,110) PRILAB
      READ(15,110) PRISCA
      READ(15,110) PRIMU
      READ(15,110) PRIDC
      READ(15,101) NTAPES
      READ(15,102) NFILES
      READ(15,101) NOTPTS
      READ(15,49)  (JH(I),I=1,20)
      READ(15,50)  BCENTR,NREPIN,NREP,JDEBU,JPRLVL,
     *            NWRIT,NBWRIT
      READ(15,51)  NVFBTG,(IVFBTG(I),I=1,NVFBTG)
      READ(15,51)  NPRETG,(IPRETG(I),I=1,NPRETG)
      READ(15,51)  NSPYTG,(ISPYTG(I),I=1,NSPYTG)
      READ(15,52)  PKICKM
      READ(15,53)  RCUT,PCUT
      READ(15,103) ETCUT
      READ(15,55)  (XCUT(I),I=1,24)
C---------------------------------------------------------------------
C   FORMAT statements for READ
C---------------------------------------------------------------------
  120 FORMAT(/,10X,9(A6,1X),/)
  121 FORMAT(50X,A20)
  122 FORMAT(50X,A8,/)
  110 FORMAT(50X,L1)
  101 FORMAT(50X,I1)
  102 FORMAT(50X,I2)
  103 FORMAT(50X,I2,/)
   49 FORMAT(/,/,20(/,50X,I1))
   50 FORMAT(/,50X,F10.5,/,/,50X,I5,/,50X,I5,/,50X,I5,
     *       /,50X,I5,/,50X,I5,/,50X,I5,/)
   51 FORMAT(50X,10(I3,1X))
   52 FORMAT(/,50X,F7.4,/)
   53 FORMAT(50X,F5.2,/,50X,F5.2)
   55 FORMAT(/,24(/,50X,L1))
C---------------------------------------------------------------------
C      Print values from runcard file
C---------------------------------------------------------------------
      WRITE(6,200) COMMEN
      WRITE(6,201) (T(I),I=1,NTAPES)
      WRITE(6,202) NFILES
      WRITE(6,210) MUDRAW,ZBKFMS(1),MUFLAG,DSTFLG,ELFLAG,MCFLAG,DCFLAG,
     *             PRITRI,PRILAB,PRIMU,PRIDC,PRISCA
      WRITE(6,105) (JH(I),I=1,20)
      WRITE(6,599) NREPIN,NREP,JDEBU,JPRLVL,NWRIT,NBWRIT
      WRITE(6,600) (IVFBTG(I),I=1,NVFBTG)
      WRITE(6,603) PKICKM,BCENTR
C---------------------------------------------------------------------
C   FORMAT statements for WRITE
C---------------------------------------------------------------------
  200 FORMAT(1X,60('*'),//,5X,'COMMENT:',7X,A20)
  201 FORMAT(/,5X,'INPUT TAPES:',3X,9(A6,1X))
  202 FORMAT(/,5X,'NUMBER OF FILES PER TAPE:',I4,/)
  210 FORMAT(1X,60('*'),/,1X,'MUDRAW = ',L1,/,
     *                    1X,'ZBKFMS = ',L1,/,
     *                    1X,'MUFLAG = ',L1,/,
     *                    1X,'DSTFLG = ',L1,/,
     *                    1X,'ELFLAG = ',L1,/,
     *                    1X,'MCFLAG = ',L1,/,
     *                    1X,'DCFLAG = ',L1,/,
     *                    1X,'PRITRI = ',L1,/,
     *                    1X,'PRILAB = ',L1,/,
     *                    1X,'PRIMU  = ',L1,/,
     *                    1X,'PRIDC  = ',L1,/,
     *                    1X,'PRISCA = ',L1)
  105 FORMAT(1X,60('*'),/,1X,'JH= ',20I1)
  599 FORMAT(1X,60('*'),/,5X,
     *    5X,'NREP(JLEVEN)=',I5,5X,'NREP(MUEVEN)=',I5,/,
     *    5X,'JDEBU=',I5,5X,'JPRLVL=',I5,/,
     *    5X,'NWRIT=',I5,5X,'NBWRIT=',I5)
  600 FORMAT(1X,60('*'),/,1X,'TEST OF VFB TRIGGER #    : ',10(I3,5X))
  603 FORMAT(1X,60('*'),/,
     *  1X,'              MAGCAL KICK VALUE:   ',F7.4,/,
     *  1X,'              MUON MAGNETIC FIELD: ',F7.4,/)
C---------------------------------------------------------------------
C      Print cuts
C---------------------------------------------------------------------
      DO 97 K=1,24
         IF(XCUT(K))             WRITE(6,*) CUTCOM(K)
         IF(K.EQ.10.AND.XCUT(K)) WRITE(6,98) RCUT,PCUT
 97   CONTINUE
 98   FORMAT('      CUT IN R: ',F5.2,'     CUT IN P: ',F5.2)
      IF(ETCUT.NE.0) WRITE(6,99) ETCUT
 99   FORMAT('      ET BIN ',I1,' IS USED')
C---------------------------------------------------------------------
C  The vector errors are in JERROR and dimensioned to 20.
C  The first group of errors is for siren label error.
C  That vector is in the common MYINFO.
C---------------------------------------------------------------------
      CALL VZERO(JERROR,20)
      CALL VZERO(NCUT,240)
      CALL VZERO(VFBTOT,51)
C---------------------------------------------------------------------
C   Fill the common MUGEOC with data describing the mu spectrometer
C   GEODAT is local routine
C---------------------------------------------------------------------
      CALL GEODAT
C---------------------------------------------------------------------
C   Book histograms
C---------------------------------------------------------------------
      CALL MYBOOK
C--------------------------
C Read run number table
C--------------------------
      I = 0
 83   I = I+1
      READ(36,84,ERR=85,END=85)NUMRUN(I)
 84   FORMAT(6X,I8)
      GOTO 83
 85   CONTINUE
      MXRUN = I-1
      WRITE(6,*)'MXRUN = ',MXRUN
      RETURN
      END
+EOD.
C*********************************************************************
C
C                         M Y E V N T
C
C*********************************************************************
+DECK, MYEVNT. Routine called after each reading
      SUBROUTINE MYEVNT(ISTAT)
C---------------------------------------------------------------------
C   This routine is called for every event
C---------------------------------------------------------------------
C
C                        C O M M O N S
C
C---------------------------------------------------------------------
+CDE,MYINFO.
+CDE,TRACK.
+CDE,MUCOUN.
+CDE,MUSTAT.
+CDE,MUID.
+CDE,HISTO.
+CDE,MUGEOC.
+CDE,MUGNET.
+CDE,SAUNUM.
+CDE,SABCOM.
+CDE,SAEVWR.
+CDE,SAZBID.
+CDE,SAPCTL.
+CDE,SAIOCT.
+CDE,GCLINK.
+CDE,DISET.
+CDE,UGMUCD.
C---------------------------------------------------------------------
C
C                      D E C L A R A T I O N S
C
C---------------------------------------------------------------------
      DIMENSION IKEEP(30)
      LOGICAL TRIGC,BSCIC,ETOTC,SIC,SCIC,CONC,DCCUT,MUCUT,MUHODC
      LOGICAL MUPAIR,FRVFB
      CHARACTER*45 ANBRUN
C---------------------------------------------------------------------
      LWREVT = .FALSE.
C---------------------------------------------------------------------
C     Dump the labels for the first 5 events
C---------------------------------------------------------------------
      IF(PRILAB.AND.JLEVEN.LE.5) CALL LBLIST(1)
C---------------------------------------------------------------------
C    Check if there is a run header and create titles for the histos
C---------------------------------------------------------------------
CC    IF( LBLENG(210 05).NE.0 )THEN
CC      WRITE(6,*) ' START OF RUN'
        CALL FRHEAD(IYMD,IHM,NBRUN)
CCC     WRITE(6,997) NBRUN,IYMD,IHM
CCC     WRITE(ANBRUN,997) NBRUN,IYMD,IHM
  997   FORMAT('RUN NUMBER: ',I6,' DATE AND TIME: ',I6,1X,I4)
CCC     CALL HTITLE(COMMEN//ANBRUN)
        IF(IYMD.GE.870101.AND.IYMD.LE.871231) YEAR=1987
        IF(IYMD.GE.880101.AND.IYMD.LE.881231) YEAR=1988
CC      RETURN
CC    ENDIF
      IF(YEAR.LT.1987) YEAR=1987
C---------------------------------------------------------------------
C    VFB triggers
C---------------------------------------------------------------------
      IF(PRITRI.AND.LBLENG(21504).NE.0) THEN
        CALL LBAPRT(21504)
      ENDIF
C---------------------------------------------------------------------
C    If this is an EOB, update the scalers
C---------------------------------------------------------------------
      IF( LBLENG(210 35).NE.0 ) THEN
        CALL FRSCAL( 0 )
        RETURN
      ENDIF
C---------------------------------------------------------------------
C     Check if we have an event
C---------------------------------------------------------------------
      IF( LBLENG(200 15).EQ.0 ) RETURN
C---------------------------------------------------------------------
C     Update event counter
C---------------------------------------------------------------------
      JLEVEN = JLEVEN + 1
C---------------------------------------------------------------------
C     If we have enough events stop
C---------------------------------------------------------------------
      IF(JLEVEN.GE.NREPIN) ISTAT = -1
C---------------------------------------------------------------------
C     Is this the event to start with ?
C---------------------------------------------------------------------
      IF(JLEVEN.LT.JDEBU) RETURN
C---------------------------------------------------------------------
C
C                   S T A R T     A N A L Y S I S
C
C--- Check run number against table :
C     IF ( LBLENG(21002,1,1) .LE. 0 ) THEN
CCC     WRITE(6,*)'No 21002'
C       RETURN
C     ELSE
C       LEN=1
C       CALL LBCOPY(21002,IRUN,LEN,1,-1,1)
CCC     WRITE(6,*)'IRUN = ',IRUN
        IRUN = NBRUN
        KK = -1
        DO 68 I=1,MXRUN
          IF ( IRUN .EQ. NUMRUN(I) ) THEN
            KK = I
            GOTO 69
          ENDIF
 68     CONTINUE
 69     CONTINUE
        IF ( KK .LT. 0 ) THEN
          RETURN
        ENDIF
CCCC  ENDIF
C---------------------------------------------------------------------
C
C                         T R I G G E R
C
C---------------------------------------------------------------------
      IF(.NOT.MCFLAG) THEN
         CALL TRIGG(TRIGC)
C        IF(TRIGC) RETURN
      ENDIF
      IF(FRVFB(37)) THEN
         YEAR = 1987
      ELSE
         YEAR = 1988
      ENDIF
      IF(MCFLAG) YEAR = 1988
C---------------------------------------------------------------------
C     Fill common /ZPOS/ with z positions
C---------------------------------------------------------------------
      CALL ZDETEC
C---------------------------------------------------------------------
C     Update event counter of good events
C---------------------------------------------------------------------
      MUEVEN = MUEVEN + 1
C---------------------------------------------------------------------
C     If we have enough good events stop
C---------------------------------------------------------------------
      IF(MUEVEN.GE.NREP) ISTAT = -1
C---------------------------------------------------------------------
C
C                    M U O N      C H A M B E R S
C
C---------------------------------------------------------------------
      IF(.NOT.DSTFLG.AND.MUFLAG) CALL MURAW(MUCUT)
      IF(DSTFLG.AND.MUFLAG)      CALL MUDST(MUCUT)
      IF(XCUT(1).AND.MUCUT)      RETURN
C     IF(DSTFLG.AND.MUFLAG)      CALL MUFIX
      IF(MUFLAG)                 CALL MUFILT(MUCUT)
 
      IF(XCUT(1).AND.MUCUT)      RETURN
      NCUT(1,1) = NCUT(1,1) + 1
C---------------------------------------------------------------------
C
C                            S I P A D
C
C---------------------------------------------------------------------
      IF(.NOT.MCFLAG) CALL SIPAD(SIC)
      IF(.NOT.MCFLAG) CALL SIPAD2
 
      IF(XCUT(5).AND.SIC)  RETURN
      NCUT(5,1) = NCUT(5,1) + 1
C---------------------------------------------------------------------
C
C                    D R I F T    C H A M B E R S
C
C---------------------------------------------------------------------
      IF(DCFLAG)                 CALL DC(DCCUT)
      IF(DCFLAG.AND.JH(13).EQ.1) CALL DCVTX
      IF(DCFLAG.AND.JH(15).EQ.1) CALL DCSEP
 
      IF(XCUT(2).AND.DCCUT)      RETURN
      NCUT(2,1) = NCUT(2,1) + 1
C---------------------------------------------------------------------
C
C                      B E A M   C O U N T E R S
C
C---------------------------------------------------------------------
      IF((XCUT(3).OR.JH(8).EQ.1).AND.YEAR.LE.1987) CALL BSC87(BSCIC)
      IF((XCUT(3).OR.JH(8).EQ.1).AND.YEAR.EQ.1988) CALL BSC88(BSCIC)
 
      IF(XCUT(3).AND.BSCIC)      RETURN
      NCUT(3,1) = NCUT(3,1) + 1
C---------------------------------------------------------------------
C
C                             E T O T
C
C---------------------------------------------------------------------
      IF(XCUT(4).OR.JH(9).EQ.1) CALL ENERGY(ETOTC)
 
      IF(XCUT(4).AND.ETOTC)     RETURN
      NCUT(4,1) = NCUT(4,1) + 1
C---------------------------------------------------------------------
C
C                 S C I N T I L L A T O R     P A D S
C
C---------------------------------------------------------------------
      IF(.NOT.MCFLAG.AND.(XCUT(6).OR.ELFLAG))  CALL SCIPAD(SCIC)
 
      IF(XCUT(6).AND.SCIC)      RETURN
      NCUT(6,1) = NCUT(6,1) + 1
C---------------------------------------------------------------------
C
C                 C O N E     C A L     S C I N T.
C
C---------------------------------------------------------------------
      IF(XCUT(7).OR.JH(4).EQ.1) CALL CONCAL(CONC)
 
      IF(XCUT(7).AND.CONC)      RETURN
      NCUT(7,1) = NCUT(7,1) + 1
C---------------------------------------------------------------------
C
C                 M U O N     H O D O S C O P E
C
C---------------------------------------------------------------------
      IF(XCUT(8).OR.JH(6).EQ.1) CALL HODOSC(MUHODC)
 
      IF(XCUT(8).AND.MUHODC)    RETURN
      NCUT(8,1) = NCUT(8,1) + 1
C---------------------------------------------------------------------
C
C                    M U O N  -  D C    M A T C H
C
C---------------------------------------------------------------------
      IF(MUFLAG.AND.DCFLAG) CALL MUDC
C---------------------------------------------------------------------
C
C                    M U O N     P A I R S
C
C---------------------------------------------------------------------
      IF(MUFLAG.AND.JH(12).NE.0) CALL MUMURA(MUPAIR)
      IF(MUFLAG.AND.JH(10).NE.0) CALL MUMU(MUPAIR)
      IF(MUFLAG.AND.JH(14).NE.0) CALL MUONE
      IF((XCUT(9).OR.XCUT(10)).AND.MUPAIR) RETURN
      NCUT(9,1) = NCUT(9,1) + 1
C---------------------------------------------------------------------
C
C      S E T    F L A G    T O   W R I T E   O U T   E V E N T
C
C---------------------------------------------------------------------
      IF(NOTPTS.GE.1) THEN
        LWREVT = .TRUE.
      ELSE
        LWREVT = .FALSE.
      ENDIF
C---------------------------------------------------------------------
C
C        S E L E C T   L A B E L S   T O   W R I T E   O U T
C
C---------------------------------------------------------------------
C     IKEEP(1) =   +20
C     IKEEP(2) =  4206
C     IKEEP(3) =  6106
C     IKEEP(4) =  8806
C     IKEEP(5) =  9006
C     IKEEP(6) = 21005
C     IKEEP(7) = 21006
C     IKEEP(8) = 21015
C     IKEEP(9) = 21016
C     IKEEP(10)= 21035
C     IKEEP(11)= 21504
C     IKEEP(12)= 22106
C     IKEEP(13)= 22206
C     IKEEP(14)= 22906
C     IKEEP(15)= 23406
C     IKEEP(16)= 23506
C     IKEEP(17)= 33106
C     IKEEP(18)= 33206
C     IKEEP(19)= 50017
C     IKEEP(20)= 50027
C     IKEEP(21)=  7807
C     CALL LBEDIT(IKEEP)
C---------------------------------------------------------------------
C
C        C R E A T E   N E W   M U O N   D S T   L A B E L
C
C---------------------------------------------------------------------
C     IF(.NOT.DSTFLG.AND.MUFLAG) CALL NEWLAB
C---------------------------------------------------------------------
C
C        C R E A T E   M U O N   P O I N T E R   L A B E L
C
C---------------------------------------------------------------------
C     CALL MUPOIN
C---------------------------------------------------------------------
C
C                      D U M P   E V E N T S
C
C---------------------------------------------------------------------
      IF(PRIDC.AND.MUEVEN.LE.100)            CALL DCDUMP
      IF(PRIMU.AND.MUEVEN.LE.100)            CALL MUDUMP
C     IF(DSTFLG.AND.MUFLAG.AND.MUEVEN.LE.25) CALL PODUMP
      RETURN
      END
+EOD.
C*********************************************************************
C
C                         M Y O U T
C
C*********************************************************************
+DECK, MYOUT. Routine called after reading is finished
      SUBROUTINE MYOUT(IRUN)
+CDE,MYINFO,FRSCLL.
+CDE,MUCOUN,HISTO.
+CDE,MUSTAT.
+CDE,SAPCTL.
+CDE,COMB.
      COMMON/ETBIN/ NETBIN(5),NSIBIN(5)
      CHARACTER*80   CMD
C---------------------------------------------------------------------
C    Write out scalers
C---------------------------------------------------------------------
      IF(PRISCA) CALL FRSCAL( 1 )
C---------------------------------------------------------------------
C    Print the VFB trigger scalers
C---------------------------------------------------------------------
      WRITE(6,*)' *******************************************************
     *******'
      WRITE(6,*)' *            OUTPUT OF THE VFB TRIGGER SCALERS
     *     *'
      WRITE(6,*)' *******************************************************
     *******'
      DO 990 I = 1,51
         IF(VFBTOT(I).NE.0) THEN
            WRITE(6,*) ' VFB TRIGGER NO ',I,' : ',VFBTOT(I)
         ENDIF
  990 CONTINUE
      WRITE(6,*)' *******************************************************
     *******'
C---------------------------------------------------------------------
C    Print number of events
C---------------------------------------------------------------------
      WRITE(6,11) NRUNS,NEVRUN(1),NEVTOT(1),NEVWRT(1),TLEFT,TQUIT
 11   FORMAT(' NRUNS NEVRUN NEVTOT NEVWRT TLEFT TQUIT',/,4I6,3X,2F6.0)
      WRITE(6,*)' *******************************************************
     *******'
      WRITE(6,*)'    Total number of events:      ',JLEVEN
      WRITE(6,*)' *******************************************************
     *******'
      WRITE(6,*)'    Events with selected trigger:',MUEVEN
      WRITE(6,*)' *******************************************************
     *******'
C---------------------------------------------------------------------
C    ET statistics
C---------------------------------------------------------------------
        WRITE(6,1) NETBIN(1)
 1      FORMAT(/,9X,'0   < ET < 1.5 GEV  ==>',I5)
        WRITE(6,2) NETBIN(2)
 2      FORMAT(/,9X,'1.5 < ET < 3   GEV  ==>',I5)
        WRITE(6,3) NETBIN(3)
 3      FORMAT(/,9X,'3   < ET < 4.5 GEV  ==>',I5)
        WRITE(6,4) NETBIN(4)
 4      FORMAT(/,9X,'4.5 < ET < 6   GEV  ==>',I5)
        WRITE(6,5) NETBIN(5)
 5      FORMAT(/,9X,'6   < ET < 9   GEV  ==>',I5)
      WRITE(6,*)' *******************************************************
     *******'
        WRITE(6,6) NSIBIN(1)
 6      FORMAT(/,9X,'DC MULT = 2,3   ==>',I5)
        WRITE(6,7) NSIBIN(2)
 7      FORMAT(/,9X,'DC MULT = 4,5   ==>',I5)
        WRITE(6,8) NSIBIN(3)
 8      FORMAT(/,9X,'DC MULT = 6,7   ==>',I5)
        WRITE(6,9) NSIBIN(4)
 9      FORMAT(/,9X,'DC MULT = 8-10  ==>',I5)
        WRITE(6,10) NSIBIN(5)
 10     FORMAT(/,9X,'DC MULT = 11-14 ==>',I5,/)
      WRITE(6,*)' *******************************************************
     *******'
C---------------------------------------------------------------------
C    Cut statistics
C---------------------------------------------------------------------
      IF(MUEVEN.EQ.0) GO TO 999
      IF(XCUT(1)) THEN
        WRITE(6,1012) NCUT(1,2),FLOAT(NCUT(1,2))/FLOAT(MUEVEN)
 1012   FORMAT(/,9X,'# mu tracks > 1          ==>',I5,F10.3)
        WRITE(6,1013) NCUT(1,3),FLOAT(NCUT(1,3))/FLOAT(MUEVEN)
 1013   FORMAT(9X,'# hits in PC0 & 1 < 50   ==>',I5,F10.3)
        WRITE(6,1014) NCUT(1,4),FLOAT(NCUT(1,4))/FLOAT(MUEVEN)
 1014   FORMAT(9X,'Momentum > 0             ==>',I5,F10.3)
        WRITE(6,1015) NCUT(1,5),FLOAT(NCUT(1,5))/FLOAT(MUEVEN)
 1015   FORMAT(9X,'Chisquare/NDF < 5        ==>',I5,F10.3)
        WRITE(6,1016) NCUT(1,6),FLOAT(NCUT(1,6))/FLOAT(MUEVEN)
 1016   FORMAT(9X,'Hodoscope cut            ==>',I5,F10.3)
        WRITE(6,1017) NCUT(1,7),FLOAT(NCUT(1,7))/FLOAT(MUEVEN)
 1017   FORMAT(9X,'Mult. scatt. angle < 2.5 ==>',I5,F10.3,/)
        WRITE(6,101) NCUT(1,1),FLOAT(NCUT(1,1))/FLOAT(MUEVEN)
 101    FORMAT(5X,'After Muon track cuts    ==>',I5,F10.3)
      ENDIF
      IF(XCUT(2)) WRITE(6,102) NCUT(2,1),FLOAT(NCUT(2,1))/FLOAT(MUEVEN)
 102  FORMAT(5X,'After DC track cut       ==>',I5,F10.3)
      IF(XCUT(3)) THEN
         WRITE(6,1032) NCUT(3,2),FLOAT(NCUT(3,2))/FLOAT(MUEVEN)
 1032    FORMAT(/,9X,'After plastic scint. cut ==>',I5,F10.3)
         WRITE(6,1033) NCUT(3,3),FLOAT(NCUT(3,3))/FLOAT(MUEVEN)
 1033    FORMAT(9X,'After large veto cut     ==>',I5,F10.3)
         WRITE(6,1034) NCUT(3,4),FLOAT(NCUT(3,4))/FLOAT(MUEVEN)
 1034    FORMAT(9X,'After small veto cut     ==>',I5,F10.3)
         WRITE(6,1035) NCUT(3,5),FLOAT(NCUT(3,5))/FLOAT(MUEVEN)
 1035    FORMAT(9X,'After INT multi hit TDC  ==>',I5,F10.3)
         WRITE(6,1036) NCUT(3,6),FLOAT(NCUT(3,6))/FLOAT(MUEVEN)
 1036    FORMAT(9X,'After LV  multi hit TDC  ==>',I5,F10.3,/)
         WRITE(6,103) NCUT(3,1),FLOAT(NCUT(3,1))/FLOAT(MUEVEN)
 103     FORMAT(5X,'After beam scint. cut    ==>',I5,F10.3)
      ENDIF
      IF(XCUT(4)) WRITE(6,104) NCUT(4,1),FLOAT(NCUT(4,1))/FLOAT(MUEVEN)
 104  FORMAT(5X,'After Etot cut           ==>',I5,F10.3)
      IF(XCUT(5)) WRITE(6,105) NCUT(5,1),FLOAT(NCUT(5,1))/FLOAT(MUEVEN)
 105  FORMAT(5X,'After Si pad cut         ==>',I5,F10.3)
      IF(XCUT(6)) THEN
         WRITE(6,1062) NCUT(6,2),FLOAT(NCUT(6,2))/FLOAT(MUEVEN)
 1062    FORMAT(/,9X,'After single disc. cut   ==>',I5,F10.3)
         WRITE(6,1063) NCUT(6,3),FLOAT(NCUT(6,3))/FLOAT(MUEVEN)
 1063    FORMAT(9X,'After double disc. cut   ==>',I5,F10.3,/)
         WRITE(6,106) NCUT(6,1),FLOAT(NCUT(6,1))/FLOAT(MUEVEN)
 106     FORMAT(5X,'After Scint. Pad cut     ==>',I5,F10.3)
         ENDIF
      IF(XCUT(7)) WRITE(6,107) NCUT(7,1),FLOAT(NCUT(7,1))/FLOAT(MUEVEN)
 107  FORMAT(5X,'After Cone cal cut       ==>',I5,F10.3)
      IF(XCUT(8)) WRITE(6,108) NCUT(8,1),FLOAT(NCUT(8,1))/FLOAT(MUEVEN)
 108  FORMAT(5X,'After mu hodoscope cut   ==>',I5,F10.3)
      IF(XCUT(9).OR.XCUT(10))
     *WRITE(6,109) NCUT(9,1),FLOAT(NCUT(9,1))/FLOAT(MUEVEN)
 109  FORMAT(5X,'After muon pair cut      ==>',I5,F10.3)
 999  CONTINUE
C---------------------------------------------------------------------
C    Calculate comb. background
C---------------------------------------------------------------------
      CALL MUCOMB
C---------------------------------------------------------------------
C    Output histograms
C---------------------------------------------------------------------
      CALL HBLACK(0)
      CALL H1EVLI(0)
      CALL HISTDO
C---------------------------------------------------------------------
C    Put histograms on file
C---------------------------------------------------------------------
      IF(MUDRAW) THEN
C        CMD = 'FILEDEF 75 DISK '//FILEN//' DATA A'
C        WRITE(6,*) ' THE FILE DEFINITION OF THE HISTOGRAM FILE IS:'
C        WRITE(6,*) CMD
C        CALL VMCMS(CMD,IERR)
C        IF(IERR.NE.0) WRITE(6,*) 'PROBLEMS WITH HIST. FILE, IERR:',IERR
C        CALL HSTORE(0,75)
         CALL HWRITE(0,75,1,10000,-1,NOMORE)
      ENDIF
      RETURN
      END
+EOD.
C*********************************************************************
C
C                         T R I G G
C
C*********************************************************************
+DECK,TRIGG. Subroutine to test trigger
      SUBROUTINE TRIGG(TRIGC)
C---------------------------------------------------------------------
C    Subroutine that checks if there is a valid trigger
C---------------------------------------------------------------------
+CDE,MYINFO.
      COMMON/HISTO/JH(20),LH(20)
      DIMENSION IPRE(10)
      INTEGER   ISPY( 5 ), IBIT( 16,5 )
C---------------------------------------------------------------------
C  FRVFB,FRCEDA & FRVETO are logical functions in FREJA
C---------------------------------------------------------------------
      LOGICAL FRVFB, FRCEDA, FRVETO
      LOGICAL TRIGC,FRSPY(80)
+CDE,BITLOGIC.
 
      DATA I1  /0/
      DATA I2  /0/
      DATA IBIT/  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     *           10, 9, 8, 7, 6, 5, 4, 3, 2, 1,20,19,18,17,16,15,
     *           14,13,12,11,30,29,28,27,26,25,24,23,22,21,40,39,
     *           38,37,36,35,34,33,32,31,50,49,48,47,46,45,44,43,
     *           42,41, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0/
      TRIGC=.FALSE.
C---------------------------------------------------------------------
C     Count the # of VFB triggers
C---------------------------------------------------------------------
      DO 4 I = 1,51
        IF(FRVFB(I)) THEN
          VFBTOT(I) = VFBTOT(I)+1
          VI=I
          IF(JH(7).NE.0) CALL HFILL(LH(7)+1,VI,0.,1.)
        ENDIF
    4 CONTINUE
C---------------------------------------------------------------------
C    Make cut on VFB trigger IVFBTG which is set in the runcards
C---------------------------------------------------------------------
      IF(.NOT.FRVFB(IVFBTG).AND.IVFBTG(1).NE.0) TRIGC=.TRUE.
C---------------------------------------------------------------------
C    Pick up SPY information
C    ( BTEST(I,N) is a standard logical function which checks if bit
C      N in word I is on )
C---------------------------------------------------------------------
      LABEL  = 22206
      LENGTH = 5
      IF(LBLENG(LABEL).EQ.0) CALL LSTOP(LABEL)
      CALL LBCOPY(LABEL,ISPY,LENGTH)
      DO 100 I = 1,5
        DO 200 J = 0,15
          FRSPY(IBIT(J+1,I)) = .NOT.BTEST( ISPY(I), J )
 200    CONTINUE
 100  CONTINUE
C---------------------------------------------------------------------
C    Cut away MT-events
C---------------------------------------------------------------------
      IF(FRSPY(42).AND.IVFBTG(1).NE.2) TRIGC=.TRUE.
C---------------------------------------------------------------------
C    Return if it is the wrong trigger
C---------------------------------------------------------------------
      IF(TRIGC) RETURN
C---------------------------------------------------------------------
C    Check the SPY trigger bits
C---------------------------------------------------------------------
      DO 5 I = 1,50
        IF(JH(7).NE.0.AND.FRSPY(I)) THEN
          VI=I
          CALL HFILL(LH(7)+2,VI,0.,1.)
        ENDIF
  5   CONTINUE
C---------------------------------------------------------------------
C    Check the PRE trigger bits
C---------------------------------------------------------------------
      LABEL = 23506
      LENGTH = 10
      CALL LBCOPY(LABEL,IPRE,LENGTH,1,-1,1)
      DO 10 I = 1,2
         ISHIFT =(I-1)*16
         DO 20 J = 0,15
            FRPRE(ISHIFT+J+1) = .FALSE.
            IF(BTEST(IPRE(I),J)) FRPRE(ISHIFT+J+1) = .TRUE.
   20    CONTINUE
   10 CONTINUE
      DO 6 I = 17,24
        IF(FRPRE(I)) THEN
          VI=I-16
          IF(JH(7).NE.0) CALL HFILL(LH(7)+3,VI,0.,1.)
        ENDIF
  6   CONTINUE
      IF(.NOT.FRPRE(17).AND.I1.NE.1) THEN
        WRITE(6,*) ' W A R N I N G  NO VINT'
        I1=1
      ENDIF
      IF(.NOT.FRPRE(20).AND..NOT.FRPRE(21).AND.I2.NE.1) THEN
        WRITE(6,*) ' W A R N I N G  NO MU-PRE'
        I2=1
      ENDIF
      RETURN
      END
+EOD.
C*********************************************************************
C
C                         B S C 8 7
C
C*********************************************************************
+DECK,BSC87. Subroutine to study beam scintillation counters
      SUBROUTINE BSC87(BSCIC)
C---------------------------------------------------------------------
C    Subroutine that checks the signals from the beam counters
C---------------------------------------------------------------------
+CDE,MYINFO.
      COMMON/HISTO/JH(20),LH(20)
      DIMENSION ADCBM(2),ADCSV(2),ADCLV(2),AA(12),
     *          TDCBM(2),TDCSV(2),TDCLV(2),TDCMUL(3,8),
     *          TINTDC(8),GMUTDC(48),GENADC(48),GENTDC(48),GENDIS(3)
      INTEGER GMUTDC,GENADC,GENTDC,GENDIS
      LOGICAL BSCIC,SV,LV
      SAVE ISTAT, B6APED, B6BPED, B3APED, B3BPED, B7APED, B7BPED
      DATA ISTAT/1/
      DATA B6APED/50./, B6BPED/0./, B3APED/0./, B3BPED/0./,
     *B7APED/0./, B7BPED/0./, B1APED/80./, B1BPED/120./, B2PED/180./
      DATA B6ATDC/1.75/, B6BTDC/0./, B3ATDC/-2.48/, B3BTDC/-3.93/,
     *     B7ATDC/0./, B7BTDC/0./
      DATA TDCB/250./, TDCI/200./, TDCV/1365./
      BSCIC=.FALSE.
C---------------------------------------------------------------------
C    Unpack beam scint. ADC's
C---------------------------------------------------------------------
      LABEL = 406
      LENGTH = 24
      CALL LBCOPY(LABEL,GENADC,LENGTH,1,-1,1)
      IF(LENGTH.EQ.0) CALL LSTOP(LABEL)
 
      DO 945 II=1,12
      AA(II)=FLOAT(GENADC(II+12))
945   CONTINUE
 
      ADCB1A   = FLOAT(GENADC(2)) -B1APED
      ADCB1B   = FLOAT(GENADC(3)) -B1BPED
      ADCB2    = FLOAT(GENADC(4)) -B2PED
      ADCBM(1) = FLOAT(GENADC(15))-B6APED
      ADCBM(2) = FLOAT(GENADC(16))-B6BPED
      ADCSV(1) = FLOAT(GENADC(13))-B3APED
      ADCSV(2) = FLOAT(GENADC(14))-B3BPED
      ADCLV(1) = FLOAT(GENADC(17))-B7APED
      ADCLV(2) = FLOAT(GENADC(18))-B7BPED
C---------------------------------------------------------------------
C    Unpack beam scint. TDC's. (Flight time B6-B3 is about 7.3 ns).
C---------------------------------------------------------------------
      LABEL = 206
      LENGTH = 48
      CALL LBCOPY(LABEL,GENTDC,LENGTH,1,-1,1)
      IF(LENGTH.EQ.0) CALL LSTOP(LABEL)
      TDCBM(1) = .05 * FLOAT(GENTDC(38)) + B6ATDC
      TDCBM(2) = .05 * FLOAT(GENTDC(39)) + B6BTDC
      TDCSV(1) = .05 * FLOAT(GENTDC(36)) + B3ATDC
      TDCSV(2) = .05 * FLOAT(GENTDC(37)) + B3BTDC
      TDCLV(1) = .05 * FLOAT(GENTDC(41)) + B7ATDC
      TDCLV(2) = .05 * FLOAT(GENTDC(42)) + B7BTDC
C---------------------------------------------------------------------
C    Calculate slewing correction
C---------------------------------------------------------------------
C     IF(ADCSV(1).GT.60..AND.ADCSV(1).LT.1000..AND.TDCSV(1).LT.41.)
C    *  THEN
C       C1 = ADCSV(1) * (TDCSV(1)-35.4)
C       IF(JH(8).NE.0) CALL HFILL(LH(8)+31,C1,0.,1.)
C     ENDIF
C     IF(ADCSV(1).GT.1000..AND.TDCSV(1).LT.41.) THEN
C       C2 = ADCSV(1) * (TDCSV(1)-35.4)
C       IF(JH(8).NE.0) CALL HFILL(LH(8)+32,C2,0.,1.)
C     ENDIF
C     IF(ADCSV(2).GT.60..AND.ADCSV(2).LT.1000..AND.TDCSV(2).LT.41.)
C    *  THEN
C       C3 = ADCSV(2) * (TDCSV(2)-35.4)
C       IF(JH(8).NE.0) CALL HFILL(LH(8)+33,C3,0.,1.)
C     ENDIF
C     IF(ADCSV(2).GT.1000..AND.TDCSV(2).LT.41.) THEN
C       C4 = ADCSV(2) * (TDCSV(2)-35.4)
C       IF(JH(8).NE.0) CALL HFILL(LH(8)+34,C4,0.,1.)
C     ENDIF
C---------------------------------------------------------------------
C    Make slewing correction
C---------------------------------------------------------------------
      IF(ADCSV(1).GT.60..AND.ADCSV(1).LT.1000..AND.TDCSV(1).LT.41.)
     *TDCSV(1) = TDCSV(1) - 400./ADCSV(1)
      IF(ADCSV(2).GT.60..AND.ADCSV(2).LT.1000..AND.TDCSV(2).LT.41.)
     *TDCSV(2) = TDCSV(2) - 480./ADCSV(2)
C---------------------------------------------------------------------
C    Calculate T0, TSV AND TOF
C---------------------------------------------------------------------
      T0  = (TDCBM(1)+TDCBM(2))/2.
      TSV = -9999.
      IF(ADCSV(1).GE.60..AND.ADCSV(2).GE.60.) TSV=(TDCSV(1)+TDCSV(2))/2.
      IF(ADCSV(1).GE.60..AND.ADCSV(2).LT.60.) TSV=TDCSV(1)
      IF(ADCSV(1).LT.60..AND.ADCSV(2).GE.60.) TSV=TDCSV(2)
      TOF = TSV - T0
C---------------------------------------------------------------------
C    Unpack bit registers (LV OR & SV OR & MU T/O)
C---------------------------------------------------------------------
      LABEL = 106
      LENGTH= 3
      CALL LBCOPY(LABEL,GENDIS,LENGTH,1,-1,1)
      IF(LENGTH.EQ.0) CALL LSTOP(LABEL)
      SV   = BTEST(GENDIS(1),6)
      LV   = BTEST(GENDIS(1),9)
C---------------------------------------------------------------------
C    Unpack multi-hit TDC's
C---------------------------------------------------------------------
      LABEL = 22406
      LENGTH = 48
      CALL LBCOPY(LABEL,GMUTDC,LENGTH,1,-1,1)
      IF(LENGTH.EQ.0) CALL LSTOP(LABEL)
      DO 50 I = 1,8
         KK = 1 + (I-1)*2
         I1 = GMUTDC(KK)
         I2 = GMUTDC(KK+1)
         IF(I1.NE.0.OR.I2.NE.0) TDCMUL(1,I) = FJOIN(I1,I2) + TDCB
         IF(I.GE.7) GO TO 50
         KK = 17 + (I-1)*2
         I1 = GMUTDC(KK)
         I2 = GMUTDC(KK+1)
         IF(I1.NE.0.OR.I2.NE.0) TDCMUL(2,I) = FJOIN(I1,I2) + TDCI
         IF(I.GE.5) GO TO 50
         KK = 33 + (I-1)*2
         I1 = GMUTDC(KK)
         I2 = GMUTDC(KK+1)
         IF(I1.NE.0.OR.I2.NE.0) TDCMUL(3,I) = FJOIN(I1,I2) + TDCV
   50 CONTINUE
C---------------------------------------------------------------------
C    Plot histograms
C---------------------------------------------------------------------
      IF(JH(8).NE.0) THEN
         CALL HFILL(LH(8)-2,ADCB1A,0.,1.)
         CALL HFILL(LH(8)-1,ADCB1B,0.,1.)
         CALL HFILL(LH(8)+0,ADCB2,0.,1.)
         CALL HFILL(LH(8)+1,ADCBM(1),0.,1.)
         CALL HFILL(LH(8)+2,ADCBM(2),0.,1.)
         CALL HFILL(LH(8)+3,ADCSV(1),0.,1.)
         CALL HFILL(LH(8)+4,ADCSV(2),0.,1.)
         IF(TDCSV(1).GT.31.AND.TDCSV(1).LT.41.)
     *   CALL HFILL(LH(8)+5,ADCSV(1),0.,1.)
         IF(TDCSV(2).GT.31.AND.TDCSV(2).LT.41.)
     *   CALL HFILL(LH(8)+6,ADCSV(2),0.,1.)
         CALL HFILL(LH(8)+7,ADCLV(1),0.,1.)
         CALL HFILL(LH(8)+8,ADCLV(2),0.,1.)
         CALL HFILL(LH(8)+9,TDCBM(1),0.,1.)
         CALL HFILL(LH(8)+10,TDCBM(2),0.,1.)
         CALL HFILL(LH(8)+11,TDCSV(1),0.,1.)
         CALL HFILL(LH(8)+12,TDCSV(2),0.,1.)
         CALL HFILL(LH(8)+13,T0,0.,1.)
         CALL HFILL(LH(8)+14,TSV,0.,1.)
         CALL HFILL(LH(8)+15,TOF,0.,1.)
         DO 100 I = 1,8
            CALL HFILL(LH(8)+16,TDCMUL(1,I),0.,1.)
            IF(I.GE.7) GO TO 100
            CALL HFILL(LH(8)+17,TDCMUL(2,I),0.,1.)
            IF(I.GE.5) GO TO 100
            CALL HFILL(LH(8)+18,TDCMUL(3,I),0.,1.)
 100     CONTINUE
         IF(TDCSV(1).GT.34.0.AND.TDCSV(1).LT.35.2)
     *   CALL HFILL(LH(8)+19,ADCSV(1),0.,1.)
         IF(TDCSV(1).GT.35.2.AND.TDCSV(1).LT.40.0)
     *   CALL HFILL(LH(8)+20,ADCSV(1),0.,1.)
         IF(TDCSV(2).GT.33.8.AND.TDCSV(2).LT.35.4)
     *   CALL HFILL(LH(8)+21,ADCSV(2),0.,1.)
         IF(TDCSV(2).GT.35.4.AND.TDCSV(2).LT.40.0)
     *   CALL HFILL(LH(8)+22,ADCSV(2),0.,1.)
      ENDIF
C---------------------------------------------------------------------
C    Make the cuts
C---------------------------------------------------------------------
      IF(ADCB1A.LE.0..OR.ADCB1B.LE.0..OR.ADCB2.LE.0.) THEN
         BSCIC=.TRUE.
         RETURN
      ELSE
         NCUT(3,2)=NCUT(3,2)+1
      ENDIF
      IF(ADCLV(1).GE.60..OR.ADCLV(2).GE.60.) THEN
         BSCIC=.TRUE.
         RETURN
      ELSE
         NCUT(3,3)=NCUT(3,3)+1
      ENDIF
      IF((ADCSV(1).GE.80..OR.ADCSV(2).GE.80.).AND.(TOF.LE.9.)) THEN
         BSCIC=.TRUE.
         RETURN
      ELSE
         NCUT(3,4)=NCUT(3,4)+1
      ENDIF
      DO 200 I = 1,6
        T2=TDCMUL(2,I)
        IF((T2.GE.-2000..AND.T2.LE.-100.).OR.
     *  (T2.GE.100.AND.T2.LE.2000.))
     *      BSCIC=.TRUE.
 200  CONTINUE
      IF(BSCIC) RETURN
      NCUT(3,5)=NCUT(3,5)+1
      DO 201 I = 1,4
        T3=TDCMUL(3,I)
        IF(T3.GE.-700..AND.T3.LE.2000.)
     *      BSCIC=.TRUE.
 201  CONTINUE
      IF(BSCIC) RETURN
      NCUT(3,6)=NCUT(3,6)+1
      RETURN
      END
+EOD.
C*********************************************************************
C
C                         B S C 8 8
C
C*********************************************************************
+DECK,BSC88. Subroutine to study beam scintillation counters
      SUBROUTINE BSC88(BSCIC)
C---------------------------------------------------------------------
C    Subroutine that checks the signals from the beam counters
C---------------------------------------------------------------------
+CDE,MYINFO.
      COMMON/HISTO/JH(20),LH(20)
      DIMENSION ADCBM(2),ADCSV(2),ADCLV(2),TDCMUL(3,8),
     *          GMUTDC(48),GENADC(48),GENDIS(3)
      INTEGER GMUTDC,GENADC,GENDIS
      LOGICAL BSCIC,SV,LV
      SAVE ISTAT, B6APED, B6BPED, B3APED, B3BPED, B7APED, B7BPED
      DATA ISTAT/1/
      DATA B6APED/20./,   B6BPED/20./,   B3APED/90./,   B3BPED/90./,
     *     B7APED/20./,   B7BPED/20./
      DATA TDCB/250./,    TDCI/200./,    TDCV/75./
      BSCIC=.FALSE.
C---------------------------------------------------------------------
C    Unpack beam scint. ADC's
C---------------------------------------------------------------------
      LABEL = 406
      LENGTH = 24
      CALL LBCOPY(LABEL,GENADC,LENGTH,1,-1,1)
      IF(LENGTH.EQ.0) CALL LSTOP(LABEL)
      ADCBM(1) = FLOAT(GENADC(19))-B6APED
      ADCBM(2) = FLOAT(GENADC(20))-B6BPED
      ADCSV(1) = FLOAT(GENADC(13))-B3APED
      ADCSV(2) = FLOAT(GENADC(14))-B3BPED
      ADCLV(1) = FLOAT(GENADC(17))-B7APED
      ADCLV(2) = FLOAT(GENADC(18))-B7BPED
C---------------------------------------------------------------------
C    Unpack multi-hit TDC's
C---------------------------------------------------------------------
      LABEL = 22406
      LENGTH = 48
      CALL LBCOPY(LABEL,GMUTDC,LENGTH,1,-1,1)
      IF(LENGTH.EQ.0) CALL LSTOP(LABEL)
      DO 50 I = 1,8
         KK = 1 + (I-1)*2
         I1 = GMUTDC(KK)
         I2 = GMUTDC(KK+1)
         IF(I1.NE.0.OR.I2.NE.0) TDCMUL(1,I) = FJOIN(I1,I2) + TDCB
         IF(I.GE.7) GO TO 50
         KK = 17 + (I-1)*2
         I1 = GMUTDC(KK)
         I2 = GMUTDC(KK+1)
         IF(I1.NE.0.OR.I2.NE.0) TDCMUL(2,I) = FJOIN(I1,I2) + TDCI
         IF(I.GE.5) GO TO 50
         KK = 33 + (I-1)*2
         I1 = GMUTDC(KK)
         I2 = GMUTDC(KK+1)
         IF(I1.NE.0.OR.I2.NE.0) TDCMUL(3,I) = FJOIN(I1,I2) + TDCV
   50 CONTINUE
C---------------------------------------------------------------------
C    Plot histograms
C---------------------------------------------------------------------
      IF(JH(8).NE.0) THEN
         CALL HFILL(LH(8)+1,ADCBM(1),0.,1.)
         CALL HFILL(LH(8)+2,ADCBM(2),0.,1.)
         CALL HFILL(LH(8)+3,ADCSV(1),0.,1.)
         CALL HFILL(LH(8)+4,ADCSV(2),0.,1.)
         CALL HFILL(LH(8)+7,ADCLV(1),0.,1.)
         CALL HFILL(LH(8)+8,ADCLV(2),0.,1.)
         DO 100 I = 1,8
            CALL HFILL(LH(8)+16,TDCMUL(1,I),0.,1.)
            IF(I.GE.7) GO TO 100
            CALL HFILL(LH(8)+17,TDCMUL(2,I),0.,1.)
            IF(I.GE.5) GO TO 100
            CALL HFILL(LH(8)+18,TDCMUL(3,I),0.,1.)
 100     CONTINUE
      ENDIF
C---------------------------------------------------------------------
C    Make the cuts
C---------------------------------------------------------------------
      IF(ADCBM(1).LE.0..OR.ADCBM(2).LE.0.) THEN
         BSCIC=.TRUE.
         RETURN
      ELSE
         NCUT(3,2)=NCUT(3,2)+1
      ENDIF
      IF(ADCLV(1).GE.0..OR.ADCLV(2).GE.0.) THEN
         BSCIC=.TRUE.
         RETURN
      ELSE
         NCUT(3,3)=NCUT(3,3)+1
      ENDIF
      IF(ADCSV(1).GE.0..OR.ADCSV(2).GE.0.) THEN
         BSCIC=.TRUE.
         RETURN
      ELSE
         NCUT(3,4)=NCUT(3,4)+1
      ENDIF
      DO 200 I = 1,6
        T2=TDCMUL(2,I)
        IF((T2.GE.-1500..AND.T2.LE.-50.).OR.
     *  (T2.GE.50.AND.T2.LE.2000.))
     *      BSCIC=.TRUE.
 200  CONTINUE
      IF(BSCIC) RETURN
      NCUT(3,5)=NCUT(3,5)+1
      DO 201 I = 1,4
        T3=TDCMUL(3,I)
        IF(T3.GE.-1500..AND.T3.LE.1500.)
     *      BSCIC=.TRUE.
 201  CONTINUE
      IF(BSCIC) RETURN
      NCUT(3,6)=NCUT(3,6)+1
      RETURN
      END
+EOD.
C*********************************************************************
C
C                         F J O I N
C
C*********************************************************************
+DECK,FJOIN.
      FUNCTION FJOIN (INT1,INT2)
C---------------------------------------------------------------------
C     This routine is used to unpack two VAX words into an SANDRA
C     word. The routine uses two integer arguments, INT1 & INT2
C     where INT1 is low order 16 bits & INT2 is next 8 bits.
C     Twos complemented if negative.
C---------------------------------------------------------------------
      DATA ITIME /0/
      IF(ITIME.EQ.0) THEN
         ITIME = 1
         MASK = 255
         MASK = ISHFT(MASK,24)
      ENDIF
      IVAL = 65536.*INT2 + INT1
      IF (INT2.GE.128) THEN
C---------------------------------------------------------------------
C     24 bit # is negative - turn it into a 32 bit negative #
C---------------------------------------------------------------------
      IVAL = IOR(IVAL,MASK)
      ENDIF
      FJOIN = IVAL
      RETURN
      END
+EOD.
C*********************************************************************
C
C                         E N E R G Y
C
C*********************************************************************
+DECK, ENERGY.
      SUBROUTINE ENERGY(ETOTC)
C---------------------------------------------------------------------
C     This routine calculates the total energy from the flash ADC's
C---------------------------------------------------------------------
+CDE,MYINFO.
+CDE,TRACK.
+CDE,KINEM.
      COMMON/HISTO/JH(20),LH(20)
      COMMON/ETBIN/ NETBIN(5),NSIBIN(5)
      LOGICAL ETOTC
      DIMENSION IFADC(50),WEIGHT(7),PED(7),P1(3),IADDER(5)
      DATA WEIGHT /1.17,1.01,0.89,1.49,1.49,1.17,1.49/
      DATA PED    /1.5,7.7,5.5,1.8,4.7,2.4,1.5/
      DATA ETPED  /2.5/
      DATA NETBIN/0,0,0,0,0/
      DATA NSIBIN/0,0,0,0,0/
      ETOTC=.FALSE.
C---------------------------------------------------------------------
C     Unpack the flash ADC's
C
C     34: Veto  35: ULAC had    36: ULAC em  37: External  38: Box
C     39: Beam  40: Wall+Magcal 44: ULAC EM ET
C---------------------------------------------------------------------
      LABEL = 22906
      LENGTH=48
      CALL LBCOPY(LABEL,IFADC(1),LENGTH,1,16)
      IF (LENGTH.NE.48) CALL LSTOP(LABEL)
C---------------------------------------------------------------------
C     Unpack the adder
C
C     3: ULAC had ET
C---------------------------------------------------------------------
C     LABEL = 23306
C     LENGTH=5
C     CALL LBCOPY(LABEL,IADDER(1),LENGTH,1,16)
C     IF (LENGTH.NE.5) CALL LWARNG(LABEL)
C---------------------------------------------------------------------
C     Calculate ETOT for muons
C---------------------------------------------------------------------
      ETOTMU = 0.
      DO 100 I = 1,NMU
        IF(TRAKMU(1,I,5).EQ.0.) GO TO 100
        XM    = MUM
        P1(1) = TRAKMU(1,I,1)
        P1(2) = TRAKMU(1,I,2)
        P1(3) = TRAKMU(1,I,3)
        E1 = SQRT(XM**2 + P1(1)**2 + P1(2)**2 + P1(3)**2)
        ETOTMU = ETOTMU + E1
 100  CONTINUE
C---------------------------------------------------------------------
C     Calculate ETOT from calorimeter
C---------------------------------------------------------------------
      ETOT     = 0.
      DO 1   I = 1,7
      IF(YEAR.EQ.1987) THEN
         ETOT  = ETOT + WEIGHT(I) * ( FLOAT(IFADC(33+I)) - PED(I) )
      ELSE
         ETOT  = ETOT + FLOAT(IFADC(33+I))
      ENDIF
 1    CONTINUE
C---------------------------------------------------------------------
C     Calculate energy in veto cal.
C---------------------------------------------------------------------
      VETOEN   = FLOAT(IFADC(34))
C---------------------------------------------------------------------
C     Calculate em ET in ULAC
C---------------------------------------------------------------------
      ETULAC   = 0.5 * (FLOAT(IFADC(44)) - ETPED)
C---------------------------------------------------------------------
C   Calculate total PT from DC tracks
C---------------------------------------------------------------------
      PTSUM = 0.
      DO 10 IDC = 1,NDC
        IF(IRAKDC(5,IDC,16).NE.4.AND.IRAKDC(5,IDC,16).NE.7) GO TO 10
        J=IRAKDC(1,IDC,16)
        E=TRAKDC(1,IDC,17)
        P=TRAKDC(5,IDC,4)
        Y0= TRAKDC(2,IDC,14)
        IF(ABS(Y0).LT.0.45) THEN
           IF(J.EQ.4.OR.J.EQ.7.AND.(E.GT.0.010.AND.E.LT.0.070)) THEN
              PTSUM = PTSUM + P
C ================= DUMP =================
        IF(P.GT.5.) THEN
            X0 = TRAKDC(1,IDC,12)
            Y0 = TRAKDC(1,IDC,14)
            SX = 1000.*TRAKDC(1,IDC,11)
            SY = 1000.*TRAKDC(1,IDC,13)
            IG = IRAKDC(1,IDC,10)
            PL = TRAKDC(1,IDC,5)
            PC = TRAKDC(1,IDC,4)
            IQ = IRAKDC(1,IDC,16)
C           WRITE(6,2)
C           WRITE(6,3) IDC,SX,X0,SY,Y0,IG,PL,PC,IQ
C2    FORMAT('   #  ALPHA    X0    BETA   Y0    S P-LAB  PT    FLAG')
C3    FORMAT(1X,I3,F7.1,F7.2,F7.1,F7.2,I3,2F6.1,2X,I3)
           ENDIF
C ================= DUMP =================
           ENDIF
        ENDIF
 10   CONTINUE
      ETSUM  = PTSUM + ETULAC
C---------------------------------------------------------------------
C     Create fake comb. background
C---------------------------------------------------------------------
C     MULT = MULTS2
C     MULT = MULTDC(8)
      MULT = MULTSC
C     MULT = MULTDC(12)
C     MULT = 10
      NMUON = 0
      DO 532 I=1,MULT
         XRND = 10.*RNDM(0)
         IF(XRND.GE.9.5) NMUON = NMUON + 1
 532  CONTINUE
C---------------------------------------------------------------------
C     Plot histogram
C---------------------------------------------------------------------
 
      IF(JH(9).EQ.0) GO TO 666
      CALL HFILL(LH(9)+0,FLOAT(MULT),0.,1.)
      IF(NMUON.EQ.2) CALL HFILL(LH(9)-1,FLOAT(MULT),0.,1.)
      CALL HFILL(LH(9)-2,FLOAT(NMUON),0.,1.)
      CALL HFILL(LH(9)+1,ETOT,0.,1.)
      CALL HFILL(LH(9)+2,ETOT+ETOTMU,0.,1.)
      CALL HFILL(LH(9)+3,VETOEN,0.,1.)
      CALL HFILL(LH(9)+4,ETULAC,0.,1.)
      CALL HFILL(LH(9)+40,PTSUM,0.,1.)
      CALL HFILL(LH(9)+44,ETSUM,0.,1.)
      CALL HFILL(LH(9)+5,ETULAC,FLOAT(MULT),1.)
      CALL HFILL(LH(9)+11,ETOTMU,0.,1.)
      CALL HFILL(LH(9)+12,FLOAT(MULTDC(8)),FLOAT(MULTSC),1.)
      CALL HFILL(LH(9)+120,PTSUM,FLOAT(MULTDC(12)),1.)
 
      IF(MULT.EQ.2)
     *CALL HFILL(LH(9)+60,FLOAT(MULT),0.,1.)
      IF(MULT.EQ.3)
     *CALL HFILL(LH(9)+70,FLOAT(MULT),0.,1.)
      IF(MULT.EQ.4)
     *CALL HFILL(LH(9)+80,FLOAT(MULT),0.,1.)
      IF(MULT.EQ.5)
     *CALL HFILL(LH(9)+90,FLOAT(MULT),0.,1.)
      IF(MULT.EQ.6)
     *CALL HFILL(LH(9)+100,FLOAT(MULT),0.,1.)
      IF(MULT.GE.7.AND.MULT.LE.9)
     *CALL HFILL(LH(9)+110,FLOAT(MULT),0.,1.)
      IF(MULT.GE.14.AND.MULT.LE.18)
     *CALL HFILL(LH(9)+121,FLOAT(MULT),0.,1.)
 
      IF(ETULAC.GT.0..AND.ETULAC.LE.1.)
     *CALL HFILL(LH(9)+13,ETULAC,0.,1.)
      IF(ETULAC.GT.1..AND.ETULAC.LE.2.)
     *CALL HFILL(LH(9)+14,ETULAC,0.,1.)
      IF(ETULAC.GT.2..AND.ETULAC.LE.3.)
     *CALL HFILL(LH(9)+15,ETULAC,0.,1.)
      IF(ETULAC.GT.3..AND.ETULAC.LE.4.)
     *CALL HFILL(LH(9)+16,ETULAC,0.,1.)
      IF(ETULAC.GT.4..AND.ETULAC.LE.5.)
     *CALL HFILL(LH(9)+17,ETULAC,0.,1.)
      IF(ETULAC.GT.5..AND.ETULAC.LE.7.)
     *CALL HFILL(LH(9)+18,ETULAC,0.,1.)
      IF(ETULAC.GT.7..AND.ETULAC.LE.9.)
     *CALL HFILL(LH(9)+19,ETULAC,0.,1.)
 
      IF(ETULAC.GT.0..AND.ETULAC.LE.1.5)
     *CALL HFILL(LH(9)+6,FLOAT(MULT),0.,1.)
      IF(ETULAC.GT.1.5.AND.ETULAC.LE.3.)
     *CALL HFILL(LH(9)+7,FLOAT(MULT),0.,1.)
      IF(ETULAC.GT.3..AND.ETULAC.LE.4.5)
     *CALL HFILL(LH(9)+8,FLOAT(MULT),0.,1.)
      IF(ETULAC.GT.4.5.AND.ETULAC.LE.6.)
     *CALL HFILL(LH(9)+9,FLOAT(MULT),0.,1.)
      IF(ETULAC.GT.6..AND.ETULAC.LE.9.)
     *CALL HFILL(LH(9)+10,FLOAT(MULT),0.,1.)
 
      IF(ETULAC.GT.0..AND.ETULAC.LE.1.5)
     *CALL HFILL(LH(9)+61,PTSUM,0.,1.)
      IF(ETULAC.GT.1.5.AND.ETULAC.LE.3.)
     *CALL HFILL(LH(9)+62,PTSUM,0.,1.)
      IF(ETULAC.GT.3..AND.ETULAC.LE.4.5)
     *CALL HFILL(LH(9)+63,PTSUM,0.,1.)
      IF(ETULAC.GT.4.5.AND.ETULAC.LE.6.)
     *CALL HFILL(LH(9)+64,PTSUM,0.,1.)
      IF(ETULAC.GT.6..AND.ETULAC.LE.9.)
     *CALL HFILL(LH(9)+65,PTSUM,0.,1.)
 
      IF(ETSUM.GT.1..AND.ETSUM.LE.3.)
     *CALL HFILL(LH(9)+71,ETSUM,0.,1.)
      IF(ETSUM.GT.3..AND.ETSUM.LE.5.)
     *CALL HFILL(LH(9)+72,ETSUM,0.,1.)
      IF(ETSUM.GT.5..AND.ETSUM.LE.7.)
     *CALL HFILL(LH(9)+73,ETSUM,0.,1.)
      IF(ETSUM.GT.7..AND.ETSUM.LE.9.)
     *CALL HFILL(LH(9)+74,ETSUM,0.,1.)
      IF(ETSUM.GT.9..AND.ETSUM.LE.13.)
     *CALL HFILL(LH(9)+75,ETSUM,0.,1.)
 
 666  CONTINUE
C---------------------------------------------------------------------
C     Do the cut
C---------------------------------------------------------------------
      IF (ETOT.GT.550..OR.VETOEN.GT.7.)          ETOTC=.TRUE.
 
      IF(ETULAC.GT.0..AND.ETULAC.LE.1.5)  NETBIN(1)=NETBIN(1)+1
      IF(ETULAC.GT.1.5.AND.ETULAC.LE.3.)  NETBIN(2)=NETBIN(2)+1
      IF(ETULAC.GT.3..AND.ETULAC.LE.4.5)  NETBIN(3)=NETBIN(3)+1
      IF(ETULAC.GT.4.5.AND.ETULAC.LE.6.)  NETBIN(4)=NETBIN(4)+1
      IF(ETULAC.GT.6..AND.ETULAC.LE.9.)   NETBIN(5)=NETBIN(5)+1
 
      IF(MULT.GE.2.AND.MULT.LE.3)         NSIBIN(1)=NSIBIN(1)+1
      IF(MULT.GE.4.AND.MULT.LE.5)         NSIBIN(2)=NSIBIN(2)+1
      IF(MULT.GE.6.AND.MULT.LE.7)         NSIBIN(3)=NSIBIN(3)+1
      IF(MULT.GE.8.AND.MULT.LE.10)        NSIBIN(4)=NSIBIN(4)+1
      IF(MULT.GE.11.AND.MULT.LE.14)       NSIBIN(5)=NSIBIN(5)+1
 
      IF(ETCUT.EQ.0) RETURN
      IF(ETCUT.EQ.1.AND..NOT.(ETULAC.GT.0..AND.ETULAC.LE.1.5))
     *ETOTC=.TRUE.
      IF(ETCUT.EQ.2.AND..NOT.(ETULAC.GT.1.5.AND.ETULAC.LE.3.))
     *ETOTC=.TRUE.
      IF(ETCUT.EQ.3.AND..NOT.(ETULAC.GT.3..AND.ETULAC.LE.4.5))
     *ETOTC=.TRUE.
      IF(ETCUT.EQ.4.AND..NOT.(ETULAC.GT.4.5.AND.ETULAC.LE.6.))
     *ETOTC=.TRUE.
      IF(ETCUT.EQ.5.AND..NOT.(ETULAC.GT.6..AND.ETULAC.LE.9.))
     *ETOTC=.TRUE.
 
      IF(ETCUT.EQ.6.AND..NOT.(MULT.GE.2.AND.MULT.LE.3))
     *ETOTC=.TRUE.
      IF(ETCUT.EQ.7.AND..NOT.(MULT.GE.4.AND.MULT.LE.5))
     *ETOTC=.TRUE.
      IF(ETCUT.EQ.8.AND..NOT.(MULT.GE.6.AND.MULT.LE.7))
     *ETOTC=.TRUE.
      IF(ETCUT.EQ.9.AND..NOT.(MULT.GE.8.AND.MULT.LE.10))
     *ETOTC=.TRUE.
      IF(ETCUT.EQ.10.AND..NOT.(MULT.GE.11.AND.MULT.LE.14))
     *ETOTC=.TRUE.
 
      RETURN
      END
+EOD.
C*********************************************************************
C
C                         S I P A D
C
C*********************************************************************
+DECK, SIPAD.
      SUBROUTINE SIPAD(SIC)
C---------------------------------------------------------------------
C     This routine calculates the multiplicity of the Sipads
C---------------------------------------------------------------------
+CDE,MYINFO.
      COMMON/HISTO/JH(20),LH(20)
      DIMENSION ISPD(76),IXV(12)
      LOGICAL SIC
      SIC=.FALSE.
C---------------------------------------------------------------------
C     Unpack the Si Pads and calculate multiplicity
C---------------------------------------------------------------------
      MULTSC = 0
      LABEL = 4206
      IF(LBLENG(LABEL).EQ.0) THEN
         CALL LWARNG(LABEL)
         RETURN
      ENDIF
      LENGTH=76
      CALL LBCOPY(LABEL,ISPD(1),LENGTH,1,-1,1)
      DO 11 I = 1,76,2
         CALL BITPOS(ISPD(I),12,IXV,NX)
         MULTSC = MULTSC + NX
 11   CONTINUE
C---------------------------------------------------------------------
C     Plot histogram
C---------------------------------------------------------------------
      IF(JH(2).NE.0) CALL HFILL(LH(2)+1,FLOAT(MULTSC),0.,1.)
C---------------------------------------------------------------------
C     Do the cut
C---------------------------------------------------------------------
      IF (MULTSC.LE.1) SIC=.TRUE.
      RETURN
      END
+EOD.
C*********************************************************************
C
C                         S I P A D 2
C
C*********************************************************************
+DECK,SIPAD2.
      SUBROUTINE SIPAD2
+CDE,MYINFO.
      COMMON/ELSARW/SASIDI(76),SDISEN(0:399),NSDISE,DISSIP(38,12)
      INTEGER       DISSIP,SDISEN,SASIDI,CENPAD(38),C1,C2,C3,C4
      DATA CENPAD /
     *     1,    2,    4,    5,    8,    9,   11,   12,
     *    16,   17,   19,   20,   24,   25,   28,   29,
     *    34,   35,   37,   38,   39,   42,   43,   44,
     *    46,   47,   48,   52,   53,   54,   56,   59,
     *    61,   65,   69,   72,   73,   76/
      DATA (DISSIP( 1,I),I=1,12)/  1,  4,  8, 11, 16, 19,
     *                            24, 28, 34, 38, 43, 47/
      DATA (DISSIP( 2,I),I=1,12)/ 53, 56, 59, 61, 23, 27,
     *                            33, 37, 42, 46, 52, -1/
      DATA (DISSIP( 3,I),I=1,12)/  2,  5,  9, 12, 17, 20,
     *                            25, 29, 35, 39, 44, 48/
      DATA (DISSIP( 4,I),I=1,12)/  3,  6, 10, 13, 18, 21,
     *                            26, 30, 36, 40, 45, 49/
      DATA (DISSIP( 5,I),I=1,12)/ 65, 69, 72, 73, 76, 77,
     *                            80, 83, 86, 89, 92, 95/
      DATA (DISSIP( 6,I),I=1,12)/ 54, 57, 60, 62, 66, 70,
     *                            74, 78, 81, 55, -1, -1/
      DATA (DISSIP( 7,I),I=1,12)/ -1, -1, -1, 58, 63, 67,
     *                            64, 68, 71, 75, 79, 82/
      DATA (DISSIP( 8,I),I=1,12)/ 85, 88, 91, 94, 96, 98,
     *                            99, 84, 87, 90, 93, 97/
      DATA (DISSIP( 9,I),I=1,12)/ -1, -1, -1, -1, -1, -1,
     *                           150,141,131,122,114,107/
      DATA (DISSIP(10,I),I=1,12)/207,214,222,231,241,250,
     *                            -1, -1, -1, -1, -1, -1/
      DATA (DISSIP(11,I),I=1,12)/101,104,108,111,116,119,
     *                           124,128,134,138,143,147/
      DATA (DISSIP(12,I),I=1,12)/153,156,159,161,123,127,
     *                           133,137,142,146,152, -1/
      DATA (DISSIP(13,I),I=1,12)/102,105,109,112,117,120,
     *                           125,129,135,139,144,148/
      DATA (DISSIP(14,I),I=1,12)/103,106,110,113,118,121,
     *                           126,130,136,140,145,149/
      DATA (DISSIP(15,I),I=1,12)/165,169,172,173,176,177,
     *                           180,183,186,189,192,195/
      DATA (DISSIP(16,I),I=1,12)/154,157,160,162,166,170,
     *                           174,178,181,155, -1, -1/
      DATA (DISSIP(17,I),I=1,12)/ -1, -1, -1,158,163,167,
     *                           164,168,171,175,179,182/
      DATA (DISSIP(18,I),I=1,12)/185,188,191,194,196,198,
     *                           199,184,187,190,193,197/
      DATA (DISSIP(19,I),I=1,12)/301,304,308,311,316,319,
     *                           324,328,334,338,343,347/
      DATA (DISSIP(20,I),I=1,12)/353,356,359,361,323,327,
     *                           333,337,342,346,352, -1/
      DATA (DISSIP(21,I),I=1,12)/302,305,309,312,317,320,
     *                           325,329,335,339,344,348/
      DATA (DISSIP(22,I),I=1,12)/303,306,310,313,318,321,
     *                           326,330,336,340,345,349/
      DATA (DISSIP(23,I),I=1,12)/365,369,372,373,376,377,
     *                           380,383,386,389,392,395/
      DATA (DISSIP(24,I),I=1,12)/354,357,360,362,366,370,
     *                           374,378,381,355, -1, -1/
      DATA (DISSIP(25,I),I=1,12)/ -1, -1, -1,358,363,367,
     *                           364,368,371,375,379,382/
      DATA (DISSIP(26,I),I=1,12)/385,388,391,394,396,398,
     *                           399,384,387,390,393,397/
      DATA (DISSIP(27,I),I=1,12)/ -1, -1, -1, -1, -1, -1,
     *                            50, 41, 31, 22, 14,  7/
      DATA (DISSIP(28,I),I=1,12)/307,314,322,331,341,350,
     *                            -1, -1, -1, -1, -1, -1/
      DATA (DISSIP(29,I),I=1,12)/201,204,208,211,216,219,
     *                           224,228,234,238,243,247/
      DATA (DISSIP(30,I),I=1,12)/253,256,259,261,223,227,
     *                           233,237,242,246,252, -1/
      DATA (DISSIP(31,I),I=1,12)/202,205,209,212,217,220,
     *                           225,229,235,239,244,248/
      DATA (DISSIP(32,I),I=1,12)/203,206,210,213,218,221,
     *                           226,230,236,240,245,249/
      DATA (DISSIP(33,I),I=1,12)/265,269,272,273,276,277,
     *                           280,283,286,289,292,295/
      DATA (DISSIP(34,I),I=1,12)/254,257,260,262,266,270,
     *                           274,278,281,255, -1, -1/
      DATA (DISSIP(35,I),I=1,12)/ -1, -1, -1,258,263,267,
     *                           264,268,271,275,279,282/
      DATA (DISSIP(36,I),I=1,12)/285,288,291,294,296,298,
     *                           299,284,287,290,293,297/
      DATA (DISSIP(37,I),I=1,12)/ -1, -1, -1, -1, -1, -1,
     *                            51, 32, 15,315,332,351/
      DATA (DISSIP(38,I),I=1,12)/151,132,115,215,232,251,
     *                            -1, -1, -1, -1, -1, -1/
      DATA LABEL/04206/
 
      MAXLEN=76
      CALL LBCOPY(LABEL,SASIDI,MAXLEN)
      CALL UZERO(SDISEN,1,400)
 
      ICARD=0
      NSDISE=0
      DO 111 I=1,76,2
         ICARD=ICARD+1
         DO 222 J=0,11
            ISIP=DISSIP(ICARD,J+1)
            IF(ISIP.NE.-1)THEN
               IF(BTEST(SASIDI(I),J))THEN
                  NSDISE=NSDISE+1
                  SDISEN(ISIP)=1
               ENDIF
            ENDIF
222      CONTINUE
111   CONTINUE
 
      MULTS2 = 0
      DO 333 J = 1,399
         IF(SDISEN(J).NE.1) GO TO 333
            DO 33 N = 1,38
              C1=CENPAD(N)
              C2=CENPAD(N)+100
              C3=CENPAD(N)+200
              C4=CENPAD(N)+300
            IF(J.EQ.C1.OR.J.EQ.C2.OR.J.EQ.C3.OR.J.EQ.C4)
     *      MULTS2 = MULTS2 + 1
 33      CONTINUE
333   CONTINUE
 
      RETURN
      END
+EOD.
C*********************************************************************
C
C                         H O D O S C
C
C*********************************************************************
+DECK,HODOSC.
      SUBROUTINE HODOSC(MUHODC)
C---------------------------------------------------------------------
C   This routine unpacks the raw muon hodoscope data and calculates
C   multiplicity.
C---------------------------------------------------------------------
      COMMON/HISTO/JH(20),LH(20)
      DIMENSION NHIT(2,2),MCOD(50)
      LOGICAL MUHODC
      MUHODC = .FALSE.
      CALL VZERO(MCOD,50)
      CALL VZERO(NHIT,4)
C---------------------------------------------------------------------
C         First we will try to find label 17506
C---------------------------------------------------------------------
      LABEL = 17506
      MAXLEN = 100
      CALL LBCOPY(LABEL,MCOD,MAXLEN)
      IF (MAXLEN.EQ.0) THEN
         CALL LWARNG(LABEL)
C---------------------------------------------------------------------
C         then we will try to find label 16106
C---------------------------------------------------------------------
         LENGHT=100
         LABEL=LABLSA(22,1)
         CALL LBCOPY(LABEL,MCOD(1),LENGHT,1,16,1)
         IF(LENGHT.EQ.0) THEN
            CALL LWARNG(LABEL)
            RETURN
         ENDIF
      ENDIF
C---------------------------------------------------------------------
C   Loop over the two hodoscope walls.
C
C   IH=1 is called H3 and is before the iron wall
C   IH=2 is called H2 and is after  the iron wall
C---------------------------------------------------------------------
      DO 1 IH=1,2
C---------------------------------------------------------------------
C   Loop over the two sides of each hodoscope wall.
C
C   ISIDE=1 corresponds to the right scintillators
C   ISIDE=2 corresponds to the left  scintillators
C---------------------------------------------------------------------
         DO 2 ISIDE=1,2
C---------------------------------------------------------------------
C   Loop over the pattern units (IPU)
C---------------------------------------------------------------------
            DO 3 IP=1,3
               IPU=(IH-1)*3+IP
               DO 4 IBS=1,8
                  JB=(IBS-1)*2+ISIDE-1
                  K=2**JB
                  IF(IAND(MCOD(IPU),K).EQ.0) GO TO 4
                  NHIT(IH,ISIDE) = NHIT(IH,ISIDE) + 1
  4            CONTINUE
  3         CONTINUE
  2      CONTINUE
  1   CONTINUE
C---------------------------------------------------------------------
C   Add together the multiplicity in the two sides
C---------------------------------------------------------------------
      NHIT1=NHIT(1,1)+NHIT(1,2)
      NHIT2=NHIT(2,1)+NHIT(2,2)
C---------------------------------------------------------------------
C   Plot histograms
C---------------------------------------------------------------------
      IF(JH(6).EQ.0) RETURN
      CALL HFILL(LH(6)+1,FLOAT(NHIT1),0.,1.)
      CALL HFILL(LH(6)+2,FLOAT(NHIT2),0.,1.)
      RETURN
      END
+EOD.
C*********************************************************************
C
C                         S C I P A D
C
C*********************************************************************
+DECK,SCIPAD.
      SUBROUTINE SCIPAD(SCIC)
C---------------------------------------------------------------------
C     This routine studies the scintillator pads
C---------------------------------------------------------------------
+CDE,MYINFO.
+CDE,MYSPAD.
      COMMON/HISTO/JH(20),LH(20)
      LOGICAL SCIC
      DATA IPED   /70/
      SCIC=.FALSE.
      CALL VZERO(IDISCR,320)
      CALL VZERO(IADC,80)
      CALL VZERO(IRAWA,100)
C---------------------------------------------------------------------
C     Shift array IDISUP and ISCSP with one so that we start count at 1
C---------------------------------------------------------------------
      DO 10 I =1,256
        IDISUP(I) = ITEMP(I)+1
 10   CONTINUE
      DO 11 I=1,256
        ISCSP(IDISUP(I)) = ISCLOC(I) + 1
 11   CONTINUE
C---------------------------------------------------------------------
C     Unpack ADC information into IADC
C---------------------------------------------------------------------
      LABEL  = 33106
      LENGTH = LBLENG(LABEL,1,1)
      LENCW  = IBCLR(LENGTH,30)
      IF(LENGTH.EQ.0 ) CALL LWARNG(LABEL)
      CALL LBCOPY(LABEL,IRAWA,LENCW,1,-1,1)
      DO  90 I = 1,80
        IADC(I) = IAND(IRAWA(JWDPM(I)),4095) - IPED
        IF(IADC(I).GT.3000.) IADC(I)=-9999
        DOSHIF=.TRUE.
        IF(DOSHIF) IADC(I)=IADC(I)-ISHIF(I)
   90 CONTINUE
C---------------------------------------------------------------------
C     Use ADC information too look for hits
C---------------------------------------------------------------------
      DO 209 I = 1,80
        IF(IADC(I).GT.100.AND.IADC(I).GT.ICUT(I)) IDISCR(1,I) = 1
        IF(IADC(I).GT.100.AND.IADC(I).GT.JCUT(I)) IDISCR(2,I) = 1
        IF(IADC(I).GT.100.AND.IADC(I).LT.ICUT(I)) IDISCR(4,I) = 1
 209  CONTINUE
C---------------------------------------------------------------------
C     Unpack FANOUT information from inside correlation logic data
C     into IRAWD
C---------------------------------------------------------------------
C     LABEL  = 23406
C     LENGTH = LBLENG(LABEL,1,1)
C     LENEC  = IBCLR(LENGTH,30)
C     IF(LENGTH.EQ.0 ) CALL LSTOP(LABEL)
C     CALL LBCOPY(LABEL,IRAWD,LENEC,1,-1,1)
C---------------------------------------------------------------------
C     Decode FANOUT information
C---------------------------------------------------------------------
      DO 80 I = 0,15
          DO 91 J = 1,16
            IPAD = IDISUP(16*I+J)
            SCIFAN(IPAD) = BTEST(IRAWD(61+I),J-1)
            IF(.NOT.SCIFAN(IPAD)) IDISCR(3,ISCSP(IPAD)) = 0
            IF(SCIFAN(IPAD))      IDISCR(3,ISCSP(IPAD)) = 1
 91       CONTINUE
 80   CONTINUE
C---------------------------------------------------------------------
C     Calculate multiplicity
C---------------------------------------------------------------------
      MDISC0 = 0
      MDISC1 = 0
      MDISC2 = 0
      MDISC3 = 0
      DO 511 I = 1,80
         IF(IDISCR(2,I).EQ.1) MDISC2 = MDISC2 + 1
         IF(IDISCR(3,I).EQ.1) MDISC3 = MDISC3 + 1
         IF(IDISCR(4,I).EQ.1) MDISC0 = MDISC0 + 1
         IF(IDISCR(1,I).EQ.0) GO TO 511
         IF(IDISCR(2,I).EQ.0) MDISC1 = MDISC1 + 1
         XP=XSCIL(I)+(XSCIH(I)-XSCIL(I))*RNDM(0)
         YP=YSCIL(I)+(YSCIH(I)-YSCIL(I))*RNDM(0)
         IF(JH(3).NE.0) CALL HFILL(LH(3)+110,XP,YP,1.)
 511  CONTINUE
C---------------------------------------------------------------------
C     Fill Histograms
C---------------------------------------------------------------------
      IF(JH(3).EQ.0) GO TO 130
C        DO 13 I=1,80
         DO 13 I=1,33
C           IF(IDISCR(1,I).NE.0)
C           IF(IDISCR(2,I).NE.0)
C           IF(IDISCR(3,I).NE.0)
C           IF(IADC(I).GT.100)
C    *      CALL HFILL(LH(3)+I,FLOAT(IADC(I)),0.,1.)
            CALL HFILL(LH(3)+I,FLOAT(IADC(I)),0.,1.)
            IF(IDISCR(3,I).EQ.1) CALL HFILL(LH(3)+120,FLOAT(I),0.,1.)
 13      CONTINUE
      CALL HFILL(LH(3)+100,FLOAT(MDISC0),0.,1.)
      CALL HFILL(LH(3)+101,FLOAT(MDISC1),0.,1.)
      CALL HFILL(LH(3)+102,FLOAT(MDISC2),0.,1.)
      CALL HFILL(LH(3)+103,FLOAT(MDISC3),0.,1.)
 130  CONTINUE
C---------------------------------------------------------------------
C     Do the cut
C---------------------------------------------------------------------
      IF (MDISC1.LE.2.OR.MDISC1.GT.11) SCIC=.TRUE.
      IF(SCIC) RETURN
      NCUT(6,2) = NCUT(6,2) + 1
      IF (MDISC2.GE.5) SCIC=.TRUE.
      IF(SCIC) RETURN
      NCUT(6,3) = NCUT(6,3) + 1
      RETURN
      END
+EOD.
C*********************************************************************
C
C                         S C I T R K
C
C*********************************************************************
+DECK,SCITRK.
      SUBROUTINE SCITRK(X,Y,NPAD)
C---------------------------------------------------------------------
C     This routine tests if a track has hit a scintillator pad.
C---------------------------------------------------------------------
+CDE,MYINFO.
+CDE,MYSPAD.
C---------------------------------------------------------------------
C   Find the pad that the track is pointing to and see if it's hit
C---------------------------------------------------------------------
      NPAD = 0
      DO 210 I = 1,80
         IF(X.GE.XSCIL(I).AND.X.LT.XSCIH(I).AND.Y.GE.YSCIL(I).AND.
     *      Y.LT.YSCIH(I).AND.IDISCR(1,I).NE.0) NPAD=1
 210  CONTINUE
      IF(NPAD.NE.0) RETURN
C---------------------------------------------------------------------
C   If the pad was not hit, look in a somewhat larger area around it.
C---------------------------------------------------------------------
      DO 220 I = 1,80
         XL = XSCIL(I) - 0.5
         XH = XSCIH(I) + 0.5
         YL = YSCIL(I) - 0.5
         YH = YSCIH(I) + 0.5
         IF(X.GE.XL.AND.X.LT.XH.AND.Y.GE.YL.AND.
     *      Y.LT.YH.AND.IDISCR(1,I).NE.0) NPAD=1
 220  CONTINUE
      RETURN
      END
+EOD.
C*********************************************************************
C
C                         C O N C A L
C
C*********************************************************************
+DECK, CONCAL.
      SUBROUTINE CONCAL(CONC)
C---------------------------------------------------------------------
C     This routine calculates the total energy from the flash ADC's
C---------------------------------------------------------------------
      COMMON/HISTO/JH(20),LH(20)
      LOGICAL CONC
      DIMENSION IADC(8),ADC(8)
      DATA ADCPED /95./
      CONC=.FALSE.
      CALL VZERO(IADC,8)
      CALL VZERO(ADC,8)
      NHIT=0
C---------------------------------------------------------------------
C     Unpack the ADC's
C---------------------------------------------------------------------
      LABEL = 8506
      LENGTH=8
      CALL LBCOPY(LABEL,IADC(1),LENGTH)
      IF (LENGTH.NE.8) CALL LSTOP(LABEL)
      DO 1 J = 1,8
 1    ADC(J)=FLOAT(IADC(J)) - ADCPED
C---------------------------------------------------------------------
C     Find hits
C---------------------------------------------------------------------
      DO 2 J = 1,8
        IF(ADC(J).GE.10.) NHIT=NHIT+1
 2    CONTINUE
C---------------------------------------------------------------------
C     Plot histogram
C---------------------------------------------------------------------
      DO 10 J = 1,8
        IF(JH(4).NE.0) CALL HFILL(LH(4)+J,ADC(J),0.,1.)
        IF(JH(4).NE.0) CALL HFILL(LH(4)+J+10,ADC(J),0.,1.)
 10   CONTINUE
        IF(JH(4).NE.0) CALL HFILL(LH(4)+20,FLOAT(NHIT),0.,1.)
C---------------------------------------------------------------------
C     Do the cut
C---------------------------------------------------------------------
      IF (NHIT.GE.1) CONC=.TRUE.
      RETURN
      END
+EOD.
C*********************************************************************
C
C                         D C S E P
C
C*********************************************************************
+DECK, DCSEP.
      SUBROUTINE DCSEP
C---------------------------------------------------------------------
C     This routine studies the DC two track separation
C---------------------------------------------------------------------
+CDE,TRACK.
+CDE,KINEM.
+CDE,MYINFO.
      COMMON/HISTO/JH(20),LH(20)
      IF(NDC.EQ.0) RETURN
C---------------------------------------------------------------------
C
C                 First loop over all tracks
C
C---------------------------------------------------------------------
      DO 100 I1 = 1,NDC
C---------------------------------------------------------------------
C    Check the reconstruction flag
C---------------------------------------------------------------------
        IF(IRAKDC(5,I1,16).NE.4.AND.IRAKDC(5,I1,16).NE.7) GO TO 100
C---------------------------------------------------------------------
C
C                 Second loop over all tracks
C
C---------------------------------------------------------------------
        DO 10 I2 = 1,NDC
           IF(I1.GE.I2)                                  GO TO 10
C---------------------------------------------------------------------
C    Check sign
C---------------------------------------------------------------------
           IS1 = IRAKDC(1,I1,10)
           IS2 = IRAKDC(1,I2,10)
           IF(IS1.EQ.IS2)                                GO TO 10
C---------------------------------------------------------------------
C    Calculate two track separation
C---------------------------------------------------------------------
           ZDC2  = 233.
           X1    = TRAKDC(5,I1,11) * ZDC2 + TRAKDC(5,I1,12)
           Y1    = TRAKDC(5,I1,13) * ZDC2 + TRAKDC(5,I1,14)
           X2    = TRAKDC(5,I2,11) * ZDC2 + TRAKDC(5,I2,12)
           Y2    = TRAKDC(5,I2,13) * ZDC2 + TRAKDC(5,I2,14)
           DELTAX= ABS(X1-X2)
           DELTAY= ABS(Y1-Y2)
           R     = SQRT( DELTAX**2 + DELTAY**2 )
C---------------------------------------------------------------------
C    Plot histograms
C---------------------------------------------------------------------
           IF(JH(15).EQ.0) GO TO 5
              CALL HFILL(LH(15)+31,DELTAX,0.,1.)
              CALL HFILL(LH(15)+32,DELTAY,0.,1.)
              CALL HFILL(LH(15)+41,DELTAX,0.,1.)
              CALL HFILL(LH(15)+42,DELTAY,0.,1.)
              CALL HFILL(LH(15)+51,DELTAX,0.,1.)
              CALL HFILL(LH(15)+52,DELTAY,0.,1.)
C---------------------------------------------------------------------
C    Check the reconstruction flag
C---------------------------------------------------------------------
           IF(IRAKDC(5,I2,16).NE.4.AND.IRAKDC(5,I2,16).NE.7) GO TO 10
              CALL HFILL(LH(15)+1,DELTAX,0.,1.)
              CALL HFILL(LH(15)+2,DELTAY,0.,1.)
              CALL HFILL(LH(15)+11,DELTAX,0.,1.)
              CALL HFILL(LH(15)+12,DELTAY,0.,1.)
              CALL HFILL(LH(15)+21,DELTAX,0.,1.)
              CALL HFILL(LH(15)+22,DELTAY,0.,1.)
              CALL HFILL(LH(15)+60,R,0.,1.)
 5      CONTINUE
C---------------------------------------------------------------------
C
C                 End of second loop
C
C---------------------------------------------------------------------
 10     CONTINUE
C---------------------------------------------------------------------
C
C                 End of first loop
C
C---------------------------------------------------------------------
 100  CONTINUE
      RETURN
      END
+EOD.
C*********************************************************************
C
C                         D C V T X
C
C*********************************************************************
+DECK, DCVTX.
      SUBROUTINE DCVTX
C---------------------------------------------------------------------
C     This routine find the DC vertex
C---------------------------------------------------------------------
+CDE,TRACK.
+CDE,KINEM.
+CDE,MYINFO.
      COMMON/HISTO/JH(20),LH(20)
      DIMENSION VERTEX(3),VTX(13)
C---------------------------------------------------------------------
C     Initialize
C---------------------------------------------------------------------
      CALL VZERO(VERTEX,3)
      NTRAK = 0
      IF(NDC.EQ.0) RETURN
C---------------------------------------------------------------------
C     Get Lucifer vertex
C---------------------------------------------------------------------
C     LENGTH = 13
C     LABEL  = 7027
C     CALL LBCOPY(LABEL,VTX,LENGTH)
C     IF(LENGTH.EQ.0) CALL LWARNG(LABEL)
C---------------------------------------------------------------------
C
C       L o o p   o v e r   a l l   t r a c k s
C
C---------------------------------------------------------------------
      DO 102 I=1,NDC
C---------------------------------------------------------------------
C       Select DC1 tracks
C---------------------------------------------------------------------
      IF(IRAKDC(1,I,16).LE.5) GO TO 102
C---------------------------------------------------------------------
C       Count the number of tracks used in the vertex
C---------------------------------------------------------------------
      NTRAK = NTRAK + 1
C---------------------------------------------------------------------
C       Calculate vertex
C---------------------------------------------------------------------
      VERTEX(1) = VERTEX(1) + TRAKDC(1,I,12) - XTARG
      VERTEX(2) = VERTEX(2) + TRAKDC(1,I,14) - YTARG
      VERTEX(3) = VERTEX(3) + TRAKDC(1,I,8)  - ZTARG
      VTXX      = TRAKDC(1,I,12) - XTARG
      VTXY      = TRAKDC(1,I,14) - YTARG
      VTXZ      = TRAKDC(1,I,8)  - ZTARG
C---------------------------------------------------------------------
C                     H i s t o g r a m s
C---------------------------------------------------------------------
      IF(JH(13).EQ.0) GO TO 102
      IF(YEAR.EQ.1988) THEN
         IF(ABS(VTXX).LT.0.3)
     *   CALL HFILL(LH(13)+1,VTXX,0.,1.)
         IF(ABS(VTXY).LT.0.3)
     *   CALL HFILL(LH(13)+2,VTXY,0.,1.)
         IF(ABS(VTXZ).LT.6.)
     *   CALL HFILL(LH(13)+3,VTXZ,0.,1.)
      ENDIF
      IF(YEAR.EQ.1987) THEN
         IF(ABS(VTXX).LT.0.3)
     *   CALL HFILL(LH(13)+51,VTXX,0.,1.)
         IF(ABS(VTXY).LT.0.3)
     *   CALL HFILL(LH(13)+52,VTXY,0.,1.)
         IF(ABS(VTXZ).LT.6.)
     *   CALL HFILL(LH(13)+53,VTXZ,0.,1.)
      ENDIF
 102  CONTINUE
C---------------------------------------------------------------------
C
C                 E n d   o f   t r a c k   l o o p
C
C---------------------------------------------------------------------
C       Calculate vertex
C---------------------------------------------------------------------
      IF(NTRAK.EQ.0) RETURN
      VERTEX(1) = VERTEX(1) / NTRAK
      VERTEX(2) = VERTEX(2) / NTRAK
      VERTEX(3) = VERTEX(3) / NTRAK
C---------------------------------------------------------------------
C
C                     H i s t o g r a m s
C
C---------------------------------------------------------------------
      IF(JH(13).EQ.0) GO TO 999
         CALL HFILL(LH(13)+21,FLOAT(NTRAK),0.,1.)
C        CALL HFILL(LH(13)+31,VTX(3),0.,1.)
C        CALL HFILL(LH(13)+32,VTX(4),0.,1.)
C        CALL HFILL(LH(13)+33,VTX(5),0.,1.)
      IF(YEAR.EQ.1988) THEN
         IF(ABS(VERTEX(1)).LT.0.2)
     *   CALL HFILL(LH(13)+11,VERTEX(1),0.,1.)
         IF(ABS(VERTEX(2)).LT.0.2)
     *   CALL HFILL(LH(13)+12,VERTEX(2),0.,1.)
         IF(ABS(VERTEX(3)).LT.4.)
     *   CALL HFILL(LH(13)+13,VERTEX(3),0.,1.)
      ENDIF
      IF(YEAR.EQ.1987) THEN
         IF(ABS(VERTEX(1)).LT.0.2)
     *   CALL HFILL(LH(13)+61,VERTEX(1),0.,1.)
         IF(ABS(VERTEX(2)).LT.0.2)
     *   CALL HFILL(LH(13)+62,VERTEX(2),0.,1.)
         IF(ABS(VERTEX(3)).LT.4.)
     *   CALL HFILL(LH(13)+63,VERTEX(3),0.,1.)
      ENDIF
 999  CONTINUE
      RETURN
      END
+EOD.
C*********************************************************************
C
C                         D C
C
C*********************************************************************
+DECK, DC.
      SUBROUTINE DC(DCCUT)
C---------------------------------------------------------------------
C     This routine unpacks the DC information
C---------------------------------------------------------------------
C
C Flag   DC used    Type  Track parameters      Momentum (at target)
C ----   -------    ----  ----------------      --------
C  1       DC1       1    not filled           not filled
C                    2    not filled           not filled
C                    3    not filled           not filled
C                    4    not filled           not filled
C                    5    not filled           not filled
C  2       DC2       1    DC1 from DC2         DC2+target
C                    2    DC2 track            DC2+target
C                    3    not filled           not filled
C                    4    DC2 track            DC2+target
C                    5    DC2 track            DC2+target
C  3       DC3       1    DC1 from DC3         DC3+target
C                    2    not filled           not filled
C                    3    DC3 track            DC3+target
C                    4    DC3 track            DC3+target
C                    5    DC3 track            DC3+target
C  4     DC2*DC3     1    DC1 from DC2/DC3     DC2+DC3+target
C                    2    DC2 track            DC2+target
C                    3    DC3 track            DC3+target
C                    4    DC2 track            DC2+DC3+target
C                    5    DC3 track            DC2+DC3+target
C  5     DC1*DC3     1    DC1 track              Lucifer
C                    2    DC3 track            not filled
C                    3    DC3 track            DC3+target
C                    4    DC3 track            DC3+target
C                    5    DC3 track            DC3+target
C  6     DC1*DC2     1    DC1 track              Lucifer
C                    2    DC2 track            DC2+target
C                    3    DC2 track            not filled
C                    4    DC2 track            DC2+target
C                    5    DC2 track            DC2+target
C  7   DC1*DC2*DC3   1    DC1 track              Lucifer
C                    2    DC2 track            DC2+target
C                    3    DC3 track            DC3+target
C                    4    DC2 track            DC2+DC3+target
C                    5    DC3 track            DC2+DC3+target
C
C---------------------------------------------------------------------
C     MULTDC(1):  Multiplicity of DC1 track only (flag = 1)
C           (2):  Multiplicity of DC2 track only (flag = 2)
C           (3):  Multiplicity of DC3 track only (flag = 3)
C           (4):  Multiplicity of DC2*DC3 track  (flag = 4)
C           (5):  Multiplicity of DC1*DC3 track  (flag = 5)
C           (6):  Multiplicity of DC1*DC2 track  (flag = 6)
C           (7):  Multiplicity of DC1*DC2 track  (flag = 7)
C           (8):  Multiplicity of good tracks    (flag = 4,7)
C           (9):  Multiplicity of DC1 tracks     (flag = 1,5,6,7)
C          (10):  Multiplicity of DC2 tracks     (flag = 2,4,6,7)
C          (11):  Multiplicity of DC3 tracks     (flag = 3,4,5,7)
C          (12):  Multiplicity of good tracks with  4<y<5
C          (13):  Multiplicity of good tracks with  10<theta<70mrad
C---------------------------------------------------------------------
+CDE,TRACK.
+CDE,KINEM.
      COMMON/HISTO/JH(20),LH(20)
      DIMENSION PLAB(4),PCM(4),TRK(4),PTARG(4),TRKTAR(4)
      INTEGER      ITRKPR(60,100),B(3)
      REAL         RTRKPR(60,100)
      EQUIVALENCE (RTRKPR,ITRKPR)
      LOGICAL      DCCUT
C---------------------------------------------------------------------
C     Initialize
C---------------------------------------------------------------------
      CALL VZERO(TRAKDC,12500)
      CALL VZERO(IRAKDC,12500)
      CALL VZERO(PDC,3000)
      CALL VZERO(MULTDC,20)
      XMULT = 0.
      DCCUT = .TRUE.
C---------------------------------------------------------------------
C  Unpack tracks   7127: FULL TRACKING     7627: POINTER TRACKING
C---------------------------------------------------------------------
      NDC=0
      LABEL = 7127
C     LABEL = 7627
      DO 100 K=1,1000
         ISIZE=60
         CALL LBCOPY(LABEL,RTRKPR(1,NDC+1),ISIZE,K)
         IF(ISIZE.EQ.0) GOTO 101
         NDC=NDC+1
100   CONTINUE
101   CONTINUE
      IF(NDC.EQ.0) RETURN
      IF(NDC.GT.100) NDC=100
C---------------------------------------------------------------------
C
C       L o o p   o v e r   a l l   t r a c k s
C
C---------------------------------------------------------------------
      DO 102 I=1,NDC
C---------------------------------------------------------------------
C       Set the track flag
C---------------------------------------------------------------------
      ITRKPR(7,I)=IAND(ITRKPR(7,I),15)
 
      CALL VZERO(B,3)
      IF(IAND(ITRKPR(7,I),1).NE.0) B(1)=1
      IF(IAND(ITRKPR(7,I),4).NE.0) B(2)=1
      IF(IAND(ITRKPR(7,I),8).NE.0) B(3)=1
 
      IRAKDC(1,I,16) = -1
      IF(B(1).EQ.1.AND.B(2).NE.1.AND.B(3).NE.1) IRAKDC(1,I,16) = 1
      IF(B(1).NE.1.AND.B(2).EQ.1.AND.B(3).NE.1) IRAKDC(1,I,16) = 2
      IF(B(1).NE.1.AND.B(2).NE.1.AND.B(3).EQ.1) IRAKDC(1,I,16) = 3
      IF(B(1).NE.1.AND.B(2).EQ.1.AND.B(3).EQ.1) IRAKDC(1,I,16) = 4
      IF(B(1).EQ.1.AND.B(2).NE.1.AND.B(3).EQ.1) IRAKDC(1,I,16) = 5
      IF(B(1).EQ.1.AND.B(2).EQ.1.AND.B(3).NE.1) IRAKDC(1,I,16) = 6
      IF(B(1).EQ.1.AND.B(2).EQ.1.AND.B(3).EQ.1) IRAKDC(1,I,16) = 7
 
      DO 123 J=2,5
 123  IRAKDC(J,I,16) = IRAKDC(1,I,16)
C---------------------------------------------------------------------
C       Calculate multiplicity for different types of tracks
C---------------------------------------------------------------------
      J=IRAKDC(1,I,16)
 
      IF(J.EQ.-1) GO TO 102
 
      IF(J.GE.1.AND.J.LE.7) THEN
         MULTDC(J) = MULTDC(J) + 1
      ENDIF
 
      IF(J.EQ.4.OR.J.EQ.7) MULTDC(8) =MULTDC(8) +1
      IF(J.EQ.1.OR.J.EQ.5.OR.J.EQ.6.OR.J.EQ.7) MULTDC(9) =MULTDC(9) +1
      IF(J.EQ.2.OR.J.EQ.4.OR.J.EQ.6.OR.J.EQ.7) MULTDC(10)=MULTDC(10)+1
      IF(J.EQ.3.OR.J.EQ.4.OR.J.EQ.5.OR.J.EQ.7) MULTDC(11)=MULTDC(11)+1
 
C---------------------------------------------------------------------
C       Track parameters for type 1,2,3
C---------------------------------------------------------------------
      TRAKDC(1,I,11) = RTRKPR(14,I)
      TRAKDC(1,I,12) = RTRKPR(15,I)
      TRAKDC(1,I,13) = RTRKPR(16,I)
      TRAKDC(1,I,14) = RTRKPR(17,I)
      TRAKDC(2,I,11) = RTRKPR(26,I)
      TRAKDC(2,I,12) = RTRKPR(27,I)
      TRAKDC(2,I,13) = RTRKPR(28,I)
      TRAKDC(2,I,14) = RTRKPR(29,I)
      TRAKDC(3,I,11) = RTRKPR(32,I)
      TRAKDC(3,I,12) = RTRKPR(33,I)
      TRAKDC(3,I,13) = RTRKPR(34,I)
      TRAKDC(3,I,14) = RTRKPR(35,I)
C---------------------------------------------------------------------
C       Track parameters for type 4,5
C---------------------------------------------------------------------
      L = IRAKDC(1,I,16)
      DO 678 J = 4,5
      IF((L.EQ.2.OR.L.EQ.6).OR.(J.EQ.4.AND.(L.EQ.4.OR.L.EQ.7))) JJ=2
      IF((L.EQ.3.OR.L.EQ.5).OR.(J.EQ.5.AND.(L.EQ.4.OR.L.EQ.7))) JJ=3
      TRAKDC(J,I,11) = TRAKDC(JJ,I,11)
      TRAKDC(J,I,12) = TRAKDC(JJ,I,12)
      TRAKDC(J,I,13) = TRAKDC(JJ,I,13)
      TRAKDC(J,I,14) = TRAKDC(JJ,I,14)
 678  CONTINUE
C---------------------------------------------------------------------
C       Sign & momentum from Lucifer (type 1 & flag 5+6+7)
C---------------------------------------------------------------------
      IF(L.EQ.5.OR.L.EQ.6.OR.L.EQ.7) THEN
         IRAKDC(1,I,10) = SIGN(1.,RTRKPR(2,I))
         TRAKDC(1,I,1) = RTRKPR(4,I)
         TRAKDC(1,I,2) = RTRKPR(5,I)
         TRAKDC(1,I,3) = RTRKPR(6,I)
         IF(RTRKPR(4,I)**2+RTRKPR(5,I)**2.GT.0.)
     *   TRAKDC(1,I,4) = SQRT(RTRKPR(4,I)**2+RTRKPR(5,I)**2)
         TRAKDC(1,I,5) = ABS(RTRKPR(2,I))
      ENDIF
C---------------------------------------------------------------------
C       Sign & momentum from target/DC2 (type 2 flag 2,4,6,7)
C---------------------------------------------------------------------
      IF(L.EQ.2.OR.L.EQ.4.OR.L.EQ.6.OR.L.EQ.7) THEN
         TRK(1) = TRAKDC(2,I,11)
         TRK(2) = TRAKDC(2,I,12)
         TRK(3) = TRAKDC(2,I,13)
         TRK(4) = TRAKDC(2,I,14)
         CALL DCMOM(TRK,PTARG,TRKTAR)
         IRAKDC(2,I,10) = SIGN(1.,PTARG(1))
         TRAKDC(2,I,1) = PTARG(2)
         TRAKDC(2,I,2) = PTARG(3)
         TRAKDC(2,I,3) = PTARG(4)
         IF(PTARG(2)**2+PTARG(3)**2.GT.0.)
     *   TRAKDC(2,I,4) = SQRT(PTARG(2)**2+PTARG(3)**2)
         TRAKDC(2,I,5) = ABS(PTARG(1))
         IF(L.EQ.2) THEN
            TRAKDC(1,I,11) = TRKTAR(1)
            TRAKDC(1,I,12) = TRKTAR(2)
            TRAKDC(1,I,13) = TRKTAR(3)
            TRAKDC(1,I,14) = TRKTAR(4)
         ENDIF
      ENDIF
C---------------------------------------------------------------------
C       Sign & momentum from target/DC3 (type 3 flag 3,4,5,7)
C---------------------------------------------------------------------
      IF(L.EQ.3.OR.L.EQ.4.OR.L.EQ.5.OR.L.EQ.7) THEN
         TRK(1) = TRAKDC(3,I,11)
         TRK(2) = TRAKDC(3,I,12)
         TRK(3) = TRAKDC(3,I,13)
         TRK(4) = TRAKDC(3,I,14)
         CALL DCMOM(TRK,PTARG,TRKTAR)
         IRAKDC(3,I,10) = SIGN(1.,PTARG(1))
         TRAKDC(3,I,1) = PTARG(2)
         TRAKDC(3,I,2) = PTARG(3)
         TRAKDC(3,I,3) = PTARG(4)
         IF(PTARG(2)**2+PTARG(3)**2.GT.0.)
     *   TRAKDC(3,I,4) = SQRT(PTARG(2)**2+PTARG(3)**2)
         TRAKDC(3,I,5) = ABS(PTARG(1))
         IF(L.EQ.3) THEN
            TRAKDC(1,I,11) = TRKTAR(1)
            TRAKDC(1,I,12) = TRKTAR(2)
            TRAKDC(1,I,13) = TRKTAR(3)
            TRAKDC(1,I,14) = TRKTAR(4)
         ENDIF
      ENDIF
C---------------------------------------------------------------------
C       Best Sign & momentum
C---------------------------------------------------------------------
      IF(L.EQ.4.OR.L.EQ.7) THEN
         TRK(1) = ( TRAKDC(2,I,11) + TRAKDC(3,I,11) ) / 2.
         TRK(2) = ( TRAKDC(2,I,12) + TRAKDC(3,I,12) ) / 2.
         TRK(3) = ( TRAKDC(2,I,13) + TRAKDC(3,I,13) ) / 2.
         TRK(4) = ( TRAKDC(2,I,14) + TRAKDC(3,I,14) ) / 2.
         CALL DCMOM(TRK,PTARG,TRKTAR)
         IRAKDC(4,I,10) = SIGN(1.,PTARG(1))
         TRAKDC(4,I,1) = PTARG(2)
         TRAKDC(4,I,2) = PTARG(3)
         TRAKDC(4,I,3) = PTARG(4)
         IF(PTARG(2)**2+PTARG(3)**2.GT.0.)
     *   TRAKDC(4,I,4) = SQRT(PTARG(2)**2+PTARG(3)**2)
         TRAKDC(4,I,5) = ABS(PTARG(1))
         IRAKDC(5,I,10) = IRAKDC(4,I,10)
         DO 73 KK = 1,5
 73      TRAKDC(5,I,KK) = TRAKDC(4,I,KK)
         IF(L.EQ.4) THEN
            TRAKDC(1,I,11) = TRKTAR(1)
            TRAKDC(1,I,12) = TRKTAR(2)
            TRAKDC(1,I,13) = TRKTAR(3)
            TRAKDC(1,I,14) = TRKTAR(4)
         ENDIF
      ENDIF
      IF(L.EQ.3.OR.L.EQ.5) THEN
         IRAKDC(4,I,10)   = IRAKDC(3,I,10)
         IRAKDC(5,I,10)   = IRAKDC(3,I,10)
         DO 78 K=1,5
            TRAKDC(4,I,K) = TRAKDC(3,I,K)
            TRAKDC(5,I,K) = TRAKDC(3,I,K)
 78      CONTINUE
      ENDIF
      IF(L.EQ.2.OR.L.EQ.6) THEN
         IRAKDC(4,I,10)   = IRAKDC(2,I,10)
         IRAKDC(5,I,10)   = IRAKDC(2,I,10)
         DO 79 K=1,5
            TRAKDC(4,I,K) = TRAKDC(2,I,K)
            TRAKDC(5,I,K) = TRAKDC(2,I,K)
 79      CONTINUE
      ENDIF
      IF(L.EQ.2.OR.L.EQ.3.OR.L.EQ.4) THEN
         IRAKDC(1,I,10) = IRAKDC(5,I,10)
         DO 83 KK = 1,5
 83      TRAKDC(1,I,KK) = TRAKDC(5,I,KK)
      ENDIF
C---------------------------------------------------------------------
C       Theta & Eta & Phi
C---------------------------------------------------------------------
      DO 90 J=1,5
         TRAKDC(J,I,17) =
     *   ACOS(1./SQRT(TRAKDC(J,I,13)**2 + TRAKDC(J,I,11)**2 + 1.))
         IF(TAN(TRAKDC(J,I,17)/2.).GT.0.)
     *   TRAKDC(J,I,18) = -ALOG(TAN(TRAKDC(J,I,17)/2.))
         IF(TRAKDC(J,I,11).NE.0.)
     *   TRAKDC(J,I,19) = ATAN2(TRAKDC(J,I,13),TRAKDC(J,I,11))
         IF(TRAKDC(J,I,19).LE.0.) TRAKDC(J,I,19)=TRAKDC(J,I,19)+PI2
C---------------------------------------------------------------------
C    Calculate closest distance to target (R)
C---------------------------------------------------------------------
         X0    = TRAKDC(J,I,12)
         Y0    = TRAKDC(J,I,14)
         ALPHA = TRAKDC(J,I,11)
         BETA  = TRAKDC(J,I,13)
         CALL DISLP(0.,0.,0.,X0,Y0,0.,ALPHA,BETA,1.,XC,YC,ZC,RC)
         TRAKDC(J,I,7) = RC
C---------------------------------------------------------------------
C    Calculate Z at closest distance to Z-axis (CPA)
C---------------------------------------------------------------------
         CALL DISLL
     *   (0.,0.,0.,0.,0.,1.,X0,Y0,0.,ALPHA,BETA,1.,XC,YC,ZC,RC,Z)
         TRAKDC(J,I,8) = Z
 90   CONTINUE
C---------------------------------------------------------------------
C       Multiplicity if 4<eta<5 or 10<theta<70 mrad
C---------------------------------------------------------------------
C     J=IRAKDC(1,I,16)
C     E=TRAKDC(1,I,18)
C     P=TRAKDC(5,I,5)
C     IF(J.EQ.4.OR.J.EQ.7.AND.P.GT.15.) THEN
C     IF(J.EQ.4.OR.J.EQ.7.AND.(E.GT.4.AND.E.LT.5.)) THEN
C        MULTDC(12)=MULTDC(12)+1
C     ENDIF
C     E=TRAKDC(1,I,17)
C     IF(J.EQ.4.OR.J.EQ.7.AND.(E.GT.0.010.AND.E.LT.0.070)) THEN
C     ENDIF
C     IF(J.EQ.4.OR.J.EQ.7.AND.(E.GT.0.010.AND.E.LT.0.070)) THEN
C        XMULT=XMULT + 1./( 0.85 * (1. - 0.0046/E) )
C     ENDIF
      J=IRAKDC(1,I,16)
      E=TRAKDC(1,I,17)
      P=TRAKDC(5,I,5)
      Y0= TRAKDC(2,I,14)
C     IF(P.GT.10.) THEN
      IF(ABS(Y0).LT.0.45) THEN
         IF(J.EQ.4.OR.J.EQ.7.AND.(E.GT.0.010.AND.E.LT.0.070)) THEN
            MULTDC(12)=MULTDC(12)+1
         ENDIF
      ENDIF
C     ENDIF
C---------------------------------------------------------------------
C       Chi square / NDF
C---------------------------------------------------------------------
      IF(ITRKPR(19,I).GT.0) THEN
         TRAKDC(1,I,15) = RTRKPR(18,I)/FLOAT(ITRKPR(19,I))
      ELSE
         TRAKDC(1,I,15) = 100000.
      ENDIF
      IF(ITRKPR(31,I).GT.0) THEN
         TRAKDC(2,I,15) = RTRKPR(30,I)/FLOAT(ITRKPR(31,I))
      ELSE
         TRAKDC(2,I,15) = 100000.
      ENDIF
      IF(ITRKPR(37,I).GT.0) THEN
         TRAKDC(3,I,15) = RTRKPR(36,I)/FLOAT(ITRKPR(37,I))
      ELSE
         TRAKDC(3,I,15) = 100000.
      ENDIF
      IF(L.EQ.3) THEN
         TRAKDC(4,I,15)   = TRAKDC(3,I,15)
         TRAKDC(5,I,15)   = TRAKDC(3,I,15)
      ELSE
         TRAKDC(4,I,15)   = TRAKDC(2,I,15)
         TRAKDC(5,I,15)   = TRAKDC(2,I,15)
      ENDIF
C---------------------------------------------------------------------
C
C                 L A B   ->   C M S
C
C---------------------------------------------------------------------
C       Assume the track is an electron
C---------------------------------------------------------------------
       PDC(1,I,6) = EM
       PLAB(1)    = TRAKDC(4,I,1)
       PLAB(2)    = TRAKDC(4,I,2)
       PLAB(3)    = TRAKDC(4,I,3)
       PLAB(4)    = SQRT(TRAKDC(4,I,5)**2 + EM**2)
       CALL LABCMS(PLAB,PCM)
       PDC(1,I,1) = PCM(1)
       PDC(1,I,2) = PCM(2)
       PDC(1,I,3) = PCM(3)
       PDC(1,I,4) = PCM(4)
       PDC(1,I,5) = SQRT(PCM(1)**2 + PCM(2)**2 + PCM(3)**2)
       PDC(1,I,7) = ACOS(PDC(1,I,3)/PDC(1,I,5))
       IF(TAN(PDC(1,I,7)/2.).GT.0.)
     * PDC(1,I,8) = -ALOG(TAN(PDC(1,I,7)/2.))
       IF(PDC(1,I,4)-PDC(1,I,3).NE.0.) PDC(1,I,9) =
     * ALOG(ABS((PDC(1,I,4)+PDC(1,I,3))/(PDC(1,I,4)-PDC(1,I,3))))/2.
       PDC(1,I,10)= 2.*PCM(3)/TSS
C---------------------------------------------------------------------
C       Assume the track is a muon
C---------------------------------------------------------------------
       PDC(2,I,6) = MUM
       PLAB(4)    = SQRT(TRAKDC(4,I,5)**2 + MUM**2)
       CALL LABCMS(PLAB,PCM)
       PDC(2,I,1) = PCM(1)
       PDC(2,I,2) = PCM(2)
       PDC(2,I,3) = PCM(3)
       PDC(2,I,4) = PCM(4)
       PDC(2,I,5) = SQRT(PCM(1)**2 + PCM(2)**2 + PCM(3)**2)
       PDC(2,I,7) = ACOS(PDC(2,I,3)/PDC(2,I,5))
       IF(TAN(PDC(2,I,7)/2.).GT.0.)
     * PDC(2,I,8) = -ALOG(TAN(PDC(2,I,7)/2.))
       IF(PDC(2,I,4)-PDC(2,I,3).NE.0.) PDC(2,I,9) =
     * ALOG(ABS((PDC(2,I,4)+PDC(2,I,3))/(PDC(2,I,4)-PDC(2,I,3))))/2.
       PDC(2,I,10)= 2.*PCM(3)/TSS
C---------------------------------------------------------------------
C       Assume the track is a pion
C---------------------------------------------------------------------
       PDC(3,I,6) = PIM
       PLAB(4)    = SQRT(TRAKDC(4,I,5)**2 + PIM**2)
       CALL LABCMS(PLAB,PCM)
       PDC(3,I,1) = PCM(1)
       PDC(3,I,2) = PCM(2)
       PDC(3,I,3) = PCM(3)
       PDC(3,I,4) = PCM(4)
       PDC(3,I,5) = SQRT(PCM(1)**2 + PCM(2)**2 + PCM(3)**2)
       PDC(3,I,7) = ACOS(PDC(3,I,3)/PDC(3,I,5))
       IF(TAN(PDC(3,I,7)/2.).GT.0.)
     * PDC(3,I,8) = -ALOG(TAN(PDC(3,I,7)/2.))
       IF(PDC(3,I,4)-PDC(3,I,3).NE.0.) PDC(3,I,9) =
     * ALOG(ABS((PDC(3,I,4)+PDC(3,I,3))/(PDC(3,I,4)-PDC(3,I,3))))/2.
       PDC(3,I,10)= 2.*PCM(3)/TSS
 102   CONTINUE
C---------------------------------------------------------------------
C
C                 E n d   o f   t r a c k   l o o p
C
C---------------------------------------------------------------------
C       Save corrected DC mult
C---------------------------------------------------------------------
      MULTDC(13)=NINT(XMULT)
C---------------------------------------------------------------------
C
C                     H i s t o g r a m s
C
C---------------------------------------------------------------------
      IF(JH(5).EQ.0) GO TO 999
C---------------------------------------------------------------------
C      track multiplicity
C---------------------------------------------------------------------
      DO 35 I=1,7
         IF(MULTDC(I).EQ.0) GO TO 35
         DO 34 J=1,MULTDC(I)
            CALL HFILL(LH(5)+4,FLOAT(I),0.,1.)
 34      CONTINUE
 35   CONTINUE
      CALL HFILL(LH(5)+5,FLOAT(NDC),0.,1.)
      CALL HFILL(LH(5)+1,FLOAT(MULTDC(9)),0.,1.)
      CALL HFILL(LH(5)+2,FLOAT(MULTDC(10)),0.,1.)
      CALL HFILL(LH(5)+3,FLOAT(MULTDC(11)),0.,1.)
      CALL HFILL(LH(5)+6,FLOAT(MULTDC(8)),0.,1.)
      CALL HFILL(LH(5)+7,FLOAT(MULTDC(8)),FLOAT(MULTSC),1.)
C---------------------------------------------------------------------
C      Momentum etc
C---------------------------------------------------------------------
      DO 777 I=1,NDC
      IF(IRAKDC(1,I,16).LE.4) GO TO 777
      CALL HFILL(LH(5)+10,TRAKDC(1,I,4),0.,1.)
      CALL HFILL(LH(5)+11,TRAKDC(1,I,5),0.,1.)
      CALL HFILL(LH(5)+12,TRAKDC(1,I,15),0.,1.)
      CALL HFILL(LH(5)+13,TRAKDC(1,I,11),0.,1.)
      CALL HFILL(LH(5)+14,TRAKDC(1,I,13),0.,1.)
      CALL HFILL(LH(5)+15,TRAKDC(1,I,17),0.,1.)
      CALL HFILL(LH(5)+16,TRAKDC(1,I,18),0.,1.)
      CALL HFILL(LH(5)+17,TRAKDC(1,I,19),0.,1.)
      CALL HFILL(LH(5)+18,PDC(3,I,5),0.,1.)
      CALL HFILL(LH(5)+19,PDC(3,I,7),0.,1.)
      CALL HFILL(LH(5)+20,PDC(3,I,8),0.,1.)
      CALL HFILL(LH(5)+21,PDC(3,I,10),0.,1.)
      CALL HFILL(LH(5)+23,TRAKDC(1,I,8),0.,1.)
      CALL HFILL(LH(5)+24,TRAKDC(1,I,8),TRAKDC(1,I,7),1.)
 777  CONTINUE
C---------------------------------------------------------------------
C               Cut
C---------------------------------------------------------------------
 999  CONTINUE
      IF(MULTDC(8).EQ.0) DCCUT=.FALSE.
      RETURN
      END
+EOD.
C*********************************************************************
C
C                         D C M O M
C
C*********************************************************************
+DECK, DCMOM.
      SUBROUTINE DCMOM(TRKPR,P,TRKTAR)
C---------------------------------------------------------------------
C   This routine calculates the momentum using vertex instead of DC1
C---------------------------------------------------------------------
C
C  input  TRKPR(4) : track parameters after the magnet.
C                    (1=Xslope 2=Xintercept 3=Yslope 4=Yintercept)
C  output P(4)     : 1: momentum with sign, 2-4: Px,Py,Pz.
C         TRKTAR(4): track parameters before magnet
C                    (1=Xslope 2=Xintercept 3=Yslope 4=Yintercept)
C
C---------------------------------------------------------------------
+CDE,MYINFO.
      REAL TRKPR(4),P(4),TRKTAR(4)
C---------------------------------------------------------------------
C  Get X,Y at the bending point (ZM)
C---------------------------------------------------------------------
      XMAG = ZM*TRKPR(1)+TRKPR(2)
      YMAG = ZM*TRKPR(3)+TRKPR(4)
C---------------------------------------------------------------------
C  Get angles
C---------------------------------------------------------------------
      DZ   = ZM    - ZTARG
      DX   = XMAG  - XTARG
      DY   = YMAG  - YTARG
      ANGX = DX/DZ
      ANGY = DY/DZ
      BEND = TRKPR(1)-ANGX
      PXZ  = 0.
      IF(BEND.NE.0.) PXZ = PKICKM/BEND
C---------------------------------------------------------------------
C  Get momentum
C---------------------------------------------------------------------
      PZQ  = PXZ / SQRT(1.+ANGX**2)
      P(4) = ABS(PZQ)
      P(2) = P(4)*ANGX
      P(3) = P(4)*ANGY
      P(1) = PZQ * SQRT(1.+ANGX**2+ANGY**2)
C---------------------------------------------------------------------
C  Get track parameters at target
C---------------------------------------------------------------------
      TRKTAR(1) =  ANGX
      TRKTAR(2) = -ANGX * ZTARG
      TRKTAR(3) =  ANGY
      TRKTAR(4) = -ANGY * ZTARG
      RETURN
      END
+EOD.
C*********************************************************************
C
C                         K I N M A T
C
C*********************************************************************
+DECK, KINMAT.
      SUBROUTINE KINMAT
C---------------------------------------------------------------------
C     TMB   : Mass of beam
C     TMT   : Mass of target
C     TPBL  : Beam momentum in lab
C     TPBC  : Beam momentum in cm
C     TEBL  : Energy of the beam in lab
C     TSS   : SQRT S (=cm-energy)
C     TLOR  : 4-momentum of cm sytem in lab frame
C---------------------------------------------------------------------
+CDE,KINEM.
      TMB=PRM
      TMT=PRM
      TPBL=450.
      TEBL=SQRT(TPBL**2+TMB**2)
      TSS=SQRT(TMB**2+TMT**2+2*TMT*TEBL)
      TBET=TPBL/(TEBL+TMT)
      TPBC=TPBL*TMT/TSS
      TLOR(1)=0.
      TLOR(2)=0.
      TLOR(3)=TPBL
      TLOR(4)=TEBL+TMT
      RETURN
      END
+EOD.
C*********************************************************************
C
C                         L A B C M S
C
C*********************************************************************
+DECK, LABCMS.
      SUBROUTINE LABCMS(PLAB,PCM)
      DIMENSION PLAB(4),PCM(4)
      COMMON/TLOR/TMB,TMT,TPBL,TPBC,TSS,TBET,TLOR(4)
      CALL LORENF(TSS,TLOR,PLAB(1),PCM(1))
      RETURN
      END
+EOD.
C*********************************************************************
C
C                         M Y B O O K
C
C*********************************************************************
+DECK,MYBOOK.   MY BOOKING ROUTINE
      SUBROUTINE MYBOOK
C---------------------------------------------------------------------
C    This routine books histograms
C---------------------------------------------------------------------
+CDE,MUSTAT,HISTO.
+CDE,MYSPAD.
+CDE,MYINFO.
      CHARACTER*72 GP16
C---------------------------------------------------------------------
C    Calculate histogram #
C---------------------------------------------------------------------
      DO 999 I = 1,20
         LH(I) = 1000*I
 999  CONTINUE
C---------------------------------------------------------------------
C    Single Muon histograms
C---------------------------------------------------------------------
      IF(JH(1).EQ.0) GO TO 1
      CALL HBOOK1(LH(1)+0,
     *'NUMBER OF HITS IN PC0 & PC1$',60,0.,60.,0.)
      CALL HBOOK1(LH(1)+1,
     *'NMU$',15,0.,15.,0.)
      CALL HBOOK1(LH(1)+2,
     *'# OF HOD. HIT$',5,0.,5.,0.)
      CALL HBOOK1(LH(1)+3,
     *'ALPHA$',50,-0.25,0.25,0.)
      CALL HBOOK1(LH(1)+4,
     *'BETA$',50,-0.25,0.25,0.)
      CALL HBOOK1(LH(1)+5,
     *'THETA IN LAB$',50,0.,0.2,0.)
      CALL HBOOK1(LH(1)+6,
     *'ETA IN LAB$',60,1.,7.0,0.)
      CALL HBOOK1(LH(1)+7,
     *'PHI$',63,0.,6.3,0.)
      CALL HBOOK1(LH(1)+8,
     *'Z AT MIN. DISTANCE TO Z-AXIS (CPA)$',50,-500.,1000.,0.)
      CALL HBOOK2(LH(1)+9,
     *'R VS CPA$',50,-500.,1000.,25,0.,100.,0.)
      CALL HBOOK1(LH(1)+10,
     *'CHI SQUARE/NDF$',50,0.,5.,0.)
      CALL HBOOK1(LH(1)+11,
     *'PT$',60,0.,2.4,0.)
      CALL HBOOK1(LH(1)+12,
     *'P IN LAB$',60,0.,30.,0.)
      CALL HBOOK1(LH(1)+13,
     *'MULT. SCATT. ANGLE/SIGMA$',50,0.,5.,0.)
      CALL HBOOK1(LH(1)+14,
     *'MULT. SCATT. ANGLE IN X/SIGMA$',50,-5.,5.,0.)
      CALL HBOOK1(LH(1)+15,
     *'MULT. SCATT. ANGLE IN Y/SIGMA$',50,-5.,5.,0.)
      CALL HBOOK1(LH(1)+16,
     *'R AT ULAC FRONT$',60,0.,60.,0.)
      CALL HBOOK1(LH(1)+17,
     *'ENERGY LOSS$',60,0.,6.,0.)
      CALL HBOOK1(LH(1)+18,
     *'P IN CM$',60,0.,3.,0.)
      CALL HBOOK1(LH(1)+19,
     *'THETA IN CM$',62,0.,3.1,0.)
      CALL HBOOK1(LH(1)+20,
     *'ETA IN CM$',60,-2.0,5.0,0.)
      CALL HBOOK1(LH(1)+21,
     *'XF$',60,-0.1,0.5,0.)
 1    CONTINUE
C---------------------------------------------------------------------
C    Si Pads
C---------------------------------------------------------------------
      IF(JH(2).EQ.0) GO TO 2
      CALL HBOOK1(LH(2)+1,
     *'SIPAD MULTIPLICITY$',30,0.,30.,0.)
 2    CONTINUE
C---------------------------------------------------------------------
C    Scintillator pads
C---------------------------------------------------------------------
      IF(JH(3).EQ.0) GO TO 3
      CALL HBOOK1(LH(3)+100,
     *'SCINT. PAD MULT. SOFT$',30,0.,30.,0.)
      CALL HBOOK1(LH(3)+101,
     *'SCINT. PAD MULT. SINGELS$',30,0.,30.,0.)
      CALL HBOOK1(LH(3)+102,
     *'SCINT. PAD MULT. DOUBLES$',30,0.,30.,0.)
      CALL HBOOK1(LH(3)+103,
     *'SCINT. PAD MULT. DISC.$',30,0.,30.,0.)
      CALL HBOOK1(LH(3)+120,
     *'SCINT. PAD DISC HITS  $',80,0.,80.,0.)
      CALL HBOOK2(LH(3)+110,
     *'SCINT. PAD HIT PATTERN$',64,-32.,32.,30,-30.,30.,0.)
      DO 30 I=1,80
        IF(IHIST(I).EQ.1)
     *  CALL HBOOK1(LH(3)+I,
     *  'SCINT. PAD ADC$',60,0.,600.,0.)
        IF(IHIST(I).EQ.2)
     *  CALL HBOOK1(LH(3)+I,
     *  'SCINT. PAD ADC$',60,0.,1200.,0.)
        IF(IHIST(I).EQ.3)
     *  CALL HBOOK1(LH(3)+I,
     *  'SCINT. PAD ADC$',60,0.,1800.,0.)
 30   CONTINUE
 3    CONTINUE
C---------------------------------------------------------------------
C    Cone cal
C---------------------------------------------------------------------
      IF(JH(4).EQ.0) GO TO 4
      DO 40 J=1,8
        CALL HBOOK1(LH(4)+J,
     *  'CONE CAL ADC$',50,0.,250.,0.)
        CALL HBOOK1(LH(4)+J+10,
     *  'CONE CAL ADC$',50,0.,5000.,0.)
 40   CONTINUE
        CALL HBOOK1(LH(4)+20,
     *  'CONE CAL MULT$',30,0.,30.,0.)
 4    CONTINUE
C---------------------------------------------------------------------
C    DC histograms
C---------------------------------------------------------------------
      IF(JH(5).EQ.0) GO TO 5
      CALL HBOOK1(LH(5)+4,
     *'NUMBER OF TRACKS OF DIFF. TYPE$',8,0.,8.,0.)
      CALL HBOOK1(LH(5)+5,
     *'MULT. OF ALL TRACKS (NDC)$',30,0.,30.,0.)
      CALL HBOOK1(LH(5)+1,
     *'MULT. DC1 TRACKS$',30,0.,30.,0.)
      CALL HBOOK1(LH(5)+2,
     *'MULT. DC2 TRACKS$',30,0.,30.,0.)
      CALL HBOOK1(LH(5)+3,
     *'MULT. DC3 TRACKS$',30,0.,30.,0.)
      CALL HBOOK1(LH(5)+6,
     *'MULT. OF LONG TRACKS$',30,0.,30.,0.)
      CALL HBOOK2(LH(5)+7,
     *'DC VS SI PAD MULT$',20,0.,20.,20,0.,20.,0.)
      CALL HBOOK1(LH(5)+8,
     *'TRACK FINDING EFF.$',19,1.,20.,0.)
      CALL HBOOK1(LH(5)+10,
     *'PT$',60,0.,2.4,0.)
      CALL HBOOK1(LH(5)+11,
     *'P IN LAB$',60,0.,30.,0.)
      CALL HBOOK1(LH(5)+12,
     *'CHI SQUARE/NDF$',50,0.,5.,0.)
      CALL HBOOK1(LH(5)+13,
     *'ALPHA$',50,-0.25,0.25,0.)
      CALL HBOOK1(LH(5)+14,
     *'BETA$',50,-0.25,0.25,0.)
      CALL HBOOK1(LH(5)+15,
     *'THETA IN LAB$',50,0.,0.2,0.)
      CALL HBOOK1(LH(5)+16,
     *'ETA IN LAB$',60,1.,7.0,0.)
      CALL HBOOK1(LH(5)+17,
     *'PHI$',63,0.,6.3,0.)
      CALL HBOOK1(LH(5)+18,
     *'P IN CM IF PION$',60,0.,3.,0.)
      CALL HBOOK1(LH(5)+19,
     *'THETA IN CM IF PION$',62,0.,3.1,0.)
      CALL HBOOK1(LH(5)+20,
     *'ETA IN CM IF PION$',60,-2.0,5.0,0.)
      CALL HBOOK1(LH(5)+21,
     *'XF IF PION$',60,-0.1,0.5,0.)
      CALL HBOOK1(LH(5)+23,
     *'Z AT MIN. DIST. TO Z-AXIS (CPA)$',50,-25.,25.,0.)
      CALL HBOOK2(LH(5)+24,
     *'R VS CPA$',50,-25.,25.,25,0.,2.,0.)
      CALL HBOOK1(LH(5)+51,
     *'DELTA X (SAME SIGN)$',60,0.,30.,0.)
      CALL HBOOK1(LH(5)+54,
     *'DELTA X (SAME SIGN)$',60,0.,6.,0.)
      CALL HBOOK1(LH(5)+52,
     *'DELTA Y (SAME SIGN)$',60,0.,30.,0.)
      CALL HBOOK1(LH(5)+55,
     *'DELTA Y (SAME SIGN)$',60,0.,6.,0.)
      CALL HBOOK1(LH(5)+53,
     *'R       (SAME SIGN)$',60,0.,30.,0.)
      CALL HBOOK1(LH(5)+56,
     *'R       (SAME SIGN)$',60,0.,6.,0.)
      CALL HBOOK1(LH(5)+61,
     *'DELTA X (OPP. SIGN)$',60,0.,30.,0.)
      CALL HBOOK1(LH(5)+64,
     *'DELTA X (OPP. SIGN)$',60,0.,6.,0.)
      CALL HBOOK1(LH(5)+62,
     *'DELTA Y (OPP. SIGN)$',60,0.,30.,0.)
      CALL HBOOK1(LH(5)+65,
     *'DELTA Y (OPP. SIGN)$',60,0.,6.,0.)
      CALL HBOOK1(LH(5)+63,
     *'R       (OPP. SIGN)$',60,0.,30.,0.)
      CALL HBOOK1(LH(5)+66,
     *'R       (OPP. SIGN)$',60,0.,6.,0.)
 5    CONTINUE
C---------------------------------------------------------------------
C    Muon hodoscope multiplicity
C---------------------------------------------------------------------
      IF(JH(6).EQ.0) GO TO 6
      CALL HBOOK1(LH(6)+1,
     *'MULTIPLICITY IN HODOSC. WALL 1 (BEFORE IRON)$',30,0.,30.,0.)
      CALL HBOOK1(LH(6)+2,
     *'MULTIPLICITY IN HODOSC. WALL 2 (AFTER IRON)$',30,0.,30.,0.)
      CALL HBOOK1(LH(6)+11,
     *'X(H3) (++) + (--)$',24,-300.,300.,0.)
      CALL HBOOK1(LH(6)+12,
     *'X(H3) (+-)$',24,-300.,300.,0.)
      CALL HBOOK1(LH(6)+21,
     *'X(H2) (++) + (--)$',24,-300.,300.,0.)
      CALL HBOOK1(LH(6)+22,
     *'X(H2) (+-)$',24,-300.,300.,0.)
      CALL HBOOK1(LH(6)+31,
     *'X(H2+1M) (++) + (--)$',24,-300.,300.,0.)
      CALL HBOOK1(LH(6)+32,
     *'X(H2+1M) (+-)$',24,-300.,300.,0.)
      CALL HBOOK1(LH(6)+110,
     *'Y(H3) (++) + (--)$',24,-300.,300.,0.)
      CALL HBOOK1(LH(6)+120,
     *'Y(H3) (+-)$',24,-300.,300.,0.)
      CALL HBOOK1(LH(6)+210,
     *'Y(H2) (++) + (--)$',24,-300.,300.,0.)
      CALL HBOOK1(LH(6)+220,
     *'Y(H2) (+-)$',24,-300.,300.,0.)
      CALL HBOOK1(LH(6)+310,
     *'Y(H2+1M) (++) + (--)$',24,-300.,300.,0.)
      CALL HBOOK1(LH(6)+320,
     *'Y(H2+1M) (+-)$',24,-300.,300.,0.)
 6    CONTINUE
C---------------------------------------------------------------------
C    Trigger histograms
C---------------------------------------------------------------------
      IF(JH(7).EQ.0) GO TO 7
      CALL HBOOK1(LH(7)+1,
     *'VFB TRIGGERS$',51,0.,51.,0.)
      CALL HBOOK1(LH(7)+2,
     *'INPUT VFB (ENCODED LINES OR SPY)$',50,0.,50.,0.)
      CALL HBOOK1(LH(7)+3,
     *'PRE TRIGGERS$',8,0.,8.,0.)
 7    CONTINUE
C---------------------------------------------------------------------
C    Beam scintillators
C---------------------------------------------------------------------
      IF(JH(8).EQ.0) GO TO 8
      CALL HBOOK1(LH(8)+1,
     *'B6A PULSEHEIGHT$',50,0.,100.,0.)
      CALL HBOOK1(LH(8)+2,
     *'B6B PULSEHEIGHT$',50,0.,100.,0.)
      CALL HBOOK1(LH(8)+3,
     *'B3A PULSEHEIGHT$',60,0.,1200.,0.)
      CALL HBOOK1(LH(8)+4,
     *'B3B PULSEHEIGHT$',60,0.,1200.,0.)
      CALL HBOOK1(LH(8)+7,
     *'B7A PULSEHEIGHT$',60,0.,300.,0.)
      CALL HBOOK1(LH(8)+8,
     *'B7B PULSEHEIGHT$',60,0.,300.,0.)
      CALL HBOOK1(LH(8)+16,
     *'BEAM MULTIHIT TDC$',60,-1500.,1500.,0.)
      CALL HBOOK1(LH(8)+17,
     *'INT MULTIHIT TDC$',60,-1500.,1500.,0.)
      CALL HBOOK1(LH(8)+18,
     *'VETO MULTIHIT TDC$',60,-700.,800.,0.)
      IF(YEAR.LE.1987) THEN
      CALL HBOOK1(LH(8)-2,
     *'B1A PULSEHEIGHT$',50,0.,1000.,0.)
      CALL HBOOK1(LH(8)-1,
     *'B1B PULSEHEIGHT$',50,0.,1000.,0.)
      CALL HBOOK1(LH(8)+0,
     *'B2  PULSEHEIGHT$',50,0.,1000.,0.)
      CALL HBOOK1(LH(8)+5,
     *'B3A PULSEHEIGHT AFTER TDC CUT$',60,0.,1200.,0.)
      CALL HBOOK1(LH(8)+6,
     *'B3B PULSEHEIGHT AFTER TDC CUT$',60,0.,1200.,0.)
      CALL HBOOK1(LH(8)+9,
     *'B6A TIME$',50,25.,30.,0.)
      CALL HBOOK1(LH(8)+10,
     *'B6B TIME$',50,25.,30.,0.)
      CALL HBOOK1(LH(8)+11,
     *'B3A TIME$',50,31.,41.,0.)
      CALL HBOOK1(LH(8)+12,
     *'B3B TIME$',50,31.,41.,0.)
      CALL HBOOK1(LH(8)+13,
     *'T0$',50,25.,30.,0.)
      CALL HBOOK1(LH(8)+14,
     *'TSV$',50,31.,41.,0.)
      CALL HBOOK1(LH(8)+15,
     *'TOF$',50,3.,13.,0.)
      CALL HBOOK1(LH(8)+19,
     *'B3A PULSEHEIGHT TDC CENTER   $',60,0.,1200.,0.)
      CALL HBOOK1(LH(8)+20,
     *'B3A PULSEHEIGHT TDC TAIL     $',60,0.,1200.,0.)
      CALL HBOOK1(LH(8)+21,
     *'B3B PULSEHEIGHT TDC CENTER   $',60,0.,1200.,0.)
      CALL HBOOK1(LH(8)+22,
     *'B3B PULSEHEIGHT TDC TAIL     $',60,0.,1200.,0.)
      CALL HBOOK1(LH(8)+31,
     *'      C1        $',60,-200.,1600.,0.)
      CALL HBOOK1(LH(8)+32,
     *'      C2        $',50,-3000.,7000.,0.)
      CALL HBOOK1(LH(8)+33,
     *'      C3        $',60,-200.,1600.,0.)
      CALL HBOOK1(LH(8)+34,
     *'      C4        $',50,-3000.,7000.,0.)
      ENDIF
 8    CONTINUE
C---------------------------------------------------------------------
C    Calorimeter histograms
C---------------------------------------------------------------------
      IF(JH(9).EQ.0) GO TO 9
      CALL HBOOK1(LH(9)+0,
     *'MULTIPLICITY$',30,0.,30.,0.)
      CALL HBOOK1(LH(9)-1,
     *'MULTIPLICITY FOR FAKE COMB.$',30,0.,30.,0.)
      CALL HBOOK1(LH(9)-2,
     *'NUMBER OF MUONS FOUND$',30,0.,30.,0.)
      CALL HBOOK1(LH(9)+1,
     *'ETOT FROM FLASH ADC$',60,0.,1200.,0.)
      CALL HBOOK1(LH(9)+2,
     *'ETOT FROM FLASH ADC & MUONS$',60,0.,600.,0.)
      CALL HBOOK1(LH(9)+11,
     *'ETOT FROM MUONS$',60,0.,60.,0.)
      CALL HBOOK1(LH(9)+3,
     *'ENERGY IN VETO CAL$',25,0.,25.,0.)
      CALL HBOOK1(LH(9)+4,
     *'ET IN ULAC$',30,0.,15.,0.)
      CALL HBOOK1(LH(9)+40,
     *'PT IN DC$',30,0.,15.,0.)
      CALL HBOOK1(LH(9)+44,
     *'ET + PT$',30,0.,15.,0.)
      CALL HBOOK2(LH(9)+5,
     *'ET VS SI PAD MULT$',30,0.,30.,30,0.,30.,0.)
      CALL HBOOK2(LH(9)+12,
     *'DC2 MULT VS SI PAD MULT$',30,0.,30.,30,0.,30.,0.)
      CALL HBOOK2(LH(9)+120,
     *'DC MULT VS PT SUM$',100,0.,50.,30,0.,30.,0.)
      CALL HBOOK1(LH(9)+6,
     *'MULT. 0<ET<1.5 GEV$',30,0.,30.,0.)
      CALL HBOOK1(LH(9)+7,
     *'MULT. 1.5<ET<3 GEV$',30,0.,30.,0.)
      CALL HBOOK1(LH(9)+8,
     *'MULT. 3<ET<4.5 GEV$',30,0.,30.,0.)
      CALL HBOOK1(LH(9)+9,
     *'MULT. 4.5<ET<6 GEV$',30,0.,30.,0.)
      CALL HBOOK1(LH(9)+10,
     *'MULT. 6<ET<9 GEV$',30,0.,30.,0.)
      CALL HBOOK1(LH(9)+60,
     *'MULT. = 2  $',30,0.,30.,0.)
      CALL HBOOK1(LH(9)+70,
     *'MULT. = 3  $',30,0.,30.,0.)
      CALL HBOOK1(LH(9)+80,
     *'MULT. = 4  $',30,0.,30.,0.)
      CALL HBOOK1(LH(9)+90,
     *'MULT. = 5   $',30,0.,30.,0.)
      CALL HBOOK1(LH(9)+100,
     *'MULT. = 6    $',30,0.,30.,0.)
      CALL HBOOK1(LH(9)+110,
     *'MULT. = 7-9  $',30,0.,30.,0.)
      CALL HBOOK1(LH(9)+121,
     *'MULT. = 10-13$',30,0.,30.,0.)
      CALL HBOOK1(LH(9)+13,
     *'ET IN ULAC  0 < ET < 1$',30,0.,15.,0.)
      CALL HBOOK1(LH(9)+14,
     *'ET IN ULAC  1 < ET < 2$',30,0.,15.,0.)
      CALL HBOOK1(LH(9)+15,
     *'ET IN ULAC  2 < ET < 3$',30,0.,15.,0.)
      CALL HBOOK1(LH(9)+16,
     *'ET IN ULAC  3 < ET < 4$',30,0.,15.,0.)
      CALL HBOOK1(LH(9)+17,
     *'ET IN ULAC  4 < ET < 5$',30,0.,15.,0.)
      CALL HBOOK1(LH(9)+18,
     *'ET IN ULAC  5 < ET < 7$',30,0.,15.,0.)
      CALL HBOOK1(LH(9)+19,
     *'ET IN ULAC  7 < ET <12$',30,0.,15.,0.)
      CALL HBOOK1(LH(9)+61,
     *'PT IN DC  0 < ET < 1.5$',30,0.,15.,0.)
      CALL HBOOK1(LH(9)+62,
     *'PT IN DC  1.5 < ET < 3$',30,0.,15.,0.)
      CALL HBOOK1(LH(9)+63,
     *'PT IN DC  3 < ET < 4.5$',30,0.,15.,0.)
      CALL HBOOK1(LH(9)+64,
     *'PT IN DC  4.5 < ET < 6$',30,0.,15.,0.)
      CALL HBOOK1(LH(9)+65,
     *'PT IN DC  6 < ET < 9$',30,0.,15.,0.)
      CALL HBOOK1(LH(9)+71,
     *'ET + PT  1 < ET+PT < 3$',30,0.,15.,0.)
      CALL HBOOK1(LH(9)+72,
     *'ET + PT  3 < ET+PT < 5$',30,0.,15.,0.)
      CALL HBOOK1(LH(9)+73,
     *'ET + PT  5 < ET+PT < 7$',30,0.,15.,0.)
      CALL HBOOK1(LH(9)+74,
     *'ET + PT  7 < ET+PT < 9$',30,0.,15.,0.)
      CALL HBOOK1(LH(9)+75,
     *'ET + PT  9 < ET+PT < 13$',30,0.,15.,0.)
 9    CONTINUE
C---------------------------------------------------------------------
C   Muon pair histograms
C---------------------------------------------------------------------
      IF(JH(10).EQ.0) GO TO 10
 
      CALL HBOOK1(LH(10)+506,
     *'MULT. (++)+(--) 0<ET<1.5 GEV$',30,0.,30.,0.)
      CALL HBOOK1(LH(10)+507,
     *'MULT. (++)+(--) 1.5<ET<3 GEV$',30,0.,30.,0.)
      CALL HBOOK1(LH(10)+508,
     *'MULT. (++)+(--) 3<ET<4.5 GEV$',30,0.,30.,0.)
      CALL HBOOK1(LH(10)+509,
     *'MULT. (++)+(--) 4.5<ET<6 GEV$',30,0.,30.,0.)
      CALL HBOOK1(LH(10)+510,
     *'MULT. (++)+(--) 6<ET<9 GEV$',30,0.,30.,0.)
 
      CALL HBOOK1(LH(10)+606,
     *'PT    (++)+(--) 0<ET<1.5 GEV$',30,0.,15.,0.)
      CALL HBOOK1(LH(10)+607,
     *'PT    (++)+(--) 1.5<ET<3 GEV$',30,0.,15.,0.)
      CALL HBOOK1(LH(10)+608,
     *'PT    (++)+(--) 3<ET<4.5 GEV$',30,0.,15.,0.)
      CALL HBOOK1(LH(10)+609,
     *'PT    (++)+(--) 4.5<ET<6 GEV$',30,0.,15.,0.)
      CALL HBOOK1(LH(10)+610,
     *'PT    (++)+(--) 6<ET<9 GEV$',30,0.,15.,0.)
 
      CALL HBOOK1(LH(10)+411,
     *'MULT. ++ -- M < 600 MEV$',30,0.,30.,0.)
      CALL HBOOK1(LH(10)+412,
     *'MULT. ++ -- M > 600 MEV$',30,0.,30.,0.)
      CALL HBOOK1(LH(10)+413,
     *'MULT. +- M < 600 MEV$',30,0.,30.,0.)
      CALL HBOOK1(LH(10)+414,
     *'MULT. +- M > 600 MEV$',30,0.,30.,0.)
 
      CALL HBOOK1(LH(10)+415,
     *'PT+ET ++ -- M < 600 MEV$',30,0.,30.,0.)
      CALL HBOOK1(LH(10)+416,
     *'PT+ET ++ -- M > 600 6EV$',30,0.,30.,0.)
      CALL HBOOK1(LH(10)+417,
     *'PT+ET +- M < 600 MEV$',30,0.,30.,0.)
      CALL HBOOK1(LH(10)+418,
     *'PT+ET +- M > 600 MEV$',30,0.,30.,0.)
 
      CALL HBOOK1(LH(10)+77,
     *'THETA FOR TRACKS IN LAB (+-)$',50,0.,0.1,0.)
 
      CALL HBOOK1(LH(10)+78,
     *'P(MU) (+-)$',80,0.,40.,0.)
      CALL HBOOK2(LH(10)+52,
     *'P(MU) MIN VS P(MU) MAX M<600$',20,0.,40.,20,0.,40.,0.)
      CALL HBOOK2(LH(10)+53,
     *'P(MU) MIN VS P(MU) MAX M>600$',20,0.,40.,20,0.,40.,0.)
 
      CALL HBOOK1(LH(10)+42,
     *'P(MUMU) M<600 (++)$',60,0.,60.,0.)
      CALL HBOOK1(LH(10)+43,
     *'P(MUMU) M>600 (++)$',60,0.,60.,0.)
      CALL HBOOK1(LH(10)+44,
     *'P(MUMU) M<600 (--)$',60,0.,60.,0.)
      CALL HBOOK1(LH(10)+45,
     *'P(MUMU) M>600 (--)$',60,0.,60.,0.)
      CALL HBOOK1(LH(10)+46,
     *'P(MUMU) M<600 (+-)$',60,0.,60.,0.)
      CALL HBOOK1(LH(10)+47,
     *'P(MUMU) M>600 (+-)$',60,0.,60.,0.)
 
      CALL HBOOK1(LH(10)+79,
     *'CORRECTED DC MULT IN 10<THETA<70$',30,0.,30.,0.)
      CALL HBOOK1(LH(10)+75,
     *'R FACTOR$',76,0.5,2.02,0.)
 
C     CALL HBOOK1(LH(10)+321,
C    *'SIPAD MULTIPLICITY IN MUMU$',30,0.,30.,0.)
C     CALL HBOOK1(LH(10)+304,
C    *'NUMBER OF TRACKS OF DIFF. TYPE IN MUMU$',8,0.,8.,0.)
C     CALL HBOOK1(LH(10)+305,
C    *'MULT. OF ALL TRACKS (NDC) IN MUMU$',30,0.,30.,0.)
C     CALL HBOOK1(LH(10)+301,
C    *'MULT. DC1 TRACKS IN MUMU$',30,0.,30.,0.)
C     CALL HBOOK1(LH(10)+302,
C    *'MULT. DC2 TRACKS IN MUMU$',30,0.,30.,0.)
C     CALL HBOOK1(LH(10)+303,
C    *'MULT. DC3 TRACKS IN MUMU$',30,0.,30.,0.)
C     CALL HBOOK1(LH(10)+306,
C    *'MULT. OF LONG TRACKS IN MUMU$',30,0.,30.,0.)
 
C     CALL HBOOK1(LH(10)+27,
C    *'(++) Y0$',60,-1.,1.,0.)
C     CALL HBOOK1(LH(10)+28,
C    *'(--) Y0$',60,-1.,1.,0.)
C     CALL HBOOK1(LH(10)+29,
C    *'(+-) Y0$',60,-1.,1.,0.)
 
      CALL HBOOK1(LH(10)+1,
     *'(++) Z OF VERTEX$',50,-500.,1000.,0.)
      CALL HBOOK1(LH(10)+2,
     *'(--) Z OF VERTEX$',50,-500.,1000.,0.)
      CALL HBOOK1(LH(10)+3,
     *'(+-) Z OF VERTEX$',50,-500.,1000.,0.)
 
      CALL HBOOK1(LH(10)+81,
     *'Y IN LAB (++)$',60,1.,7.0,0.)
      CALL HBOOK1(LH(10)+82,
     *'Y IN LAB (--)$',60,1.,7.0,0.)
      CALL HBOOK1(LH(10)+83,
     *'Y IN LAB (+-)$',60,1.,7.0,0.)
      CALL HBOOK1(LH(10)+84,
     *'Y IN LAB (++) M<600$',60,1.,7.0,0.)
      CALL HBOOK1(LH(10)+85,
     *'Y IN LAB (--) M<600$',60,1.,7.0,0.)
      CALL HBOOK1(LH(10)+86,
     *'Y IN LAB (+-) M<600$',60,1.,7.0,0.)
      CALL HBOOK1(LH(10)+87,
     *'Y IN LAB (++) 600<M<1200$',60,1.,7.0,0.)
      CALL HBOOK1(LH(10)+88,
     *'Y IN LAB (--) 600<M<1200$',60,1.,7.0,0.)
      CALL HBOOK1(LH(10)+89,
     *'Y IN LAB (+-) 600<M<1200$',60,1.,7.0,0.)
 
      CALL HBOOK1(LH(10)+91,
     *'H  (++)$',25,0.,1.0,0.)
      CALL HBOOK1(LH(10)+92,
     *'H  (--)$',25,0.,1.0,0.)
      CALL HBOOK1(LH(10)+93,
     *'H  (+-)$',25,0.,1.0,0.)
      CALL HBOOK1(LH(10)+94,
     *'H  (++) M<600$',25,0.,1.0,0.)
      CALL HBOOK1(LH(10)+95,
     *'H  (--) M<600$',25,0.,1.0,0.)
      CALL HBOOK1(LH(10)+96,
     *'H  (+-) M<600$',25,0.,1.0,0.)
      CALL HBOOK1(LH(10)+97,
     *'H  (++) 600<M<1200$',25,0.,1.0,0.)
      CALL HBOOK1(LH(10)+98,
     *'H  (--) 600<M<1200$',25,0.,1.0,0.)
      CALL HBOOK1(LH(10)+99,
     *'H  (+-) 600<M<1200$',25,0.,1.0,0.)
 
      CALL HBOOK1(LH(10)+901,
     *'COMB BACK$',140,0.,3.5,0.)
      CALL HBOOK1(LH(10)+903,
     *'COMB BACK$',300,0.,1.5,0.)
      CALL HBOOK1(LH(10)+902,
     *'COMB BACK  WT$',140,0.,3.5,0.)
 
      CALL HBOOK1(LH(10)+4,
     *'(++) MASS$',140,0.,3.5,0.)
      CALL HBOOK1(LH(10)+5,
     *'(--) MASS$',140,0.,3.5,0.)
      CALL HBOOK1(LH(10)+6,
     *'(+-) MASS$',140,0.,3.5,0.)
 
      CALL HBOOK1(LH(10)+104,
     *'(++) MASS WT$',140,0.,3.5,0.)
      CALL HBOOK1(LH(10)+105,
     *'(--) MASS WT$',140,0.,3.5,0.)
      CALL HBOOK1(LH(10)+106,
     *'(+-) MASS WT$',140,0.,3.5,0.)
 
      CALL HBOOK1(LH(10)+24,
     *'(++) MASS (WRONG DC MATCH)$',140,0.,3.5,0.)
      CALL HBOOK1(LH(10)+25,
     *'(--) MASS (WRONG DC MATCH)$',140,0.,3.5,0.)
      CALL HBOOK1(LH(10)+26,
     *'(+-) MASS (WRONG DC MATCH)$',140,0.,3.5,0.)
      CALL HBOOK1(LH(10)+34,
     *'(++) MASS (WRONG DC MATCH)$',140,0.,3.5,0.)
      CALL HBOOK1(LH(10)+35,
     *'(--) MASS (WRONG DC MATCH)$',140,0.,3.5,0.)
      CALL HBOOK1(LH(10)+36,
     *'(+-) MASS (WRONG DC MATCH)$',140,0.,3.5,0.)
 
      CALL HBOOK1(LH(10)+124,
     *'(++) MASS (WRONG DC MATCH) WT$',140,0.,3.5,0.)
      CALL HBOOK1(LH(10)+125,
     *'(--) MASS (WRONG DC MATCH) WT$',140,0.,3.5,0.)
      CALL HBOOK1(LH(10)+126,
     *'(+-) MASS (WRONG DC MATCH) WT$',140,0.,3.5,0.)
      CALL HBOOK1(LH(10)+134,
     *'(++) MASS (WRONG DC MATCH) WT$',140,0.,3.5,0.)
      CALL HBOOK1(LH(10)+135,
     *'(--) MASS (WRONG DC MATCH) WT$',140,0.,3.5,0.)
      CALL HBOOK1(LH(10)+136,
     *'(+-) MASS (WRONG DC MATCH) WT$',140,0.,3.5,0.)
 
      CALL HBOOK1(LH(10)+40,
     *'(++) MASS$',300,0.,1.5,0.)
      CALL HBOOK1(LH(10)+50,
     *'(--) MASS$',300,0.,1.5,0.)
      CALL HBOOK1(LH(10)+60,
     *'(+-) MASS$',300,0.,1.5,0.)
 
      CALL HBOOK1(LH(10)+71,
     *'(++) PT $',50,0.,1.,0.)
      CALL HBOOK1(LH(10)+72,
     *'(--) PT $',50,0.,1.,0.)
      CALL HBOOK1(LH(10)+73,
     *'(+-) PT $',50,0.,1.,0.)
 
      CALL HBOOK1(LH(10)+7,
     *'(++) PT SQUARE$',50,0.,2.5,0.)
      CALL HBOOK1(LH(10)+8,
     *'(--) PT SQUARE$',50,0.,2.5,0.)
      CALL HBOOK1(LH(10)+9,
     *'(+-) PT SQUARE$',50,0.,2.5,0.)
 
      CALL HBOOK1(LH(10)+10,
     *'(++) XF$',60,0.,0.6,0.)
      CALL HBOOK1(LH(10)+11,
     *'(--) XF$',60,0.,0.6,0.)
      CALL HBOOK1(LH(10)+12,
     *'(+-) XF$',60,0.,0.6,0.)
 
      CALL HBOOK1(LH(10)+13,
     *'(++) ETOT$',60,0.,600.,0.)
      CALL HBOOK1(LH(10)+14,
     *'(--) ETOT$',60,0.,600.,0.)
      CALL HBOOK1(LH(10)+15,
     *'(+-) ETOT$',60,0.,600.,0.)
 
      CALL HBOOK1(LH(10)+41,
     *'(++) MT$',140,0.,3.5,0.)
      CALL HBOOK1(LH(10)+51,
     *'(--) MT$',140,0.,3.5,0.)
      CALL HBOOK1(LH(10)+61,
     *'(+-) MT$',140,0.,3.5,0.)
 
C     CALL HBOOK1(LH(10)+16,
C    *'(++) R DC-MUON$',50,0.,10.,0.)
C     CALL HBOOK1(LH(10)+17,
C    *'(--) R DC-MUON$',50,0.,10.,0.)
C     CALL HBOOK1(LH(10)+18,
C    *'(+-) R DC-MUON$',50,0.,10.,0.)
C     CALL HBOOK1(LH(10)+19,
C    *'(++) P DC-MUON$',60,-15.,15.,0.)
C     CALL HBOOK1(LH(10)+20,
C    *'(--) P DC-MUON$',60,-15.,15.,0.)
C     CALL HBOOK1(LH(10)+21,
C    *'(+-) P DC-MUON$',60,-15.,15.,0.)
 10   CONTINUE
C---------------------------------------------------------------------
C    Muon-DC match
C---------------------------------------------------------------------
      IF(JH(11).EQ.0) GO TO 11
      CALL HBOOK1(LH(11)+90,
     *'Y0 $',45,-0.45,0.45,0.)
      CALL HBOOK1(LH(11)+51,
     *'P(MU)  5<P(MU)<10$',80,0.,40.,0.)
      CALL HBOOK1(LH(11)+52,
     *'P(MU) 10<P(MU)<15$',80,0.,40.,0.)
      CALL HBOOK1(LH(11)+53,
     *'P(MU) 15<P(MU)<20$',80,0.,40.,0.)
      CALL HBOOK1(LH(11)+54,
     *'P(MU) 20<P(MU)<25$',80,0.,40.,0.)
      CALL HBOOK1(LH(11)+55,
     *'P(MU) 25<P(MU)<30$',80,0.,40.,0.)
      CALL HBOOK1(LH(11)+56,
     *'P(MU) 30<P(MU)<35$',80,0.,40.,0.)
      CALL HBOOK1(LH(11)+57,
     *'P(MU) 35<P(MU)<40$',80,0.,40.,0.)
      CALL HBOOK1(LH(11)+31,
     *'PDIFF  5<P(MU)<10 (SAME SIGN)$',80,-40.,40.,0.)
      CALL HBOOK1(LH(11)+32,
     *'PDIFF 10<P(MU)<15 (SAME SIGN)$',80,-40.,40.,0.)
      CALL HBOOK1(LH(11)+33,
     *'PDIFF 15<P(MU)<20 (SAME SIGN)$',80,-40.,40.,0.)
      CALL HBOOK1(LH(11)+34,
     *'PDIFF 20<P(MU)<25 (SAME SIGN)$',80,-40.,40.,0.)
      CALL HBOOK1(LH(11)+35,
     *'PDIFF 25<P(MU)<30 (SAME SIGN)$',80,-40.,40.,0.)
      CALL HBOOK1(LH(11)+36,
     *'PDIFF 30<P(MU)<35 (SAME SIGN)$',80,-40.,40.,0.)
      CALL HBOOK1(LH(11)+37,
     *'PDIFF 35<P(MU)<40 (SAME SIGN)$',80,-40.,40.,0.)
      CALL HBOOK1(LH(11)+41,
     *'PDIFF  5<P(MU)<10 (DIFF SIGN)$',80,-40.,40.,0.)
      CALL HBOOK1(LH(11)+42,
     *'PDIFF 10<P(MU)<15 (DIFF SIGN)$',80,-40.,40.,0.)
      CALL HBOOK1(LH(11)+43,
     *'PDIFF 15<P(MU)<20 (DIFF SIGN)$',80,-40.,40.,0.)
      CALL HBOOK1(LH(11)+44,
     *'PDIFF 20<P(MU)<25 (DIFF SIGN)$',80,-40.,40.,0.)
      CALL HBOOK1(LH(11)+45,
     *'PDIFF 25<P(MU)<30 (DIFF SIGN)$',80,-40.,40.,0.)
      CALL HBOOK1(LH(11)+46,
     *'PDIFF 30<P(MU)<35 (DIFF SIGN)$',80,-40.,40.,0.)
      CALL HBOOK1(LH(11)+47,
     *'PDIFF 35<P(MU)<40 (DIFF SIGN)$',80,-40.,40.,0.)
      CALL HBOOK1(LH(11)+1,
     *'R (SAME SIGN IN DC AND MUON SPEC.)$',50,0.,10.,0.)
      CALL HBOOK1(LH(11)+7,
     *'R  IF PMU>10 (SAME SIGN)$',50,0.,10.,0.)
      CALL HBOOK1(LH(11)+9,
     *'R  IF PMU>20 (SAME SIGN)$',50,0.,10.,0.)
      CALL HBOOK1(LH(11)+2,
     *'R (DIFF. SIGN IN DC AND MUON SPEC.)$',50,0.,10.,0.)
      CALL HBOOK1(LH(11)+8,
     *'R  IF PMU>10 (DIFF SIGN)$',50,0.,10.,0.)
      CALL HBOOK1(LH(11)+10,
     *'R  IF PMU>20 (DIFF SIGN)$',50,0.,10.,0.)
      CALL HBOOK1(LH(11)+3,
     *'PDIFF (SAME SIGN IN DC AND MUON SPEC.)$',60,-15.,15.,0.)
      CALL HBOOK1(LH(11)+13,
     *'PDIFF P(DC)>7 P(MU)>10 (SAME SIGN)$',60,-15.,15.,0.)
      CALL HBOOK1(LH(11)+4,
     *'PDIFF (DIFF. SIGN IN DC AND MUON SPEC.)$',60,-15.,15.,0.)
      CALL HBOOK1(LH(11)+14,
     *'PDIFF P(DC)>7 P(MU)>10 (DIFF SIGN)$',60,-15.,15.,0.)
      CALL HBOOK2(LH(11)+5,
     *'PMU VS PDC (SAME SIGN)$',60,0.,30.,30,0.,30.,0.)
      CALL HBOOK2(LH(11)+6,
     *'PMU VS PDC (DIFF. SIGN)$',60,0.,30.,30,0.,30.,0.)
      CALL HBOOK1(LH(11)+15,
     *'Z(CPA) (SAME SIGN)$',50,-500.,1000.,0.)
      CALL HBOOK1(LH(11)+16,
     *'Z(CPA) P(DC)>10 P(MU)<10 (SAME SIGN)$',50,-500.,1000.,0.)
      CALL HBOOK1(LH(11)+17,
     *'Z(CPA) (DIFF SIGN)$',50,-500.,1000.,0.)
      CALL HBOOK1(LH(11)+18,
     *'Z(CPA) P(DC)>10 P(MU)<10 (DIFF SIGN)$',50,-500.,1000.,0.)
 11   CONTINUE
C---------------------------------------------------------------------
C   Raw muon pair histograms
C---------------------------------------------------------------------
      IF(JH(12).EQ.0) GO TO 12
      CALL HBOOK1(LH(12)+4,
     *'(++) RAW MASS$',140,0.,3.5,0.)
      CALL HBOOK1(LH(12)+5,
     *'(--) RAW MASS$',140,0.,3.5,0.)
      CALL HBOOK1(LH(12)+6,
     *'(+-) RAW MASS$',140,0.,3.5,0.)
      CALL HBOOK1(LH(12)+81,
     *'Y IN LAB (++)$',60,1.,7.0,0.)
      CALL HBOOK1(LH(12)+82,
     *'Y IN LAB (--)$',60,1.,7.0,0.)
      CALL HBOOK1(LH(12)+83,
     *'Y IN LAB (+-)$',60,1.,7.0,0.)
      CALL HBOOK1(LH(12)+84,
     *'Y IN LAB (++) M<600$',60,1.,7.0,0.)
      CALL HBOOK1(LH(12)+85,
     *'Y IN LAB (--) M<600$',60,1.,7.0,0.)
      CALL HBOOK1(LH(12)+86,
     *'Y IN LAB (+-) M<600$',60,1.,7.0,0.)
      CALL HBOOK1(LH(12)+87,
     *'Y IN LAB (++) 600<M<1200$',60,1.,7.0,0.)
      CALL HBOOK1(LH(12)+88,
     *'Y IN LAB (--) 600<M<1200$',60,1.,7.0,0.)
      CALL HBOOK1(LH(12)+89,
     *'Y IN LAB (+-) 600<M<1200$',60,1.,7.0,0.)
C     CALL HBOOK1(LH(12)+7,
C    *'(++) PT SQUARE$',50,0.,2.5,0.)
C     CALL HBOOK1(LH(12)+8,
C    *'(--) PT SQUARE$',50,0.,2.5,0.)
C     CALL HBOOK1(LH(12)+9,
C    *'(+-) PT SQUARE$',50,0.,2.5,0.)
C     CALL HBOOK1(LH(12)+10,
C    *'(++) XF$',60,0.,0.6,0.)
C     CALL HBOOK1(LH(12)+11,
C    *'(--) XF$',60,0.,0.6,0.)
C     CALL HBOOK1(LH(12)+12,
C    *'(+-) XF$',60,0.,0.6,0.)
C     CALL HBOOK1(LH(12)+13,
C    *'(++) ETOT$',60,0.,600.,0.)
C     CALL HBOOK1(LH(12)+14,
C    *'(--) ETOT$',60,0.,600.,0.)
C     CALL HBOOK1(LH(12)+15,
C    *'(+-) ETOT$',60,0.,600.,0.)
C     CALL HBOOK1(LH(12)+61,
C    *'(++) MASS (XF>0.07)$',140,0.,3.5,0.)
C     CALL HBOOK1(LH(12)+62,
C    *'(--) MASS (XF>0.07)$',140,0.,3.5,0.)
C     CALL HBOOK1(LH(12)+63,
C    *'(+-) MASS (XF>0.07)$',140,0.,3.5,0.)
C     CALL HBOOK1(LH(12)+51,
C    *'(++) MT (M<0.4)$',140,0.,3.5,0.)
C     CALL HBOOK1(LH(12)+52,
C    *'(--) MT (M<0.4)$',140,0.,3.5,0.)
C     CALL HBOOK1(LH(12)+53,
C    *'(+-) MT (M<0.4)$',140,0.,3.5,0.)
 12   CONTINUE
C---------------------------------------------------------------------
C   Drift chamber vertex
C---------------------------------------------------------------------
      IF(JH(13).EQ.0) GO TO 13
      CALL HBOOK1(LH(13)+21,
     *'MULT. OF DC1 TRACKS$',30,0.,30.,0.)
      CALL HBOOK1(LH(13)+1,
     *'X0$',50,-0.5,0.5,0.)
      CALL HBOOK1(LH(13)+2,
     *'Y0$',50,-0.5,0.5,0.)
      CALL HBOOK1(LH(13)+3,
     *'Z AT MIN. DIST. TO Z-AXIS (CPA)$',30,-15.,15.,0.)
      CALL HBOOK1(LH(13)+11,
     *'X VERTEX$',50,-0.5,0.5,0.)
      CALL HBOOK1(LH(13)+12,
     *'Y VERTEX$',50,-0.5,0.5,0.)
      CALL HBOOK1(LH(13)+13,
     *'Z VERTEX$',30,-15.,15.,0.)
      CALL HBOOK1(LH(13)+31,
     *'X VERTEX LUCIFER$',50,-0.5,0.5,0.)
      CALL HBOOK1(LH(13)+32,
     *'Y VERTEX LUCIFER$',50,-0.5,0.5,0.)
      CALL HBOOK1(LH(13)+33,
     *'Z VERTEX LUCIFER$',30,-15.,15.,0.)
      CALL HBOOK1(LH(13)+51,
     *'X0 1987$',50,-0.5,0.5,0.)
      CALL HBOOK1(LH(13)+52,
     *'Y0 1987$',50,-0.5,0.5,0.)
      CALL HBOOK1(LH(13)+53,
     *'Z  1987 AT MIN. DIST. TO Z-AXIS (CPA)$',30,-15.,15.,0.)
      CALL HBOOK1(LH(13)+61,
     *'X  1987 VERTEX$',50,-0.5,0.5,0.)
      CALL HBOOK1(LH(13)+62,
     *'Y  1987 VERTEX$',50,-0.5,0.5,0.)
      CALL HBOOK1(LH(13)+63,
     *'Z  1987 VERTEX$',30,-15.,15.,0.)
 13   CONTINUE
C---------------------------------------------------------------------
C   Muon pairs with only negative track matched to DC
C---------------------------------------------------------------------
      IF(JH(14).EQ.0) GO TO 14
      CALL HBOOK1(LH(14)+1,
     *'(++)+(--) MASS (match one random muon)$',140,0.,3.5,0.)
      CALL HBOOK1(LH(14)+2,
     *'(+-) MASS (match atleast neg muon)$',140,0.,3.5,0.)
      CALL HBOOK1(LH(14)+3,
     *'(+-) MASS (match atleast pos muon)$',140,0.,3.5,0.)
      CALL HBOOK1(LH(14)+4,
     *'(++)+(--) MASS (match one muon)$',140,0.,3.5,0.)
      CALL HBOOK1(LH(14)+5,
     *'(+-) MASS (match one muon)$',140,0.,3.5,0.)
      CALL HBOOK1(LH(14)+6,
     *'(++)+(--) MASS (match two muon)$',140,0.,3.5,0.)
      CALL HBOOK1(LH(14)+7,
     *'(+-) MASS (match two muon)$',140,0.,3.5,0.)
      CALL HBOOK1(LH(14)+8,
     *'(++)+(--) MASS (match one wrong muon)$',140,0.,3.5,0.)
      CALL HBOOK1(LH(14)+9,
     *'(+-) MASS (match one wrong muon)$',140,0.,3.5,0.)
 14   CONTINUE
C---------------------------------------------------------------------
C   DC two track separation
C---------------------------------------------------------------------
      IF(JH(15).EQ.0) GO TO 15
      CALL HBOOK1(LH(15)+60,
     *'DELTA R TO GOOD TRACK$',50,0.,1.,0.)
      CALL HBOOK1(LH(15)+1,
     *'DELTA X TO GOOD TRACK$',60,0.,30.,0.)
      CALL HBOOK1(LH(15)+11,
     *'DELTA X TO GOOD TRACK$',60,0.,6.,0.)
      CALL HBOOK1(LH(15)+21,
     *'DELTA X TO GOOD TRACK$',50,0.,1.,0.)
      CALL HBOOK1(LH(15)+2,
     *'DELTA Y TO GOOD TRACK$',60,0.,30.,0.)
      CALL HBOOK1(LH(15)+12,
     *'DELTA Y TO GOOD TRACK$',60,0.,6.,0.)
      CALL HBOOK1(LH(15)+22,
     *'DELTA Y TO GOOD TRACK$',50,0.,1.,0.)
      CALL HBOOK1(LH(15)+31,
     *'DELTA X TO ANY TRACK$',60,0.,30.,0.)
      CALL HBOOK1(LH(15)+41,
     *'DELTA X TO ANY TRACK$',60,0.,6.,0.)
      CALL HBOOK1(LH(15)+51,
     *'DELTA X TO ANY TRACK$',50,0.,1.,0.)
      CALL HBOOK1(LH(15)+32,
     *'DELTA Y TO ANY TRACK$',60,0.,30.,0.)
      CALL HBOOK1(LH(15)+42,
     *'DELTA Y TO ANY TRACK$',60,0.,6.,0.)
      CALL HBOOK1(LH(15)+52,
     *'DELTA Y TO ANY TRACK$',50,0.,1.,0.)
      CALL HMINIM(0,0.)
 15   CONTINUE
C---------------------------------------------------------------------
C    Calculate statistics with true values
C---------------------------------------------------------------------
      CALL HBSTAT(0)
C---------------------------------------------------------------------
C    Integrate histograms
C---------------------------------------------------------------------
      CALL HINTEG(0)
      RETURN
      END
+EOD.
C*********************************************************************
C
C                            M U D C
C
C*********************************************************************
+DECK,MUDC.
      SUBROUTINE MUDC
C---------------------------------------------------------------------
C    This routine looks for a match between a muon and a DC track
C---------------------------------------------------------------------
+CDE,HISTO.
+CDE,MYINFO.
+CDE,TRACK.
+CDE,KINEM.
      INTEGER SMU,SDC
C---------------------------------------------------------------------
C
C                 First loop over all muon tracks
C
C---------------------------------------------------------------------
      DO 100 IMU = 1,NMU
C---------------------------------------------------------------------
C    Initialize total match error
C---------------------------------------------------------------------
      SIGMA            = 100000.
      TRAKMU(1,IMU,23) = 100000.
      TRAKMU(2,IMU,23) = 100000.
      TRAKMU(3,IMU,23) = 100000.
C---------------------------------------------------------------------
C    Look at the quality flag for the track
C---------------------------------------------------------------------
      IF(IRAKMU(1,IMU,9).NE.1) GO TO 100
C---------------------------------------------------------------------
C    Get the sign and momentum of the muon track
C---------------------------------------------------------------------
      PU   = TRAKMU(2,IMU,5)
      IF(PU.EQ.0.) GO TO 100
      SMU  = IRAKMU(2,IMU,10)
C---------------------------------------------------------------------
C    Get the x and y coordinate of the muon track at ULAC front
C---------------------------------------------------------------------
      XMU = TRAKMU(3,IMU,11) * ZULAC + TRAKMU(3,IMU,12)
      YMU = TRAKMU(3,IMU,13) * ZULAC + TRAKMU(3,IMU,14)
C---------------------------------------------------------------------
C    Get the error in the x and y coordinate at ULAC front
C---------------------------------------------------------------------
      ERR  = TRAKMU(2,IMU,20)*(ZULAC-ZTARG)
C---------------------------------------------------------------------
C
C                 Secondly loop over all DC tracks
C
C---------------------------------------------------------------------
      DO 10 IDC = 1,NDC
C---------------------------------------------------------------------
C    Check the reconstruction flag
C---------------------------------------------------------------------
        IF(IRAKDC(5,IDC,16).NE.4.AND.IRAKDC(5,IDC,16).NE.7) GO TO 10
C---------------------------------------------------------------------
C    Get the sign and momentum of the DC track
C---------------------------------------------------------------------
        PC   = TRAKDC(5,IDC,5)
        IF(PC.EQ.0.) GO TO 10
        SDC  = IRAKDC(5,IDC,10)
C---------------------------------------------------------------------
C    Check that the scint. pad fired
C---------------------------------------------------------------------
C       X = TRAKDC(5,IDC,11) * ZSCIN + TRAKDC(5,IDC,12)
C       Y = TRAKDC(5,IDC,13) * ZSCIN + TRAKDC(5,IDC,14)
C       CALL SCITRK(X,Y,NPAD)
C       IF(NPAD.EQ.0) GO TO 10
C---------------------------------------------------------------------
C    Get the x and y coordinate of the DC track at ULAC front
C---------------------------------------------------------------------
        XDC = TRAKDC(5,IDC,11) * ZULAC + TRAKDC(5,IDC,12)
        YDC = TRAKDC(5,IDC,13) * ZULAC + TRAKDC(5,IDC,14)
C---------------------------------------------------------------------
C    Get the distance between the DC and muon track at ULAC front
C---------------------------------------------------------------------
        R    = SQRT( (XDC-XMU)**2 + (YDC-YMU)**2 )
        RERR = R/ERR
C---------------------------------------------------------------------
C    Momentum difference
C---------------------------------------------------------------------
        PDIFF = PC - PU
C---------------------------------------------------------------------
C    Get the error for the momentum difference
C---------------------------------------------------------------------
        ERRPDI = 1.905 - 0.00129 * PU + 0.00606 * PU * PU
        PDIER  = PDIFF/ERRPDI
C---------------------------------------------------------------------
C    Cut on DC vertex for first track
C---------------------------------------------------------------------
C       Y0 = TRAKDC(2,IDC,14)
C       IF(JH(11).NE.0) CALL HFILL(LH(11)+90,Y0,0.,1.)
C       IF(ABS(Y0).GT.0.20) GO TO 10
C---------------------------------------------------------------------
C    Plot histograms
C---------------------------------------------------------------------
        IF(JH(11).EQ.0) GO TO 1
           IF(RERR.LT.2.) THEN
              IF(PU.GT.5..AND.PU.LT.10.)
     *        CALL HFILL(LH(11)+51,PU,0.,1.)
              IF(PU.GT.10..AND.PU.LT.15.)
     *        CALL HFILL(LH(11)+52,PU,0.,1.)
              IF(PU.GT.15..AND.PU.LT.20.)
     *        CALL HFILL(LH(11)+53,PU,0.,1.)
              IF(PU.GT.20..AND.PU.LT.25.)
     *        CALL HFILL(LH(11)+54,PU,0.,1.)
              IF(PU.GT.25..AND.PU.LT.30.)
     *        CALL HFILL(LH(11)+55,PU,0.,1.)
              IF(PU.GT.30..AND.PU.LT.35.)
     *        CALL HFILL(LH(11)+56,PU,0.,1.)
              IF(PU.GT.35..AND.PU.LT.40.)
     *        CALL HFILL(LH(11)+57,PU,0.,1.)
           ENDIF
        IF(SMU.EQ.SDC) THEN
                         CALL HFILL(LH(11)+1,RERR,0.,1.)
           IF(PU.GE.10.) CALL HFILL(LH(11)+7,RERR,0.,1.)
           IF(PU.GE.20.) CALL HFILL(LH(11)+9,RERR,0.,1.)
           IF(RERR.LT.2.) THEN
              CALL HFILL(LH(11)+3,PDIER,0.,1.)
              IF(PC.GT.7..AND.PU.GT.10.)
     *        CALL HFILL(LH(11)+13,PDIER,0.,1.)
              CALL HFILL(LH(11)+5,PC,PU,1.)
              CALL HFILL(LH(11)+15,TRAKMU(1,IMU,8),0.,1.)
              IF(PC.GT.10..AND.PU.LT.10.)
     *        CALL HFILL(LH(11)+16,TRAKMU(1,IMU,8),0.,1.)
              IF(PU.GT.5..AND.PU.LT.10.)
     *        CALL HFILL(LH(11)+31,PDIFF,0.,1.)
              IF(PU.GT.10..AND.PU.LT.15.)
     *        CALL HFILL(LH(11)+32,PDIFF,0.,1.)
              IF(PU.GT.15..AND.PU.LT.20.)
     *        CALL HFILL(LH(11)+33,PDIFF,0.,1.)
              IF(PU.GT.20..AND.PU.LT.25.)
     *        CALL HFILL(LH(11)+34,PDIFF,0.,1.)
              IF(PU.GT.25..AND.PU.LT.30.)
     *        CALL HFILL(LH(11)+35,PDIFF,0.,1.)
              IF(PU.GT.30..AND.PU.LT.35.)
     *        CALL HFILL(LH(11)+36,PDIFF,0.,1.)
              IF(PU.GT.35..AND.PU.LT.40.)
     *        CALL HFILL(LH(11)+37,PDIFF,0.,1.)
           ENDIF
        ELSE
                         CALL HFILL(LH(11)+2,RERR,0.,1.)
           IF(PU.GE.10.) CALL HFILL(LH(11)+8,RERR,0.,1.)
           IF(PU.GE.20.) CALL HFILL(LH(11)+10,RERR,0.,1.)
           IF(PU.GE.30.) CALL HFILL(LH(11)+12,RERR,0.,1.)
           IF(RERR.LT.2.) THEN
              CALL HFILL(LH(11)+4,PDIER,0.,1.)
              IF(PC.GT.7..AND.PU.GT.10.)
     *        CALL HFILL(LH(11)+14,PDIER,0.,1.)
              CALL HFILL(LH(11)+6,PC,PU,1.)
              CALL HFILL(LH(11)+17,TRAKMU(1,IMU,8),0.,1.)
              IF(PC.GT.10..AND.PU.LT.10.)
     *        CALL HFILL(LH(11)+18,TRAKMU(1,IMU,8),0.,1.)
              IF(PU.GT.5..AND.PU.LT.10.)
     *        CALL HFILL(LH(11)+41,PDIFF,0.,1.)
              IF(PU.GT.10..AND.PU.LT.15.)
     *        CALL HFILL(LH(11)+42,PDIFF,0.,1.)
              IF(PU.GT.15..AND.PU.LT.20.)
     *        CALL HFILL(LH(11)+43,PDIFF,0.,1.)
              IF(PU.GT.20..AND.PU.LT.25.)
     *        CALL HFILL(LH(11)+44,PDIFF,0.,1.)
              IF(PU.GT.25..AND.PU.LT.30.)
     *        CALL HFILL(LH(11)+45,PDIFF,0.,1.)
              IF(PU.GT.30..AND.PU.LT.35.)
     *        CALL HFILL(LH(11)+46,PDIFF,0.,1.)
              IF(PU.GT.35..AND.PU.LT.40.)
     *        CALL HFILL(LH(11)+47,PDIFF,0.,1.)
           ENDIF
        ENDIF
 1      CONTINUE
C---------------------------------------------------------------------
C    Select best match
C---------------------------------------------------------------------
        SIGTOT = SQRT( RERR**2 + PDIER**2)
CVIH    IF(SMU.NE.SDC)      GO TO 10
        IF(SIGTOT.GT.SIGMA) GO TO 10
        SIGMA  = SIGTOT
        TRAKMU(1,IMU,23) = SIGTOT
        TRAKMU(2,IMU,23) = RERR
        TRAKMU(3,IMU,23) = PDIER
        DO 23 J = 1,4
 23     IRAKMU(J,IMU,24) = IDC
C---------------------------------------------------------------------
C
C                 End of second loop
C
C---------------------------------------------------------------------
 10     CONTINUE
C---------------------------------------------------------------------
C
C                 End of first loop
C
C---------------------------------------------------------------------
 100  CONTINUE
      RETURN
      END
+EOD.
C*********************************************************************
C
C                            M U M U
C
C*********************************************************************
+DECK,MUMU.
      SUBROUTINE MUMU(MUPAIR)
C---------------------------------------------------------------------
C    This routine looks for muon pairs with or without DC
C---------------------------------------------------------------------
+CDE,SABANKC,MUCBLNK.
+CDE,MUSTRC,HISTO.
+CDE,MUID,MUSTAT.
+CDE,MUCOUN,MYINFO.
+CDE,TRACK.
+CDE,KINEM.
+CDE,COMB.
      INTEGER S1,S2,SD1,SD2
      LOGICAL   MUPAIR
      DIMENSION P1(4),P2(4),PMUMU(4),PCMS(4),IOLD(20)
      MUPAIR = .TRUE.
      CALL VZERO(IOLD,20)
C---------------------------------------------------------------------
C
C                 First loop over all tracks
C
C---------------------------------------------------------------------
      DO 100 I1 = 1,NMU
C---------------------------------------------------------------------
C    Check the quality flag
C---------------------------------------------------------------------
        IF(IRAKMU(1,I1,9).NE.1)                       GO TO 100
C---------------------------------------------------------------------
C    Cut on R and CPA for first track
C---------------------------------------------------------------------
        IF(XCUT(9).AND.TRAKMU(1,I1,7).GT.15.)         GO TO 100
        IF(XCUT(9).AND.TRAKMU(1,I1,8).GT.1000.)       GO TO 100
        IF(XCUT(9).AND.TRAKMU(1,I1,8).LT.-800.)       GO TO 100
C---------------------------------------------------------------------
C    Do muon - DC match for first track
C---------------------------------------------------------------------
        IF(XCUT(10).AND.IRAKMU(1,I1,24).EQ.0)         GO TO 100
        IF(XCUT(10).AND.TRAKMU(2,I1,23).GT.RCUT)      GO TO 100
        IF(XCUT(10).AND.ABS(TRAKMU(3,I1,23)).GT.PCUT) GO TO 100
C---------------------------------------------------------------------
C    Cut on DC vertex for first track
C---------------------------------------------------------------------
        Y0 = TRAKDC(2,IRAKMU(1,I1,24),14)
        IF(XCUT(10).AND.ABS(Y0).GT.0.45)              GO TO 100
C       VTXX      = TRAKDC(2,IRAKMU(1,I1,24),12)
C       VTXY      = TRAKDC(2,IRAKMU(1,I1,24),14)
C       VTXZ      = TRAKDC(2,IRAKMU(1,I1,24),8)
C       IF(ABS(VTXX).GT.2.0)          GO TO 100
C       IF(ABS(VTXY).GT.1.2)          GO TO 100
C       IF(VTXZ.LT.-7..OR.VTXZ.GT.8.) GO TO 100
C---------------------------------------------------------------------
C    Cut on theta for first track
C---------------------------------------------------------------------
        IF(XCUT(10).AND.TRAKDC(1,IRAKMU(1,I1,24),17).LT.0.010)
     *  GO TO 100
C---------------------------------------------------------------------
C
C                 Second loop over all tracks
C
C---------------------------------------------------------------------
        DO 10 I2 = 1,NMU
           IF(I1.GE.I2)                                  GO TO 10
C---------------------------------------------------------------------
C    Check the quality flag
C---------------------------------------------------------------------
           IF(IRAKMU(1,I2,9).NE.1)                       GO TO 10
C---------------------------------------------------------------------
C    Cut on R and CPA for second track
C---------------------------------------------------------------------
           IF(XCUT(9).AND.TRAKMU(1,I2,7).GT.15.)         GO TO 10
           IF(XCUT(9).AND.TRAKMU(1,I2,8).GT.1000.)       GO TO 10
           IF(XCUT(9).AND.TRAKMU(1,I2,8).LT.-800.)       GO TO 10
C---------------------------------------------------------------------
C    Do muon - DC match for second track
C---------------------------------------------------------------------
           IF(XCUT(10).AND.(IRAKMU(1,I1,24).EQ.IRAKMU(1,I2,24)))
     *                                                   GO TO 10
           IF(XCUT(10).AND.IRAKMU(1,I2,24).EQ.0)         GO TO 10
           IF(XCUT(10).AND.TRAKMU(2,I2,23).GT.RCUT)      GO TO 10
           IF(XCUT(10).AND.ABS(TRAKMU(3,I2,23)).GT.PCUT) GO TO 10
C---------------------------------------------------------------------
C    Cut on DC vertex for second track
C---------------------------------------------------------------------
           Y0 = TRAKDC(2,IRAKMU(1,I2,24),14)
           IF(XCUT(10).AND.ABS(Y0).GT.0.45)      GO TO 10
C---------------------------------------------------------------------
C    Cut on theta for second track
C---------------------------------------------------------------------
           IF(XCUT(10).AND.TRAKDC(1,IRAKMU(1,I2,24),17).LT.0.010)
     *     GO TO 10
C---------------------------------------------------------------------
C    Vertex
C---------------------------------------------------------------------
           X1 = TRAKMU(1,I1,12)
           Y1 = TRAKMU(1,I1,14)
           A1 = TRAKMU(1,I1,11)
           B1 = TRAKMU(1,I1,13)
           X2 = TRAKMU(1,I2,12)
           Y2 = TRAKMU(1,I2,14)
           A2 = TRAKMU(1,I2,11)
           B2 = TRAKMU(1,I2,13)
           CALL DISLL
     *     (X1,Y1,0.,A1,B1,1.,X2,Y2,0.,A2,B2,1.,XC,YC,ZC,RC,Z)
           ZVERT = ZC
           RVERT = SQRT(XC**2+YC**2)
C---------------------------------------------------------------------
C    Get the sign of the tracks
C---------------------------------------------------------------------
           S1  = IRAKMU(1,I1,10)
           S2  = IRAKMU(1,I2,10)
           SD1 = IRAKDC(1,IRAKMU(1,I1,24),10)
           SD2 = IRAKDC(1,IRAKMU(1,I2,24),10)
C---------------------------------------------------------------------
C    Histograms of vertex
C---------------------------------------------------------------------
           IF(JH(10).NE.0) THEN
              IF(S1.EQ.1.AND.S2.EQ.1)   CALL HFILL(LH(10)+1,ZVERT,0.,1.)
              IF(S1.EQ.-1.AND.S2.EQ.-1) CALL HFILL(LH(10)+2,ZVERT,0.,1.)
              IF(S1.EQ.-1.AND.S2.EQ.1)  CALL HFILL(LH(10)+3,ZVERT,0.,1.)
              IF(S1.EQ.1.AND.S2.EQ.-1)  CALL HFILL(LH(10)+3,ZVERT,0.,1.)
           ENDIF
C---------------------------------------------------------------------
C    Vertex cut
C---------------------------------------------------------------------
           IF(XCUT(9).AND.ZVERT.GT.360.) GO TO 10
C---------------------------------------------------------------------
C    Multiplicity cut
C---------------------------------------------------------------------
           IF(XCUT(10)) THEN
C          MULT = MULTDC(12)
           MULT = MULTSC
C          MULT = MULT - 2
           IF(ETCUT.EQ.6.AND..NOT.(MULT.GE.2.AND.MULT.LE.3))  GO TO 10
           IF(ETCUT.EQ.7.AND..NOT.(MULT.GE.4.AND.MULT.LE.5))  GO TO 10
           IF(ETCUT.EQ.8.AND..NOT.(MULT.GE.6.AND.MULT.LE.7))  GO TO 10
           IF(ETCUT.EQ.9.AND..NOT.(MULT.GE.8.AND.MULT.LE.9))  GO TO 10
           IF(ETCUT.EQ.10.AND..NOT.(MULT.GE.10.AND.MULT.LE.13))GOTO 10
           ENDIF
C---------------------------------------------------------------------
C    Set mupair flag
C---------------------------------------------------------------------
           IF(XCUT(10).AND.SD1.EQ.S1.AND.SD2.EQ.S2) MUPAIR = .FALSE.
           IF(XCUT(9)) MUPAIR = .FALSE.
C---------------------------------------------------------------------
C    Calculate mass, PT, XF
C---------------------------------------------------------------------
           IF(XCUT(10)) THEN
              PM1   = TRAKMU(2,I1,5)
              AD1   = TRAKDC(1,IRAKMU(1,I1,24),11)
              BD1   = TRAKDC(1,IRAKMU(1,I1,24),13)
              P1(3) = PM1 / SQRT(AD1**2+BD1**2+1)
              P1(1) = AD1 * P1(3)
              P1(2) = BD1 * P1(3)
              PM2   = TRAKMU(2,I2,5)
              AD2   = TRAKDC(1,IRAKMU(1,I2,24),11)
              BD2   = TRAKDC(1,IRAKMU(1,I2,24),13)
              P2(3) = PM2 / SQRT(AD2**2+BD2**2+1)
              P2(1) = AD2 * P2(3)
              P2(2) = BD2 * P2(3)
           ELSE
              P1(1) = TRAKMU(2,I1,1)
              P1(2) = TRAKMU(2,I1,2)
              P1(3) = TRAKMU(2,I1,3)
              P2(1) = TRAKMU(2,I2,1)
              P2(2) = TRAKMU(2,I2,2)
              P2(3) = TRAKMU(2,I2,3)
           ENDIF
           XM    = MUM
           CALL MASS(2,XM,P1,P2,PMUMU,PCMS,P,PT,XF,XXM,XMT,YLAB,YCM,H)
           PTSQU = PT*PT
           ETOTAL= ETOT + PMUMU(4)
C          ET  = ETSUM - TRAKDC(5,I1,4) - TRAKDC(5,I2,4)
           ET  = ETULAC
C---------------------------------------------------------------------
C    XF cut
C---------------------------------------------------------------------
C          IF(XF.LT.0.03)                   GO TO 10
C---------------------------------------------------------------------
C    Get the theta of the tracks at the target
C---------------------------------------------------------------------
           IF(XCUT(10)) THEN
              TH1   = TRAKDC(1,IRAKMU(1,I1,24),17)
              TH2   = TRAKDC(1,IRAKMU(1,I2,24),17)
           ELSE
              TH1 = TRAKMU(2,I1,17)
              TH2 = TRAKMU(2,I2,17)
           ENDIF
C---------------------------------------------------------------------
C    Get the momentum of the tracks at the target
C---------------------------------------------------------------------
           PM1   = TRAKMU(2,I1,5)
           PM2   = TRAKMU(2,I2,5)
C---------------------------------------------------------------------
C    Calculate the weight due to inefficiency and acceptance
C---------------------------------------------------------------------
           WT = 1.
           WT = WT * WTHOD(I1) * WTHOD(I2)
           WT = WT * WTDC(I1)  * WTDC(I2)
           WT = WT * WTMASS(XXM,2,IERROR)
CVIH       WR = RFACT(MULTDC(13))
C          WRITE(6,*) '  WT===>',WT
C---------------------------------------------------------------------
C    Plot histograms of track position at hodoscopes
C---------------------------------------------------------------------
C          IF(SD1.EQ.S1.AND.SD2.EQ.S2) CALL HOPLOT(I1,I2,S1,S2)
C---------------------------------------------------------------------
C    Plot histograms of track position at DC2
C---------------------------------------------------------------------
C          IF(SD1.EQ.S1.AND.SD2.EQ.S2) CALL DCPLOT(I1,I2,S1,S2)
C---------------------------------------------------------------------
C    Save tracks for combinatorial background calculation
C---------------------------------------------------------------------
           IF(XCUT(9).OR.XCUT(10).AND.SD1.EQ.S1.AND.SD2.EQ.S2) THEN
           IF(IOLD(I1).EQ.1.OR.IOLD(I2).EQ.1) GO TO 444
           IF(IBP.GE.1500.OR.IBN.GE.1500)     GO TO 444
           IF(S1.NE.S2)                       GO TO 444
           IOLD(I1) = 1
           IOLD(I2) = 1
           IF(S1.EQ.1.AND.S2.EQ.1) THEN
              IBP = IBP + 1
              CBP(1,IBP) = P1(1)
              CBP(2,IBP) = P1(2)
              CBP(3,IBP) = P1(3)
              CBP(4,IBP) = WTHOD(I1) * WTDC(I1)
              IBP = IBP + 1
              CBP(1,IBP) = P2(1)
              CBP(2,IBP) = P2(2)
              CBP(3,IBP) = P2(3)
              CBP(4,IBP) = WTHOD(I2) * WTDC(I2)
           ENDIF
           IF(S1.EQ.-1.AND.S2.EQ.-1) THEN
              IBN = IBN + 1
              CBN(1,IBN) = P1(1)
              CBN(2,IBN) = P1(2)
              CBN(3,IBN) = P1(3)
              CBN(4,IBN) = WTHOD(I1) * WTDC(I1)
              IBN = IBN + 1
              CBN(1,IBN) = P2(1)
              CBN(2,IBN) = P2(2)
              CBN(3,IBN) = P2(3)
              CBN(4,IBN) = WTHOD(I2) * WTDC(I2)
           ENDIF
 444       CONTINUE
           ENDIF
C---------------------------------------------------------------------
C    Plot histograms of mass, PT**2, XF and Etot
C---------------------------------------------------------------------
           IF(JH(10).EQ.0) GO TO 5
 
           IF(XCUT(9)                               .OR.
     *       (XCUT(10).AND.SD1.EQ.S1.AND.SD2.EQ.S2) .OR.
     *       (.NOT.XCUT(9).AND..NOT.XCUT(10)))      THEN
 
              IF(S1.EQ.1.AND.S2.EQ.1) THEN
CLSJ
                 WRITE(6,9)XXM,PT,XF,-1
  9              FORMAT(1X,'M,PT,XF=',3F15.9,I3)
CLSJ
                 CALL HFILL(LH(10)+4,XXM,0.,1.)
                 CALL HFILL(LH(10)+104,XXM,0.,WT)
                 CALL HFILL(LH(10)+40,XXM,0.,1.)
                 CALL HFILL(LH(10)+71,PT,0.,1.)
                 CALL HFILL(LH(10)+7,PTSQU,0.,1.)
                 CALL HFILL(LH(10)+10,XF,0.,1.)
                 CALL HFILL(LH(10)+13,ETOTAL,0.,1.)
                 CALL HFILL(LH(10)+41,XMT,0.,1.)
                 CALL HFILL(LH(10)+81,YLAB,0.,1.)
                 CALL HFILL(LH(10)+91,H,0.,1.)
                 CALL HFILL(LH(10)+75,WR,0.,1.)
                 CALL HFILL(LH(10)+79,FLOAT(MULTDC(13)),0.,1.)
 
                 IF(XXM.LE.0.6) THEN
                    CALL HFILL(LH(10)+84,YLAB,0.,1.)
                    CALL HFILL(LH(10)+94,H,0.,1.)
                    CALL HFILL(LH(10)+42,P,0.,1.)
                    CALL HFILL(LH(10)+411,FLOAT(MULT),0.,1.)
                    CALL HFILL(LH(10)+415,ET,0.,1.)
                 ENDIF
 
                 IF(XXM.GT.0.6.AND.XXM.LE.1.2) THEN
                    CALL HFILL(LH(10)+87,YLAB,0.,1.)
                    CALL HFILL(LH(10)+97,H,0.,1.)
                    CALL HFILL(LH(10)+43,P,0.,1.)
                    CALL HFILL(LH(10)+412,FLOAT(MULT),0.,1.)
                    CALL HFILL(LH(10)+416,ET,0.,1.)
                 ENDIF
 
C             CALL HFILL(LH(10)+16,TRAKMU(2,I1,23),0.,1.)
C             CALL HFILL(LH(10)+16,TRAKMU(2,I2,23),0.,1.)
C             CALL HFILL(LH(10)+19,TRAKMU(3,I1,23),0.,1.)
C             CALL HFILL(LH(10)+19,TRAKMU(3,I2,23),0.,1.)
C             CALL HFILL(LH(10)+27,TRAKDC(2,IRAKMU(1,I1,24),14),0.,1.)
C             CALL HFILL(LH(10)+27,TRAKDC(2,IRAKMU(1,I2,24),14),0.,1.)
 
              IF(ETULAC.GT.0..AND.ETULAC.LE.1.5)
     *        CALL HFILL(LH(10)+506,FLOAT(MULT),0.,1.)
              IF(ETULAC.GT.1.5.AND.ETULAC.LE.3.)
     *        CALL HFILL(LH(10)+507,FLOAT(MULT),0.,1.)
              IF(ETULAC.GT.3..AND.ETULAC.LE.4.5)
     *        CALL HFILL(LH(10)+508,FLOAT(MULT),0.,1.)
              IF(ETULAC.GT.4.5.AND.ETULAC.LE.6.)
     *        CALL HFILL(LH(10)+509,FLOAT(MULT),0.,1.)
              IF(ETULAC.GT.6..AND.ETULAC.LE.9.)
     *        CALL HFILL(LH(10)+510,FLOAT(MULT),0.,1.)
 
              IF(ETULAC.GT.0..AND.ETULAC.LE.1.5)
     *        CALL HFILL(LH(10)+606,PTSUM,0.,1.)
              IF(ETULAC.GT.1.5.AND.ETULAC.LE.3.)
     *        CALL HFILL(LH(10)+607,PTSUM,0.,1.)
              IF(ETULAC.GT.3..AND.ETULAC.LE.4.5)
     *        CALL HFILL(LH(10)+608,PTSUM,0.,1.)
              IF(ETULAC.GT.4.5.AND.ETULAC.LE.6.)
     *        CALL HFILL(LH(10)+609,PTSUM,0.,1.)
              IF(ETULAC.GT.6..AND.ETULAC.LE.9.)
     *        CALL HFILL(LH(10)+610,PTSUM,0.,1.)
 
              ENDIF
 
              IF(S1.EQ.-1.AND.S2.EQ.-1) THEN
 
CLSJ
                 WRITE(6,9)XXM,PT,XF,-1
CLSJ
                 CALL HFILL(LH(10)+5,XXM,0.,1.)
                 CALL HFILL(LH(10)+105,XXM,0.,WT)
                 CALL HFILL(LH(10)+50,XXM,0.,1.)
                 CALL HFILL(LH(10)+72,PT,0.,1.)
                 CALL HFILL(LH(10)+8,PTSQU,0.,1.)
                 CALL HFILL(LH(10)+11,XF,0.,1.)
                 CALL HFILL(LH(10)+14,ETOTAL,0.,1.)
                 CALL HFILL(LH(10)+51,XMT,0.,1.)
                 CALL HFILL(LH(10)+82,YLAB,0.,1.)
                 CALL HFILL(LH(10)+92,H,0.,1.)
                 CALL HFILL(LH(10)+75,WR,0.,1.)
                 CALL HFILL(LH(10)+79,FLOAT(MULTDC(13)),0.,1.)
 
                 IF(XXM.LE.0.6) THEN
                    CALL HFILL(LH(10)+85,YLAB,0.,1.)
                    CALL HFILL(LH(10)+95,H,0.,1.)
                    CALL HFILL(LH(10)+44,P,0.,1.)
                    CALL HFILL(LH(10)+411,FLOAT(MULT),0.,1.)
                    CALL HFILL(LH(10)+415,ET,0.,1.)
                 ENDIF
 
                 IF(XXM.GT.0.6.AND.XXM.LE.1.2) THEN
                    CALL HFILL(LH(10)+88,YLAB,0.,1.)
                    CALL HFILL(LH(10)+98,H,0.,1.)
                    CALL HFILL(LH(10)+45,P,0.,1.)
                    CALL HFILL(LH(10)+412,FLOAT(MULT),0.,1.)
                    CALL HFILL(LH(10)+416,ET,0.,1.)
                 ENDIF
 
C             CALL HFILL(LH(10)+17,TRAKMU(2,I1,23),0.,1.)
C             CALL HFILL(LH(10)+17,TRAKMU(2,I2,23),0.,1.)
C             CALL HFILL(LH(10)+20,TRAKMU(3,I1,23),0.,1.)
C             CALL HFILL(LH(10)+20,TRAKMU(3,I2,23),0.,1.)
C             CALL HFILL(LH(10)+28,TRAKDC(2,IRAKMU(1,I1,24),14),0.,1.)
C             CALL HFILL(LH(10)+28,TRAKDC(2,IRAKMU(1,I2,24),14),0.,1.)
 
              IF(ETULAC.GT.0..AND.ETULAC.LE.1.5)
     *        CALL HFILL(LH(10)+506,FLOAT(MULT),0.,1.)
              IF(ETULAC.GT.1.5.AND.ETULAC.LE.3.)
     *        CALL HFILL(LH(10)+507,FLOAT(MULT),0.,1.)
              IF(ETULAC.GT.3..AND.ETULAC.LE.4.5)
     *        CALL HFILL(LH(10)+508,FLOAT(MULT),0.,1.)
              IF(ETULAC.GT.4.5.AND.ETULAC.LE.6.)
     *        CALL HFILL(LH(10)+509,FLOAT(MULT),0.,1.)
              IF(ETULAC.GT.6..AND.ETULAC.LE.9.)
     *        CALL HFILL(LH(10)+510,FLOAT(MULT),0.,1.)
 
              IF(ETULAC.GT.0..AND.ETULAC.LE.1.5)
     *        CALL HFILL(LH(10)+606,PTSUM,0.,1.)
              IF(ETULAC.GT.1.5.AND.ETULAC.LE.3.)
     *        CALL HFILL(LH(10)+607,PTSUM,0.,1.)
              IF(ETULAC.GT.3..AND.ETULAC.LE.4.5)
     *        CALL HFILL(LH(10)+608,PTSUM,0.,1.)
              IF(ETULAC.GT.4.5.AND.ETULAC.LE.6.)
     *        CALL HFILL(LH(10)+609,PTSUM,0.,1.)
              IF(ETULAC.GT.6..AND.ETULAC.LE.9.)
     *        CALL HFILL(LH(10)+610,PTSUM,0.,1.)
 
              ENDIF
 
              IF(S1.EQ.-1.AND.S2.EQ.1) THEN
 
C    =======================================
C                WRITE(6,*) XXM
C    =======================================
CLSJ
                 WRITE(6,9)XXM,PT,XF,1
CLSJ
                 CALL HFILL(LH(10)+6,XXM,0.,1.)
                 CALL HFILL(LH(10)+106,XXM,0.,WT)
                 CALL HFILL(LH(10)+60,XXM,0.,1.)
                 CALL HFILL(LH(10)+73,PT,0.,1.)
                 CALL HFILL(LH(10)+9,PTSQU,0.,1.)
                 CALL HFILL(LH(10)+12,XF,0.,1.)
                 CALL HFILL(LH(10)+15,ETOTAL,0.,1.)
                 CALL HFILL(LH(10)+61,XMT,0.,1.)
                 CALL HFILL(LH(10)+83,YLAB,0.,1.)
                 CALL HFILL(LH(10)+93,H,0.,1.)
 
                 IF(XXM.LE.0.6) THEN
                    CALL HFILL(LH(10)+86,YLAB,0.,1.)
                    CALL HFILL(LH(10)+96,H,0.,1.)
                    CALL HFILL(LH(10)+46,P,0.,1.)
                    CALL HFILL(LH(10)+413,FLOAT(MULT),0.,1.)
                    CALL HFILL(LH(10)+417,ET,0.,1.)
                    IF(PM1.LT.PM2) THEN
                       XXX=PM2
                       YYY=PM1
                    ELSE
                       XXX=PM1
                       YYY=PM2
                    ENDIF
                    CALL HFILL(LH(10)+52,XXX,YYY,1.)
                 ENDIF
 
                 IF(XXM.GT.0.6.AND.XXM.LE.1.2) THEN
                    CALL HFILL(LH(10)+89,YLAB,0.,1.)
                    CALL HFILL(LH(10)+99,H,0.,1.)
                    CALL HFILL(LH(10)+47,P,0.,1.)
                    CALL HFILL(LH(10)+414,FLOAT(MULT),0.,1.)
                    CALL HFILL(LH(10)+418,ET,0.,1.)
                    IF(PM1.LT.PM2) THEN
                       XXX=PM2
                       YYY=PM1
                    ELSE
                       XXX=PM1
                       YYY=PM2
                    ENDIF
                    CALL HFILL(LH(10)+53,XXX,YYY,1.)
                 ENDIF
 
                 CALL HFILL(LH(10)+77,TH1,0.,1.)
                 CALL HFILL(LH(10)+77,TH2,0.,1.)
                 CALL HFILL(LH(10)+78,PM1,0.,1.)
                 CALL HFILL(LH(10)+78,PM2,0.,1.)
 
C             CALL HFILL(LH(10)+18,TRAKMU(2,I1,23),0.,1.)
C             CALL HFILL(LH(10)+18,TRAKMU(2,I2,23),0.,1.)
C             CALL HFILL(LH(10)+21,TRAKMU(3,I1,23),0.,1.)
C             CALL HFILL(LH(10)+21,TRAKMU(3,I2,23),0.,1.)
C             CALL HFILL(LH(10)+29,TRAKDC(2,IRAKMU(1,I1,24),14),0.,1.)
C             CALL HFILL(LH(10)+29,TRAKDC(2,IRAKMU(1,I2,24),14),0.,1.)
 
              ENDIF
 
              IF(S1.EQ.1.AND.S2.EQ.-1) THEN
 
C    =======================================
C                WRITE(6,*) XXM
C    =======================================
CLSJ
                 WRITE(6,9)XXM,PT,XF,1
CLSJ
                 CALL HFILL(LH(10)+6,XXM,0.,1.)
                 CALL HFILL(LH(10)+106,XXM,0.,WT)
                 CALL HFILL(LH(10)+60,XXM,0.,1.)
                 CALL HFILL(LH(10)+73,PT,0.,1.)
                 CALL HFILL(LH(10)+9,PTSQU,0.,1.)
                 CALL HFILL(LH(10)+12,XF,0.,1.)
                 CALL HFILL(LH(10)+15,ETOTAL,0.,1.)
                 CALL HFILL(LH(10)+61,XMT,0.,1.)
                 CALL HFILL(LH(10)+83,YLAB,0.,1.)
 
                 IF(XXM.LE.0.6) THEN
                    CALL HFILL(LH(10)+86,YLAB,0.,1.)
                    CALL HFILL(LH(10)+96,H,0.,1.)
                    CALL HFILL(LH(10)+46,P,0.,1.)
                    CALL HFILL(LH(10)+413,FLOAT(MULT),0.,1.)
                    CALL HFILL(LH(10)+417,ET,0.,1.)
                    IF(PM1.LT.PM2) THEN
                       XXX=PM2
                       YYY=PM1
                    ELSE
                       XXX=PM1
                       YYY=PM2
                    ENDIF
                    CALL HFILL(LH(10)+52,XXX,YYY,1.)
                 ENDIF
 
                 IF(XXM.GT.0.6.AND.XXM.LE.1.2) THEN
                    CALL HFILL(LH(10)+89,YLAB,0.,1.)
                    CALL HFILL(LH(10)+99,H,0.,1.)
                    CALL HFILL(LH(10)+47,P,0.,1.)
                    CALL HFILL(LH(10)+414,FLOAT(MULT),0.,1.)
                    CALL HFILL(LH(10)+418,ET,0.,1.)
                    IF(PM1.LT.PM2) THEN
                       XXX=PM2
                       YYY=PM1
                    ELSE
                       XXX=PM1
                       YYY=PM2
                    ENDIF
                    CALL HFILL(LH(10)+53,XXX,YYY,1.)
                 ENDIF
 
                 CALL HFILL(LH(10)+77,TH1,0.,1.)
                 CALL HFILL(LH(10)+77,TH2,0.,1.)
                 CALL HFILL(LH(10)+78,PM1,0.,1.)
                 CALL HFILL(LH(10)+78,PM2,0.,1.)
C             CALL HFILL(LH(10)+18,TRAKMU(2,I1,23),0.,1.)
C             CALL HFILL(LH(10)+18,TRAKMU(2,I2,23),0.,1.)
C             CALL HFILL(LH(10)+21,TRAKMU(3,I1,23),0.,1.)
C             CALL HFILL(LH(10)+21,TRAKMU(3,I2,23),0.,1.)
C             CALL HFILL(LH(10)+29,TRAKDC(2,IRAKMU(1,I1,24),14),0.,1.)
C             CALL HFILL(LH(10)+29,TRAKDC(2,IRAKMU(1,I2,24),14),0.,1.)
 
              ENDIF
 
           ENDIF
 
           IF(XCUT(10).AND.SD1.NE.S1.AND.SD2.NE.S2) THEN
 
              IF(S1.EQ.1.AND.S2.EQ.1) THEN
                 CALL HFILL(LH(10)+24,XXM,0.,1.)
                 CALL HFILL(LH(10)+124,XXM,0.,WT)
              ENDIF
 
              IF(S1.EQ.-1.AND.S2.EQ.-1) THEN
                 CALL HFILL(LH(10)+25,XXM,0.,1.)
                 CALL HFILL(LH(10)+125,XXM,0.,WT)
              ENDIF
 
              IF(S1.EQ.-1.AND.S2.EQ.1) THEN
                 CALL HFILL(LH(10)+26,XXM,0.,1.)
                 CALL HFILL(LH(10)+126,XXM,0.,WT)
              ENDIF
 
              IF(S1.EQ.1.AND.S2.EQ.-1) THEN
                 CALL HFILL(LH(10)+26,XXM,0.,1.)
                 CALL HFILL(LH(10)+126,XXM,0.,WT)
              ENDIF
 
           ENDIF
 
           IF(XCUT(10).AND.(SD1.EQ.S1.AND.SD2.NE.S2.OR.
     *                      SD1.NE.S1.AND.SD2.EQ.S2))    THEN
 
              IF(S1.EQ.1.AND.S2.EQ.1) THEN
                 CALL HFILL(LH(10)+34,XXM,0.,1.)
                 CALL HFILL(LH(10)+134,XXM,0.,WT)
              ENDIF
 
              IF(S1.EQ.-1.AND.S2.EQ.-1) THEN
                 CALL HFILL(LH(10)+35,XXM,0.,1.)
                 CALL HFILL(LH(10)+135,XXM,0.,WT)
              ENDIF
 
              IF(S1.EQ.-1.AND.S2.EQ.1) THEN
                 CALL HFILL(LH(10)+36,XXM,0.,1.)
                 CALL HFILL(LH(10)+136,XXM,0.,WT)
              ENDIF
 
              IF(S1.EQ.1.AND.S2.EQ.-1) THEN
                 CALL HFILL(LH(10)+36,XXM,0.,1.)
                 CALL HFILL(LH(10)+136,XXM,0.,WT)
              ENDIF
 
           ENDIF
 5      CONTINUE
C---------------------------------------------------------------------
C
C                 End of second loop
C
C---------------------------------------------------------------------
 10     CONTINUE
C---------------------------------------------------------------------
C
C                 End of first loop
C
C---------------------------------------------------------------------
 100  CONTINUE
C---------------------------------------------------------------------
C    Plot histograms if event contains muon pair
C---------------------------------------------------------------------
C     IF(.NOT.MUPAIR) CALL MUPLOT
      RETURN
      END
+EOD.
C*********************************************************************
C
C                            M U O N E
C
C*********************************************************************
+DECK,MUONE.
      SUBROUTINE MUONE
C---------------------------------------------------------------------
C    This routine looks for muon pairs with only one DC match
C---------------------------------------------------------------------
+CDE,SABANKC,MUCBLNK.
+CDE,MUSTRC,HISTO.
+CDE,MUID,MUSTAT.
+CDE,MUCOUN,MYINFO.
+CDE,TRACK.
+CDE,KINEM.
+CDE,COMB.
      INTEGER S1,S2,SD1,SD2
      DIMENSION P1(4),P2(4),PMUMU(4),PCMS(4)
C---------------------------------------------------------------------
C
C                 First loop over all tracks
C
C---------------------------------------------------------------------
      DO 100 I1 = 1,NMU
C---------------------------------------------------------------------
C    Check the quality flag
C---------------------------------------------------------------------
        IF(IRAKMU(1,I1,9).NE.1) GO TO 100
C---------------------------------------------------------------------
C    Do muon - DC match for first track
C---------------------------------------------------------------------
        I1BAD = 0
        IF(IRAKMU(1,I1,24).EQ.0)         I1BAD = 1
        IF(TRAKMU(2,I1,23).GT.RCUT)      I1BAD = 1
        IF(ABS(TRAKMU(3,I1,23)).GT.PCUT) I1BAD = 1
C---------------------------------------------------------------------
C    Cut on DC vertex for first track
C---------------------------------------------------------------------
        IF(IRAKMU(1,I1,24).NE.0) THEN
           Y0 = TRAKDC(2,IRAKMU(1,I1,24),14)
           IF(ABS(Y0).GT.0.45) I1BAD = 1
        ENDIF
C---------------------------------------------------------------------
C    Cut on theta for first track
C---------------------------------------------------------------------
        IF(IRAKMU(1,I1,24).NE.0) THEN
           IF(TRAKDC(1,IRAKMU(1,I1,24),17).LT.0.01) I1BAD = 1
        ENDIF
C---------------------------------------------------------------------
C
C                 Second loop over all tracks
C
C---------------------------------------------------------------------
        DO 10 I2 = 1,NMU
           IF(I1.GE.I2)  GO TO 10
C---------------------------------------------------------------------
C    Check the quality flag
C---------------------------------------------------------------------
           IF(IRAKMU(1,I2,9).NE.1)  GO TO 10
C---------------------------------------------------------------------
C    Do muon - DC match for second track
C---------------------------------------------------------------------
           I2BAD = 0
           IF(IRAKMU(1,I2,24).EQ.0)         I2BAD = 1
           IF(TRAKMU(2,I2,23).GT.RCUT)      I2BAD = 1
           IF(ABS(TRAKMU(3,I2,23)).GT.PCUT) I2BAD = 1
C---------------------------------------------------------------------
C    Cut on DC vertex for second track
C---------------------------------------------------------------------
           IF(IRAKMU(1,I2,24).NE.0) THEN
              Y0 = TRAKDC(2,IRAKMU(1,I2,24),14)
              IF(XCUT(10).AND.ABS(Y0).GT.0.45) I2BAD = 1
           ENDIF
C---------------------------------------------------------------------
C    Cut on theta for second track
C---------------------------------------------------------------------
           IF(IRAKMU(1,I2,24).NE.0) THEN
              IF(TRAKDC(1,IRAKMU(1,I2,24),17).LT.0.01) I2BAD = 1
           ENDIF
C---------------------------------------------------------------------
C    Don't match two muontracks to the same DC track
C---------------------------------------------------------------------
           IF(I1BAD.EQ.0.AND.I2BAD.EQ.0.AND.
     *     IRAKMU(1,I1,24).EQ.IRAKMU(1,I2,24)) GO TO 10
C---------------------------------------------------------------------
C    Get the sign of the tracks
C---------------------------------------------------------------------
           S1  = IRAKMU(1,I1,10)
           S2  = IRAKMU(1,I2,10)
           SD1 = 0
           SD2 = 0
           IF(IRAKMU(1,I1,24).NE.0) THEN
              SD1 = IRAKDC(1,IRAKMU(1,I1,24),10)
           ENDIF
           IF(IRAKMU(1,I2,24).NE.0) THEN
              SD2 = IRAKDC(1,IRAKMU(1,I2,24),10)
           ENDIF
C---------------------------------------------------------------------
C    Calculate mass, PT, XF
C---------------------------------------------------------------------
           IF(I1BAD.EQ.0) THEN
              PM1   = TRAKMU(2,I1,5)
              AD1   = TRAKDC(1,IRAKMU(1,I1,24),11)
              BD1   = TRAKDC(1,IRAKMU(1,I1,24),13)
              P1(3) = PM1 / SQRT(AD1**2+BD1**2+1)
              P1(1) = AD1 * P1(3)
              P1(2) = BD1 * P1(3)
           ELSE
              P1(1) = TRAKMU(2,I1,1)
              P1(2) = TRAKMU(2,I1,2)
              P1(3) = TRAKMU(2,I1,3)
           ENDIF
           IF(I2BAD.EQ.0) THEN
              PM2   = TRAKMU(2,I2,5)
              AD2   = TRAKDC(1,IRAKMU(1,I2,24),11)
              BD2   = TRAKDC(1,IRAKMU(1,I2,24),13)
              P2(3) = PM2 / SQRT(AD2**2+BD2**2+1)
              P2(1) = AD2 * P2(3)
              P2(2) = BD2 * P2(3)
           ELSE
              P2(1) = TRAKMU(2,I2,1)
              P2(2) = TRAKMU(2,I2,2)
              P2(3) = TRAKMU(2,I2,3)
           ENDIF
           XM    = MUM
           CALL MASS(2,XM,P1,P2,PMUMU,PCMS,P,PT,XF,XXM,XMT,YLAB,YCM,H)
           PTSQU = PT*PT
           ETOTAL= ETOT + PMUMU(4)
C---------------------------------------------------------------------
C    Plot histograms of mass, PT**2, XF and Etot
C---------------------------------------------------------------------
           IF(JH(14).EQ.0) GO TO 5
 
           IF(S1.EQ.S2) THEN
              SE = RNDM(0)
              IF( (SE.LT.0.5.AND.I1BAD.EQ.0.AND.S1.EQ.SD1) .OR.
     *            (SE.GE.0.5.AND.I2BAD.EQ.0.AND.S2.EQ.SD2) ) THEN
                     CALL HFILL(LH(14)+1,XXM,0.,1.)
              ENDIF
           ENDIF
 
           IF(S1.NE.S2) THEN
              IF( (S1.EQ.-1.AND.I1BAD.EQ.0.AND.S1.EQ.SD1) .OR.
     *            (S2.EQ.-1.AND.I2BAD.EQ.0.AND.S2.EQ.SD2) ) THEN
                     CALL HFILL(LH(14)+2,XXM,0.,1.)
              ENDIF
           ENDIF
 
           IF(S1.NE.S2) THEN
              IF( (S1.EQ.1.AND.I1BAD.EQ.0.AND.S1.EQ.SD1) .OR.
     *            (S2.EQ.1.AND.I2BAD.EQ.0.AND.S2.EQ.SD2) ) THEN
                     CALL HFILL(LH(14)+3,XXM,0.,1.)
              ENDIF
           ENDIF
 
           IF(S1.EQ.S2) THEN
              IF( (I1BAD.EQ.0.AND.S1.EQ.SD1.AND.I2BAD.EQ.1) .OR.
     *            (I2BAD.EQ.0.AND.S2.EQ.SD2.AND.I1BAD.EQ.1) ) THEN
                     CALL HFILL(LH(14)+4,XXM,0.,1.)
              ENDIF
           ENDIF
 
           IF(S1.NE.S2) THEN
              IF( (I1BAD.EQ.0.AND.S1.EQ.SD1.AND.I2BAD.EQ.1) .OR.
     *            (I2BAD.EQ.0.AND.S2.EQ.SD2.AND.I1BAD.EQ.1) ) THEN
                     CALL HFILL(LH(14)+5,XXM,0.,1.)
              ENDIF
           ENDIF
 
           IF(S1.EQ.S2) THEN
              IF( (I1BAD.EQ.0.AND.S1.EQ.SD1) .AND.
     *            (I2BAD.EQ.0.AND.S2.EQ.SD2) ) THEN
                     CALL HFILL(LH(14)+6,XXM,0.,1.)
              ENDIF
           ENDIF
 
           IF(S1.NE.S2) THEN
              IF( (I1BAD.EQ.0.AND.S1.EQ.SD1) .AND.
     *            (I2BAD.EQ.0.AND.S2.EQ.SD2) ) THEN
                     CALL HFILL(LH(14)+7,XXM,0.,1.)
              ENDIF
           ENDIF
 
           IF(S1.EQ.S2) THEN
              IF( (I1BAD.EQ.0.AND.S1.NE.SD1.AND.I2BAD.EQ.1) .OR.
     *            (I2BAD.EQ.0.AND.S2.NE.SD2.AND.I1BAD.EQ.1) ) THEN
                     CALL HFILL(LH(14)+8,XXM,0.,1.)
              ENDIF
           ENDIF
 
           IF(S1.NE.S2) THEN
              IF( (I1BAD.EQ.0.AND.S1.NE.SD1.AND.I2BAD.EQ.1) .OR.
     *            (I2BAD.EQ.0.AND.S2.NE.SD2.AND.I1BAD.EQ.1) ) THEN
                     CALL HFILL(LH(14)+9,XXM,0.,1.)
              ENDIF
           ENDIF
 
 5      CONTINUE
C---------------------------------------------------------------------
C
C                 End of second loop
C
C---------------------------------------------------------------------
 10     CONTINUE
C---------------------------------------------------------------------
C
C                 End of first loop
C
C---------------------------------------------------------------------
 100  CONTINUE
      RETURN
      END
+EOD.
C*********************************************************************
C
C                            M U C O M B
C
C*********************************************************************
+DECK,MUCOMB.
      SUBROUTINE MUCOMB
C---------------------------------------------------------------------
C    This routine calcultes the comb. background by mixing events
C---------------------------------------------------------------------
+CDE,SABANKC,MUCBLNK.
+CDE,MUSTRC,HISTO.
+CDE,MUID,MUSTAT.
+CDE,MUCOUN,MYINFO.
+CDE,TRACK.
+CDE,KINEM.
+CDE,COMB.
      DIMENSION P1(4),P2(4),PMUMU(4),PCMS(4)
C---------------------------------------------------------------------
C
C                 First loop over all positive tracks
C
C---------------------------------------------------------------------
      WRITE(6,*) ' IBP IBN   ===>',IBP,IBN
      IF(IBP.GE.1500) IBP = 1500
      IF(IBN.GE.1500) IBN = 1500
      DO 100 I1 = 1,IBP
C---------------------------------------------------------------------
C
C                 Second loop over all negative tracks
C
C---------------------------------------------------------------------
        DO 10 I2 = 1,IBN
C---------------------------------------------------------------------
C    Calculate mass
C---------------------------------------------------------------------
           P1(1) = CBP(1,I1)
           P1(2) = CBP(2,I1)
           P1(3) = CBP(3,I1)
           P2(1) = CBN(1,I2)
           P2(2) = CBN(2,I2)
           P2(3) = CBN(3,I2)
           XM    = MUM
           CALL MASS(1,XM,P1,P2,PMUMU,PCMS,P,PT,XF,XXM,XMT,YLAB,YCM,H)
C---------------------------------------------------------------------
C    Calculate the weight due to inefficiency and acceptance
C---------------------------------------------------------------------
C          WT = 1.
C          WT = CBP(4,I1) * CBN(4,I2)
C          WT = WT * WTMASS(XXM,2,IERROR)
C          WRITE(6,*) '  WT===>',WT
C---------------------------------------------------------------------
C    Plot histograms of mass
C---------------------------------------------------------------------
           IF(JH(10).EQ.0) GO TO 5
               CALL HFILL(LH(10)+901,XXM,0.,1.)
               CALL HFILL(LH(10)+903,XXM,0.,1.)
C              CALL HFILL(LH(10)+902,XXM,0.,WT)
 5      CONTINUE
C---------------------------------------------------------------------
C
C                 End of second loop
C
C---------------------------------------------------------------------
 10     CONTINUE
C---------------------------------------------------------------------
C
C                 End of first loop
C
C---------------------------------------------------------------------
 100  CONTINUE
      RETURN
      END
+EOD.
C*********************************************************************
C
C                         W T H O D
C
C*********************************************************************
+DECK,WTHOD.
      FUNCTION WTHOD(I)
C---------------------------------------------------------------------
C   This is the routine which corrects for the hod. efficiency
C---------------------------------------------------------------------
+CDE,TRACK.
+CDE,MYINFO.
+CDE,MUGEOH.
      DIMENSION EFFH2(12),EFFH3(12)
      DATA EFFH3 /0.985,0.982,0.975,0.924,0.864,0.814,
     *            0.730,0.844,0.901,0.963,0.983,0.985/
      DATA EFFH2 /0.985,0.985,0.985,0.985,0.950,0.900,
     *            0.820,0.930,0.985,0.985,0.985,0.985/
C---------------------------------------------------------------------
C    Initialization
C---------------------------------------------------------------------
      ALPHA     = TRAKMU(4,I,11)
      X0        = TRAKMU(4,I,12)
C---------------------------------------------------------------------
C    Track position at hodoscopes
C---------------------------------------------------------------------
      XH3 = ALPHA*ZHOD(1) + X0
      XH2 = ALPHA*ZHOD(2) + X0
C---------------------------------------------------------------------
C   Get the x position on the slab
C---------------------------------------------------------------------
      IF(XH3.GT.250.)                   IXH3 = 1
      IF(XH3.GE.200.AND.XH3.LT.250.)    IXH3 = 2
      IF(XH3.GE.150.AND.XH3.LT.200.)    IXH3 = 3
      IF(XH3.GE.100.AND.XH3.LT.150.)    IXH3 = 4
      IF(XH3.GE.50.AND.XH3.LT.100.)     IXH3 = 5
      IF(XH3.GE.0.AND.XH3.LT.50.)       IXH3 = 6
      IF(XH3.GE.-50.AND.XH3.LT.0.)      IXH3 = 7
      IF(XH3.GE.-100.AND.XH3.LT.-50.)   IXH3 = 8
      IF(XH3.GE.-150.AND.XH3.LT.-100.)  IXH3 = 9
      IF(XH3.GE.-200.AND.XH3.LT.-150.)  IXH3 = 10
      IF(XH3.GE.-250.AND.XH3.LT.-200.)  IXH3 = 11
      IF(XH3.LT.-250.)                  IXH3 = 12
 
      IF(XH2.GT.250.)                   IXH2 = 1
      IF(XH2.GE.200.AND.XH2.LT.250.)    IXH2 = 2
      IF(XH2.GE.150.AND.XH2.LT.200.)    IXH2 = 3
      IF(XH2.GE.100.AND.XH2.LT.150.)    IXH2 = 4
      IF(XH2.GE.50.AND.XH2.LT.100.)     IXH2 = 5
      IF(XH2.GE.0.AND.XH2.LT.50.)       IXH2 = 6
      IF(XH2.GE.-50.AND.XH2.LT.0.)      IXH2 = 7
      IF(XH2.GE.-100.AND.XH2.LT.-50.)   IXH2 = 8
      IF(XH2.GE.-150.AND.XH2.LT.-100.)  IXH2 = 9
      IF(XH2.GE.-200.AND.XH2.LT.-150.)  IXH2 = 10
      IF(XH2.GE.-250.AND.XH2.LT.-200.)  IXH2 = 11
      IF(XH2.LT.-250.)                  IXH2 = 12
C---------------------------------------------------------------------
C   Get the weight
C---------------------------------------------------------------------
      WTHOD = 1. / ( EFFH2(IXH2) * EFFH3(IXH3) )
      RETURN
      END
+EOD.
C*********************************************************************
C
C                         W T D C
C
C*********************************************************************
+DECK,WTDC.
      FUNCTION WTDC(I)
C---------------------------------------------------------------------
C
C     Function that gives the DC track reconstruction
C     efficiency as a function of measured multiplicity
C     and track polar angle.
C
C     Input : NDC2  : # tracks found by LUCY in DC2
C                    (# 7127-banks with the bit for
C                       DC2 set.)
C             THETA : Polar angle of track (R/Z)
C---------------------------------------------------------------------
+CDE,TRACK.
+CDE,MYINFO.
      DIMENSION EFFMLT(20)
C---------------------------------------------------------------------
C     First 9 are Rob's, then guessing the rest, using
C     Gilles' value of 0.40 at n=20.
C---------------------------------------------------------------------
      DATA EFFMLT/0.89,0.89,0.89,0.87,0.87,0.85,0.82,0.72,0.62
     *           ,3*0.6,4*0.5,4*0.4/
 
      THETA = ABS(TRAKDC(1,I,17))
 
      IF(THETA.GT.0.100)     THEN
        EFFTHE = 0.00000000001
      ELSEIF(THETA.GT.0.006) THEN
        EFFTHE = 1. - 0.005/THETA
      ELSE
        EFFTHE = 0.00000000001
      ENDIF
 
      NDC2  = MULTDC(8)
 
      IF(NDC2.LE.0) THEN
        EFFDC = 0.00000000001
      ELSEIF(NDC2.LE.20) THEN
        EFFDC = EFFTHE *  EFFMLT(NDC2)
      ELSE
        EFFDC = EFFTHE * EFFMLT(20)
      ENDIF
 
      WTDC = 1./EFFDC
      IF(1./EFFDC.GT.1000.) WTDC = 0.
 
      RETURN
      END
+EOD.
C*********************************************************************
C
C                         W T M A S S
C
C*********************************************************************
+DECK,WTMASS.
        FUNCTION WTMASS(XMASS,ICUT,IERR)
C---------------------------------------------------------------------
C     Function that gives acceptence of the muon spectrometer.
C---------------------------------------------------------------------
+CDE,TRACK.
+CDE,MYINFO.
C---------------------------------------------------------------------
C
C       INPUT :   XMASS        Mass in GeV; must be .2.LT.XMASS.LE.1.5
C                 ICUT = 1 ==> No theta cut, no mult.scat.cut
C                        2 ==> Theta cut (10mrad), no mult.scat.cut
C                        3 ==> Theta cut (10mrad), mult.scat.cut (2.5)
C                      < 1 OR > 3 ==> ICUT=3
C
C       OUTPUT:   IERR = 0 ==> everything's fine
C                      =-1 ==> mass out of all. range
C                      =-2 ==> weight would be 1/0
C                 WTMASS        weight; it is 0. if IERR.NE.0
C---------------------------------------------------------------------
        DIMENSION AM(14,3),AQ(14,3)
        DATA (AM(I,1),I=1,14)/0.000,0.050,0.090,0.140,0.180,0.200,0.200,
     +                        0.170,0.130,0.090,0.050,0.020,0.020,0.000/
        DATA (AQ(I,1),I=1,14)/0.591,0.579,0.564,0.542,0.520,0.507,0.507,
     +                        0.532,0.570,0.613,0.659,0.696,0.696,0.725/
        DATA (AM(I,2),I=1,14)/0.000,-.010,0.020,0.080,0.140,0.180,0.160,
     +                        0.150,0.140,0.110,0.080,0.040,0.030,0.000/
        DATA (AQ(I,2),I=1,14)/0.245,0.248,0.237,0.210,0.177,0.151,0.166,
     +                        0.174,0.184,0.215,0.250,0.300,0.314,0.357/
        DATA (AM(I,3),I=1,14)/0.000,0.020,0.070,0.120,0.160,0.170,0.160,
     +                        0.140,0.120,0.110,0.090,0.050,0.030,0.000/
        DATA (AQ(I,3),I=1,14)/0.221,0.216,0.199,0.176,0.154,0.147,0.155,
     +                        0.172,0.191,0.201,0.224,0.275,0.302,0.345/
        DATA XMASSM,BINW /1.5,.1/
*
        WTMASS=0.
        IERR=-1
        IF(XMASS.LE..2.OR.XMASS.GT.XMASSM) RETURN
        IF(ICUT.LE.0.OR.ICUT.GT.3) ICUT=3
        DM=.15
        DO 50 I=1,14
          IN=I
          DM=DM+BINW
          IF(XMASS.LE.DM) GO TO 100
 50     CONTINUE
        RETURN
 100    CONTINUE
        IERR=-2
        ACC=AM(IN,ICUT)*XMASS+AQ(IN,ICUT)
        IF(ACC.LE.0.) RETURN
        WTMASS=1./ACC
        IERR=0
        RETURN
        END
+EOD.
C*********************************************************************
C
C                         R F A C T
C
C*********************************************************************
+DECK,RFACT.
      FUNCTION RFACT(I)
C---------------------------------------------------------------------
C
C     Function that gives the R factor for the correction of
C     the comb. background.
C
C     Input : NDC2  : # good tracks corrected for eff. in
C                     10 theta < 70 mrad
C---------------------------------------------------------------------
      DIMENSION EFF(15)
      DATA EFF/2.00,2.00,2.00,1.55,1.35,1.26,1.21,1.19,1.16,1.16,
     *         1.16,1.13,1.12,1.12,1.10/
 
      IF(I.LE.15) THEN
         RFACT=EFF(I)
      ELSE
         RFACT=1.10
      ENDIF
 
      RETURN
      END
+EOD.
C*********************************************************************
C
C                         M U P L O T
C
C*********************************************************************
+DECK,MUPLOT.
      SUBROUTINE MUPLOT
C---------------------------------------------------------------------
C   This routine calculates the distances between the tracks in DC2
C---------------------------------------------------------------------
+CDE,TRACK.
+CDE,MYINFO.
+CDE,MUGEOH.
+CDE,HISTO.
      INTEGER S1,S2
C---------------------------------------------------------------------
C    Check the histogram flag
C---------------------------------------------------------------------
      IF(JH(10).EQ.0) RETURN
C---------------------------------------------------------------------
C     Plot histogram
C---------------------------------------------------------------------
      CALL HFILL(LH(10)+321,FLOAT(MULTSC),0.,1.)
      DO 35 I=1,7
         IF(MULTDC(I).EQ.0) GO TO 35
         DO 34 J=1,MULTDC(I)
 34         CALL HFILL(LH(10)+304,FLOAT(I),0.,1.)
 35      CONTINUE
      CALL HFILL(LH(10)+305,FLOAT(NDC),0.,1.)
      CALL HFILL(LH(10)+301,FLOAT(MULTDC(9)),0.,1.)
      CALL HFILL(LH(10)+302,FLOAT(MULTDC(10)),0.,1.)
      CALL HFILL(LH(10)+303,FLOAT(MULTDC(11)),0.,1.)
      CALL HFILL(LH(10)+306,FLOAT(MULTDC(8)),0.,1.)
      RETURN
      END
+EOD.
C*********************************************************************
C
C                         D C P L O T
C
C*********************************************************************
+DECK,DCPLOT.
      SUBROUTINE DCPLOT(I1,I2,S1,S2)
C---------------------------------------------------------------------
C   This routine calculates the distances between the tracks in DC2
C---------------------------------------------------------------------
+CDE,TRACK.
+CDE,MYINFO.
+CDE,MUGEOH.
+CDE,HISTO.
      INTEGER S1,S2
C---------------------------------------------------------------------
C    Check the histogram flag
C---------------------------------------------------------------------
      IF(JH(5).EQ.0) RETURN
C---------------------------------------------------------------------
C    Track parameters
C---------------------------------------------------------------------
        ZDC2  = 233.
        X1    = TRAKDC(5,I1,11) * ZDC2 + TRAKDC(5,I1,12)
        Y1    = TRAKDC(5,I1,13) * ZDC2 + TRAKDC(5,I1,14)
        X2    = TRAKDC(5,I2,11) * ZDC2 + TRAKDC(5,I2,12)
        Y2    = TRAKDC(5,I2,13) * ZDC2 + TRAKDC(5,I2,14)
        DELTAX= ABS(X1-X2)
        DELTAY= ABS(Y1-Y2)
        R     = SQRT( DELTAX**2 + DELTAY**2 )
C---------------------------------------------------------------------
C   Fill histograms
C---------------------------------------------------------------------
         IF(S1.EQ.1.AND.S2.EQ.1)   THEN
            CALL HFILL(LH(5)+51,DELTAX,0.,1.)
            CALL HFILL(LH(5)+52,DELTAY,0.,1.)
            CALL HFILL(LH(5)+53,R,0.,1.)
            CALL HFILL(LH(5)+54,DELTAX,0.,1.)
            CALL HFILL(LH(5)+55,DELTAY,0.,1.)
            CALL HFILL(LH(5)+56,R,0.,1.)
         ENDIF
         IF(S1.EQ.-1.AND.S2.EQ.-1) THEN
            CALL HFILL(LH(5)+51,DELTAX,0.,1.)
            CALL HFILL(LH(5)+52,DELTAY,0.,1.)
            CALL HFILL(LH(5)+53,R,0.,1.)
            CALL HFILL(LH(5)+54,DELTAX,0.,1.)
            CALL HFILL(LH(5)+55,DELTAY,0.,1.)
            CALL HFILL(LH(5)+56,R,0.,1.)
         ENDIF
         IF(S1.EQ.-1.AND.S2.EQ.1)  THEN
            CALL HFILL(LH(5)+61,DELTAX,0.,1.)
            CALL HFILL(LH(5)+62,DELTAY,0.,1.)
            CALL HFILL(LH(5)+63,R,0.,1.)
            CALL HFILL(LH(5)+64,DELTAX,0.,1.)
            CALL HFILL(LH(5)+65,DELTAY,0.,1.)
            CALL HFILL(LH(5)+66,R,0.,1.)
         ENDIF
         IF(S1.EQ.1.AND.S2.EQ.-1)  THEN
            CALL HFILL(LH(5)+61,DELTAX,0.,1.)
            CALL HFILL(LH(5)+62,DELTAY,0.,1.)
            CALL HFILL(LH(5)+63,R,0.,1.)
            CALL HFILL(LH(5)+64,DELTAX,0.,1.)
            CALL HFILL(LH(5)+65,DELTAY,0.,1.)
         ENDIF
      RETURN
      END
+EOD.
C*********************************************************************
C
C                         H O P L O T
C
C*********************************************************************
+DECK,HOPLOT.
      SUBROUTINE HOPLOT(I1,I2,S1,S2)
C---------------------------------------------------------------------
C   This routine plots the x and y position at the hodoscopes
C---------------------------------------------------------------------
+CDE,TRACK.
+CDE,MYINFO.
+CDE,MUGEOH.
+CDE,HISTO.
      INTEGER S1,S2
      DIMENSION X(3),Y(3)
C---------------------------------------------------------------------
C    Check the histogram flag
C---------------------------------------------------------------------
      IF(JH(6).EQ.0) RETURN
C---------------------------------------------------------------------
C    Loop over the two tracks
C---------------------------------------------------------------------
      DO 100 J=1,2
         IF(J.EQ.1) I=I1
         IF(J.EQ.2) I=I2
C---------------------------------------------------------------------
C    Track parameters
C---------------------------------------------------------------------
         ALPHA  = TRAKMU(4,I,11)
         X0     = TRAKMU(4,I,12)
         BETA   = TRAKMU(4,I,13)
         Y0     = TRAKMU(4,I,14)
         X(1)   = ALPHA*ZHOD(1) + X0
         Y(1)   = BETA*ZHOD(1) + Y0
         X(2)   = ALPHA*ZHOD(2) + X0
         Y(2)   = BETA*ZHOD(2) + Y0
         X(3)   = ALPHA*(ZHOD(2)+100.) + X0
         Y(3)   = BETA*(ZHOD(2)+100.) + Y0
C---------------------------------------------------------------------
C   Fill histograms
C---------------------------------------------------------------------
         IF(S1.EQ.1.AND.S2.EQ.1)   THEN
            CALL HFILL(LH(6)+11,X(1),0.,1.)
            CALL HFILL(LH(6)+21,X(2),0.,1.)
            CALL HFILL(LH(6)+31,X(3),0.,1.)
            CALL HFILL(LH(6)+110,Y(1),0.,1.)
            CALL HFILL(LH(6)+210,Y(2),0.,1.)
            CALL HFILL(LH(6)+310,Y(3),0.,1.)
         ENDIF
         IF(S1.EQ.-1.AND.S2.EQ.-1) THEN
            CALL HFILL(LH(6)+11,X(1),0.,1.)
            CALL HFILL(LH(6)+21,X(2),0.,1.)
            CALL HFILL(LH(6)+31,X(3),0.,1.)
            CALL HFILL(LH(6)+110,Y(1),0.,1.)
            CALL HFILL(LH(6)+210,Y(2),0.,1.)
            CALL HFILL(LH(6)+310,Y(3),0.,1.)
         ENDIF
         IF(S1.EQ.-1.AND.S2.EQ.1)  THEN
            CALL HFILL(LH(6)+12,X(1),0.,1.)
            CALL HFILL(LH(6)+22,X(2),0.,1.)
            CALL HFILL(LH(6)+32,X(3),0.,1.)
            CALL HFILL(LH(6)+120,Y(1),0.,1.)
            CALL HFILL(LH(6)+220,Y(2),0.,1.)
            CALL HFILL(LH(6)+320,Y(3),0.,1.)
         ENDIF
         IF(S1.EQ.1.AND.S2.EQ.-1)  THEN
            CALL HFILL(LH(6)+12,X(1),0.,1.)
            CALL HFILL(LH(6)+22,X(2),0.,1.)
            CALL HFILL(LH(6)+32,X(3),0.,1.)
            CALL HFILL(LH(6)+120,Y(1),0.,1.)
            CALL HFILL(LH(6)+220,Y(2),0.,1.)
            CALL HFILL(LH(6)+320,Y(3),0.,1.)
         ENDIF
 100  CONTINUE
      RETURN
      END
+EOD.
C*********************************************************************
C
C                            M U M U R A
C
C*********************************************************************
+DECK,MUMURA.
      SUBROUTINE MUMURA(MUPAIR)
C---------------------------------------------------------------------
C    This routine plots the raw mass spectrum
C---------------------------------------------------------------------
+CDE,SABANKC,MUCBLNK.
+CDE,MUSTRC,HISTO.
+CDE,MUID,MUSTAT.
+CDE,MUCOUN,MYINFO.
+CDE,TRACK.
+CDE,KINEM.
      INTEGER S1,S2
      LOGICAL   MUPAIR
      DIMENSION P1(4),P2(4),PMUMU(4),PCMS(4)
      MUPAIR = .TRUE.
C---------------------------------------------------------------------
C
C                 First loop over all tracks
C
C---------------------------------------------------------------------
      DO 100 I1 = 1,NMU
C---------------------------------------------------------------------
C    Check the quality flag
C---------------------------------------------------------------------
        IF(IRAKMU(1,I1,9).NE.1)                       GO TO 100
C---------------------------------------------------------------------
C                Theta
C---------------------------------------------------------------------
C       IF(TRAKMU(2,I1,17).LT.0.01) GO TO 100
C---------------------------------------------------------------------
C
C                 Second loop over all tracks
C
C---------------------------------------------------------------------
        DO 10 I2 = 1,NMU
           IF(I1.GE.I2)                                  GO TO 10
C---------------------------------------------------------------------
C    Check the quality flag
C---------------------------------------------------------------------
           IF(IRAKMU(1,I2,9).NE.1)                       GO TO 10
C---------------------------------------------------------------------
C                    Theta
C---------------------------------------------------------------------
C       IF(TRAKMU(2,I2,17).LT.0.01) GO TO 10
C---------------------------------------------------------------------
C    Get the sign of the tracks
C---------------------------------------------------------------------
           S1  = IRAKMU(1,I1,10)
           S2  = IRAKMU(1,I2,10)
C---------------------------------------------------------------------
C    Set mupair flag
C---------------------------------------------------------------------
           MUPAIR = .FALSE.
C---------------------------------------------------------------------
C    Calculate mass, PT, XF
C---------------------------------------------------------------------
           P1(1) = TRAKMU(2,I1,1)
           P1(2) = TRAKMU(2,I1,2)
           P1(3) = TRAKMU(2,I1,3)
           P2(1) = TRAKMU(2,I2,1)
           P2(2) = TRAKMU(2,I2,2)
           P2(3) = TRAKMU(2,I2,3)
           XM    = MUM
           CALL MASS(2,XM,P1,P2,PMUMU,PCMS,P,PT,XF,XXM,XMT,YLAB,YCM,H)
           PTSQU = PT*PT
           ETOTAL= ETOT + PMUMU(4)
C---------------------------------------------------------------------
C    Plot histograms of mass etc
C---------------------------------------------------------------------
           IF(JH(12).EQ.0) GO TO 5
           IF(S1.EQ.1.AND.S2.EQ.1) THEN
              CALL HFILL(LH(12)+4,XXM,0.,1.)
              CALL HFILL(LH(12)+81,YLAB,0.,1.)
              IF(XXM.LE.0.6)
     *        CALL HFILL(LH(12)+84,YLAB,0.,1.)
              IF(XXM.GT.0.6.AND.XXM.LE.1.2)
     *        CALL HFILL(LH(12)+87,YLAB,0.,1.)
C             CALL HFILL(LH(12)+7,PTSQU,0.,1.)
C             CALL HFILL(LH(12)+10,XF,0.,1.)
C             CALL HFILL(LH(12)+13,ETOTAL,0.,1.)
C             IF(XXM.LE.0.4) CALL HFILL(LH(12)+51,XMT,0.,1.)
C             IF(XF.GE.0.07) CALL HFILL(LH(12)+61,XXM,0.,1.)
           ENDIF
           IF(S1.EQ.-1.AND.S2.EQ.-1) THEN
              CALL HFILL(LH(12)+5,XXM,0.,1.)
              CALL HFILL(LH(12)+82,YLAB,0.,1.)
              IF(XXM.LE.0.6)
     *        CALL HFILL(LH(12)+85,YLAB,0.,1.)
              IF(XXM.GT.0.6.AND.XXM.LE.1.2)
     *        CALL HFILL(LH(12)+88,YLAB,0.,1.)
C             CALL HFILL(LH(12)+8,PTSQU,0.,1.)
C             CALL HFILL(LH(12)+11,XF,0.,1.)
C             CALL HFILL(LH(12)+14,ETOTAL,0.,1.)
C             IF(XXM.LE.0.4) CALL HFILL(LH(12)+52,XMT,0.,1.)
C             IF(XF.GE.0.07) CALL HFILL(LH(12)+62,XXM,0.,1.)
           ENDIF
           IF(S1.EQ.-1.AND.S2.EQ.1) THEN
              CALL HFILL(LH(12)+6,XXM,0.,1.)
              CALL HFILL(LH(12)+83,YLAB,0.,1.)
              IF(XXM.LE.0.6)
     *        CALL HFILL(LH(12)+86,YLAB,0.,1.)
              IF(XXM.GT.0.6.AND.XXM.LE.1.2)
     *        CALL HFILL(LH(12)+89,YLAB,0.,1.)
C             CALL HFILL(LH(12)+9,PTSQU,0.,1.)
C             CALL HFILL(LH(12)+12,XF,0.,1.)
C             CALL HFILL(LH(12)+15,ETOTAL,0.,1.)
C             IF(XXM.LE.0.4) CALL HFILL(LH(12)+53,XMT,0.,1.)
C             IF(XF.GE.0.07) CALL HFILL(LH(12)+63,XXM,0.,1.)
           ENDIF
           IF(S1.EQ.1.AND.S2.EQ.-1) THEN
              CALL HFILL(LH(12)+6,XXM,0.,1.)
              CALL HFILL(LH(12)+83,YLAB,0.,1.)
              IF(XXM.LE.0.6)
     *        CALL HFILL(LH(12)+86,YLAB,0.,1.)
              IF(XXM.GT.0.6.AND.XXM.LE.1.2)
     *        CALL HFILL(LH(12)+89,YLAB,0.,1.)
C             CALL HFILL(LH(12)+9,PTSQU,0.,1.)
C             CALL HFILL(LH(12)+12,XF,0.,1.)
C             CALL HFILL(LH(12)+15,ETOTAL,0.,1.)
C             IF(XXM.LE.0.4) CALL HFILL(LH(12)+53,XMT,0.,1.)
C             IF(XF.GE.0.07) CALL HFILL(LH(12)+63,XXM,0.,1.)
           ENDIF
 5      CONTINUE
C---------------------------------------------------------------------
C
C                 End of second loop
C
C---------------------------------------------------------------------
 10     CONTINUE
C---------------------------------------------------------------------
C
C                 End of first loop
C
C---------------------------------------------------------------------
 100  CONTINUE
      RETURN
      END
+EOD.
C*********************************************************************
C
C                            M A S S
C
C*********************************************************************
+DECK,MASS.
      SUBROUTINE MASS(I,XM,P1,P2,PMUMU,PCMS,P,PT,XF,XXM,XMT,YLAB,YCM,H)
C---------------------------------------------------------------------
C    This routine calculates invariant mass, energy, momentum, PT
C    and Feynman X of a pair of particles.
C---------------------------------------------------------------------
C  Input parameters  I:          =1 only mass and momentum calculated
C                    XM:         rest mass of the particles
C                    P1(1-3):    momentum in lab of part. 1
C                    P2(1-3):    momentum in lab of part. 2
C
C  Output parameters P1(4):      energy in lab of particle 1
C                    P2(4):      energy in lab of particle 2
C                    PMUMU(1-4): 4-momentum of pair in lab
C                    PCMS(1-4):  4-momentum of pair in cms
C                    P:          momentum in lab
C                    PT:         transverse momentum (invariant)
C                    XF:         Feynman X  (always cms)
C                    XXM:        mass of pair (invariant)
C                    XMT:        transverse mass of pair (invariant)
C                    YLAB:       rapidity in lab of pair
C                    YCM:        rapidity in cms of pair
C                    H:          cos(helicity angle)
C
C  Internal parameters PCM:      momentum in cms of pair
C---------------------------------------------------------------------
      COMMON/TLOR/TMB,TMT,TPBL,TPBC,TSS,TBET,TLOR(4)
      COMMON/CONST/EM,EEM,MUM,MUMUM,PIM,KAM,PRM,ROM,PI,PI2
      REAL MUM,MUMUM,KAM
      DIMENSION  P1(4),P2(4),P1CM(4),P2CM(4),PMUMU(4),PCMS(4)
      DIMENSION  A(4),B(4),C(4)
C---------------------------------------------------------------------
C    Energy of the two particles
C---------------------------------------------------------------------
      E1 = SQRT(XM**2 + P1(1)**2 + P1(2)**2 + P1(3)**2)
      E2 = SQRT(XM**2 + P2(1)**2 + P2(2)**2 + P2(3)**2)
      P1(4)    = E1
      P2(4)    = E2
C---------------------------------------------------------------------
C    4-Momentum of the pair in lab
C---------------------------------------------------------------------
      PMUMU(1) = P1(1) + P2(1)
      PMUMU(2) = P1(2) + P2(2)
      PMUMU(3) = P1(3) + P2(3)
      PMUMU(4) = E1 + E2
C---------------------------------------------------------------------
C    Transverse momentum
C---------------------------------------------------------------------
      PT = SQRT((P1(1)+P2(1))**2+(P1(2)+P2(2))**2)
C---------------------------------------------------------------------
C    Momentum in lab
C---------------------------------------------------------------------
      P = (P1(1)+P2(1))**2+(P1(2)+P2(2))**2+(P1(3)+P2(3))**2
      P = SQRT(P)
C---------------------------------------------------------------------
C    Mass
C---------------------------------------------------------------------
      XXM = SQRT( ABS(PMUMU(4)**2 - P**2) )
      IF(I.EQ.1) RETURN
C---------------------------------------------------------------------
C    LAB --> CMS
C---------------------------------------------------------------------
      CALL LABCMS(P1,P1CM)
      CALL LABCMS(P2,P2CM)
C---------------------------------------------------------------------
C    4-Momentum of the pair in CMS
C---------------------------------------------------------------------
      PCMS(1) = P1CM(1) + P2CM(1)
      PCMS(2) = P1CM(2) + P2CM(2)
      PCMS(3) = P1CM(3) + P2CM(3)
      PCMS(4) = P1CM(4) + P2CM(4)
C---------------------------------------------------------------------
C    Momentum in CMS
C---------------------------------------------------------------------
      PCM = PT**2+(P1CM(3)+P2CM(3))**2
      PCM = SQRT(PCM)
C---------------------------------------------------------------------
C    MT
C---------------------------------------------------------------------
      XMT = SQRT(XXM**2 + PT**2)
C---------------------------------------------------------------------
C    Feynman X
C---------------------------------------------------------------------
      XF = 2.*PCMS(3)/TSS
C---------------------------------------------------------------------
C    Rapidity
C---------------------------------------------------------------------
      YLAB =0.5*ALOG( ABS((PMUMU(4)+PMUMU(3))/(PMUMU(4)-PMUMU(3))) )
      YCM  =0.5*ALOG( ABS((PCMS(4)+PCMS(3))/(PCMS(4)-PCMS(3))) )
C---------------------------------------------------------------------
C    Helicity
C---------------------------------------------------------------------
      CALL LORENF(XXM,PCMS,P1CM,A)
      C(1) = -PCMS(1)
      C(2) = -PCMS(2)
      C(3) = -PCMS(3)
      C(4) =  PCMS(4)
      CALL LORENF(XXM,PCMS,C,B)
      CALL COSANG(A,B,COSHEL)
      H=ABS(COSHEL)
 
      RETURN
      END
+EOD.
C********************************************************************
 
 
C                      C O S A N G
 
 
C********************************************************************
+DECK,COSANG.
      SUBROUTINE COSANG(A,B,C)
C---------------------------------------------------------------------
C    This routine gives the cos(angle) between two tracks with
C    four momentum A and B
C---------------------------------------------------------------------
      DIMENSION A(4),B(4)
      ASUM=SQRT(A(1)**2+A(2)**2+A(3)**2)
      BSUM=SQRT(B(1)**2+B(2)**2+B(3)**2)
      C=A(1)*B(1)+A(2)*B(2)+A(3)*B(3)
      IF(ASUM*BSUM.GT.0.) C=C/(ASUM*BSUM)
      RETURN
      END
+EOD.
C*********************************************************************
C
C                            M U F I L T
C
C*********************************************************************
+DECK,MUFILT.
      SUBROUTINE MUFILT(MUCUT)
C---------------------------------------------------------------------
C    This routine filters the muon data
C---------------------------------------------------------------------
+CDE,SABANKC,MUCBLNK.
+CDE,MUSTRC,HISTO.
+CDE,MUID,MUSTAT.
+CDE,MUCOUN,MYINFO.
+CDE,TRACK.
      DIMENSION IGOOD(4)
      LOGICAL MUCUT
      MUCUT =.FALSE.
C---------------------------------------------------------------------
C    Zero the number of good tracks
C---------------------------------------------------------------------
      CALL VZERO(IGOOD,4)
C---------------------------------------------------------------------
C
C         Loop over all tracks found in mu spectrometer
C
C---------------------------------------------------------------------
      DO 100 I = 1,NMU
C---------------------------------------------------------------------
C    Momentum
C---------------------------------------------------------------------
        IF(TRAKMU(1,I,5).EQ.0.) GO TO 100
        IGOOD(1)=IGOOD(1)+1
C---------------------------------------------------------------------
C    Chi square / NDF
C---------------------------------------------------------------------
        IF(TRAKMU(1,I,15).GT.5.) GO TO 100
        IGOOD(2)=IGOOD(2)+1
C---------------------------------------------------------------------
C    Hodoscope information
C---------------------------------------------------------------------
        IF(IRAKMU(1,I,16).NE.1) GO TO 100
        IGOOD(3)=IGOOD(3)+1
C---------------------------------------------------------------------
C    Multiple Scattering angle (the efficiency for good tracks is 97%)
C---------------------------------------------------------------------
        OMEGA=0.
        IF(TRAKMU(1,I,20).NE.0.)
     *  OMEGA=TRAKMU(3,I,22)/TRAKMU(1,I,20)
C       IF(OMEGA.GT.2.5) GO TO 100
C       IF(OMEGA.GT.2.0) GO TO 100
        IGOOD(4)=IGOOD(4)+1
C---------------------------------------------------------------------
C    Set the quality flag
C---------------------------------------------------------------------
        IRAKMU(1,I,9) = 1
        IF(TRAKMU(2,I,17).GT.0.01) IRAKMU(2,I,9) = 1
        IF(TRAKMU(3,I,21).GT.3.84) IRAKMU(3,I,9) = 1
C---------------------------------------------------------------------
C
C                 End loop over all good tracks
C
C---------------------------------------------------------------------
 100  CONTINUE
C---------------------------------------------------------------------
C    Cut
C---------------------------------------------------------------------
      IF(IGOOD(1).LE.1) THEN
        MUCUT=.TRUE.
        RETURN
      ENDIF
      NCUT(1,4)=NCUT(1,4)+1
      IF(IGOOD(2).LE.1) THEN
        MUCUT=.TRUE.
        RETURN
      ENDIF
      NCUT(1,5)=NCUT(1,5)+1
      IF(IGOOD(3).LE.1) THEN
        MUCUT=.TRUE.
        RETURN
      ENDIF
      NCUT(1,6)=NCUT(1,6)+1
      IF(IGOOD(4).LE.1) THEN
        MUCUT=.TRUE.
        RETURN
      ENDIF
      NCUT(1,7)=NCUT(1,7)+1
      RETURN
      END
+EOD.
C*********************************************************************
C
C                            M U R A W
C
C*********************************************************************
+DECK,MURAW.
      SUBROUTINE MURAW(MUCUT)
C---------------------------------------------------------------------
C    This routine fills the track bank commons /TRAKMU/ from the
C    MUREC bank.
C---------------------------------------------------------------------
+CDE,SABANKC,MUCBLNK.
+CDE,MUSTRC,HISTO.
+CDE,MUID,MUSTAT.
+CDE,MUCOUN,MYINFO.
+CDE,TRACK.
+CDE,KINEM.
      DIMENSION PLAB(4),PCM(4)
      DIMENSION IHINT(2)
      LOGICAL MUCUT,HODFLG
      MUCUT  =.FALSE.
      HODFLG =.FALSE.
C---------------------------------------------------------------------
C    Zero the track bank
C---------------------------------------------------------------------
      CALL VZERO(TRAKMU,1000)
      CALL VZERO(IRAKMU,1000)
      CALL VZERO(PMU,100)
      NMU   = 0
C---------------------------------------------------------------------
C    LMUTR:  link to track banks
C    LMUHI:  link to hit banks
C    LMUFA:  link to fasten hit banks
C    LGDTR:  link to good track banks
C---------------------------------------------------------------------
      LMUTR = LBADDR(17326,1,1)
      LMUHI = LBADDR(17426,1,1)
      LMUFA = LBADDR(17126,1,1)
      LGDTR = LBADDR(17526,1,1)
      IF(LGDTR.EQ.0) THEN
        MUCUT=.TRUE.
        RETURN
      ENDIF
C---------------------------------------------------------------------
C    Find the number of tracks (NMU)
C---------------------------------------------------------------------
      NMU = IW(LGDTR+1)
      IF(NMU.GT.10) NMU=10
      IF(JH(1).NE.0) CALL HFILL(LH(1)+1,FLOAT(NMU),0.,1.)
      IF(NMU.EQ.0) THEN
        MUCUT=.TRUE.
        RETURN
      ENDIF
C---------------------------------------------------------------------
C    Number of hits in PC0 & PC1
C---------------------------------------------------------------------
      NHIT01 = 0
      DO 15 I = 1,6
 15   NHIT01 = IW(IW(LMUHI-I)+5)+NHIT01
      TRAKMU(1,1,6) = FLOAT(NHIT01/6)
      CALL HFILL(LH(1)+0,TRAKMU(1,1,6),0.,1.)
C---------------------------------------------------------------------
C
C         Loop over all good tracks found in mu spectrometer
C
C---------------------------------------------------------------------
      DO 100 I = 1,NMU
        LGOOD=IW(LGDTR-I)
        NGOOD=IW(LGOOD+1)
        IF(NGOOD.EQ.0) GO TO 100
C---------------------------------------------------------------------
C  Track parameters of track in muon spectrometer (before muon magnet)
C---------------------------------------------------------------------
        LBTR = IW(LMUTR-NGOOD)
        TRAKMU(1,I,11) = RW(LBTR+4)
        TRAKMU(1,I,12) = RW(LBTR+5)-TRAKMU(1,I,11)*RW(LBTR+3)
        TRAKMU(1,I,13) = RW(LBTR+6)
        TRAKMU(1,I,14) = RW(LBTR+7)-TRAKMU(1,I,13)*RW(LBTR+3)
        ALPHA = TRAKMU(1,I,11)
        X0    = TRAKMU(1,I,12)
        BETA  = TRAKMU(1,I,13)
        Y0    = TRAKMU(1,I,14)
C---------------------------------------------------------------------
C  Track parameters of track in muon spectrometer (after muon magnet)
C---------------------------------------------------------------------
        TRAKMU(4,I,11) = RW(LBTR+9)
        TRAKMU(4,I,12) = RW(LBTR+10)-TRAKMU(4,I,11)*RW(LBTR+8)
        TRAKMU(4,I,13) = RW(LBTR+11)
        TRAKMU(4,I,14) = RW(LBTR+12)-TRAKMU(4,I,13)*RW(LBTR+8)
C---------------------------------------------------------------------
C    Momentum
C---------------------------------------------------------------------
        P = RW(LBTR+1)
        TRAKMU(1,I,5) = ABS(RW(LBTR+1))
        IF(TRAKMU(1,I,5).EQ.0.) GO TO 100
        DIRNOR = SQRT(ALPHA**2+BETA**2+1.)
        TRAKMU(1,I,1) = TRAKMU(1,I,5) * ALPHA / DIRNOR
        TRAKMU(1,I,2) = TRAKMU(1,I,5) * BETA  / DIRNOR
        TRAKMU(1,I,3) = TRAKMU(1,I,5) / DIRNOR
        TRAKMU(1,I,4) = SQRT(TRAKMU(1,I,1)**2+TRAKMU(1,I,2)**2)
C---------------------------------------------------------------------
C    Sign
C---------------------------------------------------------------------
        IF(YEAR.EQ.1988) THEN
           IRAKMU(1,I,10) = -1 * NINT(P/ABS(P))
        ELSE
           IRAKMU(1,I,10) = NINT(P/ABS(P))
        ENDIF
C---------------------------------------------------------------------
C    Calculate Px,Py,Pz,PT,P,Eloss,Mult. Scatt.,alpha,beta,X0,Y0
C    for tracks at the target and after the magcal
C---------------------------------------------------------------------
        CALL PTRUE(I)
C---------------------------------------------------------------------
C
C         Calculate stuff which are common to all types of tracks
C
C---------------------------------------------------------------------
C    Hodoscope information
C---------------------------------------------------------------------
        IF(.NOT.MCFLAG) THEN
           CALL MUHODT(I,HODFLG,IHINT)
           IF(HODFLG) IRAKMU(1,I,16) = 1
           NHOD=IHINT(1)+IHINT(2)
           IF(JH(1).NE.0) CALL HFILL(LH(1)+2,FLOAT(NHOD),0.,1.)
        ENDIF
C---------------------------------------------------------------------
C    Calculate closest distance to target
C---------------------------------------------------------------------
        CALL DISLP(0.,0.,0.,X0,Y0,0.,ALPHA,BETA,1.,XC,YC,ZC,RC)
        TRAKMU(1,I,7) = RC
C---------------------------------------------------------------------
C    Calculate closest distance to Z-axis and z at this point
C---------------------------------------------------------------------
        CALL DISLL
     *  (0.,0.,0.,0.,0.,1.,X0,Y0,0.,ALPHA,BETA,1.,XC,YC,ZC,RC,Z)
        TRAKMU(1,I,8) = Z
C---------------------------------------------------------------------
C    Chi square / NDF
C---------------------------------------------------------------------
        IF(RW(LBTR+2).GT.0) THEN
           TRAKMU(1,I,15) = RW(LBTR+2)
        ELSE
           TRAKMU(1,I,15) = 100000.
        ENDIF
C---------------------------------------------------------------------
C    Copy TRAKMU(1,  ) -> TRAKMU(2,  ),TRAKMU(3,  )
C---------------------------------------------------------------------
        DO 25 J=2,4
           TRAKMU(J,I,7)  = TRAKMU(1,I,7)
           TRAKMU(J,I,8)  = TRAKMU(1,I,8)
           IRAKMU(J,I,10) = IRAKMU(1,I,10)
           TRAKMU(J,I,15) = TRAKMU(1,I,15)
           TRAKMU(J,I,16) = TRAKMU(1,I,16)
 25     CONTINUE
C---------------------------------------------------------------------
C
C    Calculate stuff which are different for diff. types of tracks
C
C---------------------------------------------------------------------
        DO 55 J=1,4
C---------------------------------------------------------------------
C    Theta & Eta & Phi
C---------------------------------------------------------------------
           TRAKMU(J,I,17) =
     *     ACOS(1./SQRT(TRAKMU(J,I,13)**2 + TRAKMU(J,I,11)**2 + 1.))
           IF(TAN(TRAKMU(J,I,17)/2.).GT.0.)
     *     TRAKMU(J,I,18) = -ALOG(TAN(TRAKMU(J,I,17)/2.))
           IF(TRAKMU(J,I,11).NE.0.)
     *     TRAKMU(J,I,19) = ATAN2(TRAKMU(J,I,13),TRAKMU(J,I,11))
           IF(TRAKMU(J,I,19).LE.0.) TRAKMU(J,I,19)=TRAKMU(J,I,19)+PI2
 55     CONTINUE
C---------------------------------------------------------------------
C    Multiple scattering angle (in X & Y)
C---------------------------------------------------------------------
       TRAKMU(1,I,22) = TRAKMU(3,I,11) - TRAKMU(1,I,11)
       TRAKMU(2,I,22) = TRAKMU(3,I,13) - TRAKMU(1,I,13)
C---------------------------------------------------------------------
C    X, Y and R at ULAC face
C---------------------------------------------------------------------
       TRAKMU(1,I,21) = TRAKMU(3,I,11)*ZULAC + TRAKMU(3,I,12)
       TRAKMU(2,I,21) = TRAKMU(3,I,13)*ZULAC + TRAKMU(3,I,14)
       TRAKMU(3,I,21) = SQRT(TRAKMU(1,I,21)**2 + TRAKMU(2,I,21)**2)
C---------------------------------------------------------------------
C
C                 L A B   ->   C M S
C
C---------------------------------------------------------------------
       PMU(I,6) = MUM
       PLAB(1)  = TRAKMU(2,I,1)
       PLAB(2)  = TRAKMU(2,I,2)
       PLAB(3)  = TRAKMU(2,I,3)
       PLAB(4)  = SQRT(TRAKMU(2,I,5)**2 + MUM**2)
 
       CALL LABCMS(PLAB,PCM)
 
       PMU(I,1) = PCM(1)
       PMU(I,2) = PCM(2)
       PMU(I,3) = PCM(3)
       PMU(I,4) = PCM(4)
 
       PMU(I,5) = SQRT(PCM(1)**2 + PCM(2)**2 + PCM(3)**2)
 
       PMU(I,7) = ACOS(PMU(I,3)/PMU(I,5))
       IF(TAN(PMU(I,7)/2.).GT.0.)
     * PMU(I,8) = -ALOG(TAN(PMU(I,7)/2.))
       IF(PMU(I,4)-PMU(I,3).NE.0.) PMU(I,9) =
     * ALOG(ABS((PMU(I,4)+PMU(I,3))/(PMU(I,4)-PMU(I,3))))/2.
       PMU(I,10)= 2.*PCM(3)/TSS
C---------------------------------------------------------------------
C
C                 End loop over all good tracks
C
C---------------------------------------------------------------------
 100  CONTINUE
C---------------------------------------------------------------------
C
C                     H i s t o g r a m s
C
C---------------------------------------------------------------------
      J = JH(1)
      IF(JH(1).EQ.0) GO TO 999
      DO 777 I=1,NMU
         CALL HFILL(LH(1)+3,TRAKMU(J,I,11),0.,1.)
         CALL HFILL(LH(1)+4,TRAKMU(J,I,13),0.,1.)
         IF(TRAKMU(1,I,5).EQ.0.) GO TO 777
         CALL HFILL(LH(1)+5,TRAKMU(J,I,17),0.,1.)
         CALL HFILL(LH(1)+6,TRAKMU(J,I,18),0.,1.)
         CALL HFILL(LH(1)+7,TRAKMU(J,I,19),0.,1.)
         CALL HFILL(LH(1)+8,TRAKMU(J,I,8),0.,1.)
         CALL HFILL(LH(1)+9,TRAKMU(J,I,8),TRAKMU(J,I,7),1.)
         CALL HFILL(LH(1)+10,TRAKMU(J,I,15),0.,1.)
         CALL HFILL(LH(1)+11,TRAKMU(J,I,4),0.,1.)
         CALL HFILL(LH(1)+12,TRAKMU(J,I,5),0.,1.)
         IF(TRAKMU(1,I,20).NE.0.) THEN
            OMEGA =TRAKMU(3,I,22)/TRAKMU(1,I,20)
            OMEGAX=TRAKMU(1,I,22)/TRAKMU(1,I,20)
            OMEGAY=TRAKMU(2,I,22)/TRAKMU(1,I,20)
            CALL HFILL(LH(1)+13,OMEGA,0.,1.)
            CALL HFILL(LH(1)+14,OMEGAX,0.,1.)
            CALL HFILL(LH(1)+15,OMEGAY,0.,1.)
         ENDIF
         CALL HFILL(LH(1)+16,TRAKMU(3,I,21),0.,1.)
         CALL HFILL(LH(1)+17,TRAKMU(3,I,20),0.,1.)
         CALL HFILL(LH(1)+18,PMU(I,5),0.,1.)
         CALL HFILL(LH(1)+19,PMU(I,7),0.,1.)
         CALL HFILL(LH(1)+20,PMU(I,8),0.,1.)
         CALL HFILL(LH(1)+21,PMU(I,10),0.,1.)
 777  CONTINUE
 999  CONTINUE
C---------------------------------------------------------------------
C    Cut
C---------------------------------------------------------------------
      IF(NMU.LT.2) THEN
        MUCUT=.TRUE.
        RETURN
      ENDIF
      NCUT(1,2)=NCUT(1,2)+1
      IF(NHIT01.GT.20) THEN
        MUCUT=.TRUE.
        RETURN
      ENDIF
      NCUT(1,3)=NCUT(1,3)+1
      RETURN
      END
+EOD.
C*********************************************************************
C
C                            M U H O D T
C
C*********************************************************************
+DECK,MUHODT.
      SUBROUTINE MUHODT(I,HODFLG,IHINT)
C---------------------------------------------------------------------
C    This routine matches muon tracks with muon hodoscope slabs
C---------------------------------------------------------------------
+CDE,MUGEOH.
+CDE,TRACK.
+CDE,MUSTAT.
+CDE,MUID,MUSTRC.
+CDE,SABANKC,MUCBLNK.
      LOGICAL HODFLG
      DIMENSION ISID(2),IHINT(2)
      REAL ACCEPT(4),X(2),Y(2)
      DATA ACCEPT /0.5,0.5,0.5,0.5/
C---------------------------------------------------------------------
C    Initialization
C---------------------------------------------------------------------
      HODFLG    = .FALSE.
      IHINT(1)  = 0
      IHINT(2)  = 0
      ALPHA     = TRAKMU(4,I,11)
      X0        = TRAKMU(4,I,12)
      BETA      = TRAKMU(4,I,13)
      Y0        = TRAKMU(4,I,14)
      P         = TRAKMU(1,I,5)
C---------------------------------------------------------------------
C    Check if information available is sufficient
C---------------------------------------------------------------------
      IF(Y0.GT.1000.) RETURN
      IF(P.EQ.0.)     RETURN
C---------------------------------------------------------------------
C    Track position at hodoscopes
C---------------------------------------------------------------------
      X(1) = ALPHA*ZHOD(1) + X0
      Y(1) =  BETA*ZHOD(1) + Y0
      X(2) = ALPHA*ZHOD(2) + X0
      Y(2) =  BETA*ZHOD(2) + Y0
C---------------------------------------------------------------------
C    Distance between the two points
C---------------------------------------------------------------------
      ZL = SQRT( (X(1)-X(2))**2+(Y(1)-Y(2))**2+(ZHOD(2)-ZHOD(1))**2 )
C---------------------------------------------------------------------
C    Distance that the muon spent inside the iron wall
C---------------------------------------------------------------------
      ZL = ZL*80./(ZHOD(2)-ZHOD(1))
C---------------------------------------------------------------------
C    Multiple scattering angle error in one dimension
C---------------------------------------------------------------------
      TRL = ZL/1.76
      OMEGA = 0.014*SQRT(TRL)*(1.+ALOG10(TRL)/9.)/P
C---------------------------------------------------------------------
C    Acceptance bounderies for the track
C---------------------------------------------------------------------
      ACCEPT(2) = (ZHOD(2)-ZHOD(1))*TAN(ALPHA+2.*OMEGA) - (X(2)-X(1))
      ACCEPT(2) = AMAX1(.5,ACCEPT(2))
      ACCEPT(4) = (ZHOD(2)-ZHOD(1))*TAN(BETA+2.*OMEGA)  - (Y(2)-Y(1))
      ACCEPT(4) = AMAX1(.5,ACCEPT(4))
C---------------------------------------------------------------------
C
C                    Loop over both hodoscope walls
C
C---------------------------------------------------------------------
      DO 2 IH=1,2
C---------------------------------------------------------------------
C    Get total number of slabs in the wall
C---------------------------------------------------------------------
         NL=NHLAT(IH)
C---------------------------------------------------------------------
C    Check if we are within the wall area in X
C    (note that the wall is divided into only two parts in X)
C---------------------------------------------------------------------
         XL = X(IH)-ACCEPT(IH+2)
         XH = X(IH)+ACCEPT(IH+2)
         XMAX=XMINH(IH)+2.*XLHOD(IH)
         IF(XH.GE.XMINH(IH).AND.XL.LE.XMAX) THEN
C---------------------------------------------------------------------
C    Check if we are within the wall area in Y
C---------------------------------------------------------------------
            YL = Y(IH)-ACCEPT(IH)
            YH = Y(IH)+ACCEPT(IH)
            IF(YH.GE.YHINF(1,IH).AND.YL.LE.YHINF(NL+1,IH)) THEN
C---------------------------------------------------------------------
C
C                    Loop over all slabs in the wall
C
C---------------------------------------------------------------------
C   Get the # of the slab (ILAT1) that the lower boundary (YL) goes
C   through and the same thing (ILAT2) for the higher boundary (YH).
C---------------------------------------------------------------------
               ILAT1  = 1
               ILAT2  = NL
               DO 3 KL= 1,NL
                  IF(YL.GT.YHINF(KL,IH).AND.YL.LT.YHINF(KL+1,IH))
     *            ILAT1 = KL
                  IF(YH.GT.YHINF(KL,IH).AND.YH.LT.YHINF(KL+1,IH))
     *            ILAT2 = KL
 3             CONTINUE
C---------------------------------------------------------------------
C
C                    End of hodoscope loop
C
C---------------------------------------------------------------------
C    Check if the low and high boundary in X (XL & XH) goes through
C    the same slab (NXSID = 1) or different slabs (NXSID = 2).
C---------------------------------------------------------------------
               ISID(1) = SIGN(1.,XL)
               ISID(2) = SIGN(1.,XH)
               NXSID = 2
               IF(ISID(1).EQ.ISID(2)) NXSID = 1
C---------------------------------------------------------------------
C
C                    Loop over the two sides in X
C
C---------------------------------------------------------------------
               DO 4 NSID = 1,NXSID
                  JS = (ISID(NSID)+1)/2 + 1
C---------------------------------------------------------------------
C    Unpack hodoscope hit bank
C---------------------------------------------------------------------
                  IADR=LBADDR(18117,IH,1)
                  IF(IADR.GT.0) THEN
                     NHOD=IW(IADR+JS)
                     IF(NHOD.GT.0) THEN
                        LO=IADR+LEFDHO+(JS-1)*IW(IADR+1)*LENHOD
                        IHINT(IH) = 0
C---------------------------------------------------------------------
C
C                    Loop over hodoscope hits
C
C---------------------------------------------------------------------
                        DO 5 JL=1,NHOD
                           LOP=LO+(JL-1)*LENHOD+1
                           NNHH = IW(LOP)
                           IF(NNHH.GE.ILAT1.AND.NNHH.LE.ILAT2) THEN
                              IHINT(IH) = 1
                           END IF
 5                      CONTINUE
C---------------------------------------------------------------------
C
C                    End of hodoscope hit loop
C
C---------------------------------------------------------------------
                     END IF
                  ELSE
                     WRITE(6,*) 'MUHODT, SHIT NO HODO BANKS'
                  END IF
 4             CONTINUE
C---------------------------------------------------------------------
C
C                    End of side loop
C
C---------------------------------------------------------------------
            END IF
         END IF
 2    CONTINUE
C---------------------------------------------------------------------
C
C                    End of hodoscope loop
C
C---------------------------------------------------------------------
      IF(IHINT(1).EQ.1.AND.IHINT(2).EQ.1) HODFLG = .TRUE.
      RETURN
      END
+EOD.
C*********************************************************************
C
C                            M U F I X
C
C*********************************************************************
+DECK,MUFIX.
      SUBROUTINE MUFIX
C---------------------------------------------------------------------
C    This routine recalculates the track parameters for the tracks
C    before the dump.
C---------------------------------------------------------------------
+CDE,SABANKC,MUCBLNK.
+CDE,MUSTRC,HISTO.
+CDE,MUID,MUSTAT.
+CDE,MUCOUN,MYINFO.
+CDE,TRACK.
+CDE,KINEM.
      DIMENSION PLAB(4),PCM(4)
C---------------------------------------------------------------------
C
C         Loop over all good tracks found in mu spectrometer
C
C---------------------------------------------------------------------
      DO 100 I = 1,NMU
        IF(TRAKMU(1,I,5).EQ.0.) GO TO 100
C---------------------------------------------------------------------
C    Calculate Px,Py,Pz,PT,P,Eloss,Mult. Scatt.,alpha,beta,X0,Y0
C    for tracks at the target and after the magcal
C---------------------------------------------------------------------
        CALL PTRUE(I)
C---------------------------------------------------------------------
C
C    Calculate stuff which are different for diff. types of tracks
C
C---------------------------------------------------------------------
        DO 55 J=2,3
C---------------------------------------------------------------------
C    Theta & Eta & Phi
C---------------------------------------------------------------------
           TRAKMU(J,I,17) =
     *     ACOS(1./SQRT(TRAKMU(J,I,13)**2 + TRAKMU(J,I,11)**2 + 1.))
           IF(TAN(TRAKMU(J,I,17)/2.).GT.0.)
     *     TRAKMU(J,I,18) = -ALOG(TAN(TRAKMU(J,I,17)/2.))
           IF(TRAKMU(J,I,11).NE.0.)
     *     TRAKMU(J,I,19) = ATAN2(TRAKMU(J,I,13),TRAKMU(J,I,11))
           IF(TRAKMU(J,I,19).LE.0.) TRAKMU(J,I,19)=TRAKMU(J,I,19)+PI2
 55     CONTINUE
C---------------------------------------------------------------------
C    Multiple scattering angle (in X & Y)
C---------------------------------------------------------------------
       TRAKMU(1,I,22) = TRAKMU(3,I,11) - TRAKMU(1,I,11)
       TRAKMU(2,I,22) = TRAKMU(3,I,13) - TRAKMU(1,I,13)
C---------------------------------------------------------------------
C    X, Y and R at ULAC face
C---------------------------------------------------------------------
       TRAKMU(1,I,21) = TRAKMU(3,I,11)*ZULAC + TRAKMU(3,I,12)
       TRAKMU(2,I,21) = TRAKMU(3,I,13)*ZULAC + TRAKMU(3,I,14)
       TRAKMU(3,I,21) = SQRT(TRAKMU(1,I,21)**2 + TRAKMU(2,I,21)**2)
C---------------------------------------------------------------------
C
C                 L A B   ->   C M S
C
C---------------------------------------------------------------------
       PMU(I,6) = MUM
       PLAB(1)  = TRAKMU(2,I,1)
       PLAB(2)  = TRAKMU(2,I,2)
       PLAB(3)  = TRAKMU(2,I,3)
       PLAB(4)  = SQRT(TRAKMU(2,I,5)**2 + MUM**2)
 
       CALL LABCMS(PLAB,PCM)
 
       PMU(I,1) = PCM(1)
       PMU(I,2) = PCM(2)
       PMU(I,3) = PCM(3)
       PMU(I,4) = PCM(4)
 
       PMU(I,5) = SQRT(PCM(1)**2 + PCM(2)**2 + PCM(3)**2)
 
       PMU(I,7) = ACOS(PMU(I,3)/PMU(I,5))
       IF(TAN(PMU(I,7)/2.).GT.0.)
     * PMU(I,8) = -ALOG(TAN(PMU(I,7)/2.))
       IF(PMU(I,4)-PMU(I,3).NE.0.) PMU(I,9) =
     * ALOG(ABS((PMU(I,4)+PMU(I,3))/(PMU(I,4)-PMU(I,3))))/2.
       PMU(I,10)= 2.*PCM(3)/TSS
C---------------------------------------------------------------------
C
C                 End loop over all good tracks
C
C---------------------------------------------------------------------
 100  CONTINUE
      RETURN
      END
+EOD.
C*********************************************************************
C
C                            M U P O I N
C
C*********************************************************************
+DECK,MUPOIN.
      SUBROUTINE MUPOIN
C---------------------------------------------------------------------
C    This routine fills the label 7807 which is used by the DC
C    reconstruction program.
C---------------------------------------------------------------------
C    The label is filled by the pointer array POINT(I) which contains;
C
C    I=1     Alpha
C    I=2     X0
C    I=3     Beta
C    I=4     Y0
C    I=5
C    I=6     Radius of the tube around the muon track were DC tracks
C            will be recontructed
C    I=7     P in lab with sign
C    I=8
C    I=9
C    I=10    Track type: 1-electron   2-muon
C
C---------------------------------------------------------------------
+CDE,MYINFO.
+CDE,TRACK.
      REAL POINT(10)
      CALL VZERO(POINT,10)
C---------------------------------------------------------------------
C     Loop over all muon tracks
C---------------------------------------------------------------------
      DO 40 I=1,NMU
C---------------------------------------------------------------------
C    Only use tracks that have passed the quality requirement
C---------------------------------------------------------------------
         IF(IRAKMU(1,I,9).NE.1) GO TO 40
C---------------------------------------------------------------------
C     Fill the DC pointer label 7807 (one label for each track).
C---------------------------------------------------------------------
         POINT(1) = TRAKMU(3,I,11)
         POINT(2) = TRAKMU(3,I,12)
         POINT(3) = TRAKMU(3,I,13)
         POINT(4) = TRAKMU(3,I,14)
         POINT(5) = 0.0
         ERROR    = 4. * TRAKMU(2,I,20) *  ZULAC
         POINT(6) = AMAX1(1.0,ERROR)
         POINT(7) = FLOAT(IRAKMU(3,I,10)) * TRAKMU(3,I,5)
         POINT(8) = 0.0
         POINT(9) = 0.0
         POINT(10)= 2.0
C---------------------------------------------------------------------
C     Write out the label 7807 (one label for each track).
C---------------------------------------------------------------------
         LENGTH   = 10
         LABEL    = 7807
         CALL LBSTOR(LABEL,POINT,LENGTH)
 40   CONTINUE
      RETURN
      END
+EOD.
C*********************************************************************
C
C                            P O D U M P
C
C*********************************************************************
+DECK,PODUMP.
      SUBROUTINE PODUMP
C---------------------------------------------------------------------
C    This routine unpacks and dumps muon pointer labels
C---------------------------------------------------------------------
+CDE,MYINFO.
+CDE,TRACK.
      REAL POINT(10)
C---------------------------------------------------------------------
C     Calculate the number of good tracks
C---------------------------------------------------------------------
      IGOOD = 0
      DO 10 I=1,NMU
 10   IF(IRAKMU(1,I,9).EQ.1) IGOOD = IGOOD + 1
      IF(IGOOD.EQ.0) RETURN
C---------------------------------------------------------------------
C     Unpack the muon pointer labels 7807
C---------------------------------------------------------------------
      DO 20 I=1,IGOOD
         CALL VZERO(POINT,10)
         LABEL  = 7807
         IF(LBLENG(LABEL,I).EQ.0) CALL LSTOP(LABEL)
         LENGTH = 10
         CALL LBCOPY(LABEL,POINT,LENGTH,I)
C---------------------------------------------------------------------
C    Dump the POINT array
C---------------------------------------------------------------------
         WRITE(6,103) (POINT(J),J=1,5)
 103     FORMAT(1X,60('*'),/,1X,'POINT: ',5F9.4)
         WRITE(6,104) (POINT(J),J=6,10)
 104     FORMAT(1X,'POINT: ',5F9.4)
 20   CONTINUE
      RETURN
      END
+EOD.
C*********************************************************************
C
C                            D C D U M P
C
C*********************************************************************
+DECK,DCDUMP.
      SUBROUTINE DCDUMP
C---------------------------------------------------------------------
C    This routine dumps the contents in common /TRAKDC/.
C---------------------------------------------------------------------
+CDE,MYINFO.
+CDE,TRACK.
C---------------------------------------------------------------------
C     Loop over track type
C---------------------------------------------------------------------
      WRITE(6,*)' *******************************************************
     *******'
      DO 88 J=1,5
      WRITE(6,1) J
      WRITE(6,2)
C---------------------------------------------------------------------
C     Loop over tracks
C---------------------------------------------------------------------
         DO 77 I=1,NDC
            X0 = TRAKDC(J,I,12)
            Y0 = TRAKDC(J,I,14)
            SX = 1000.*TRAKDC(J,I,11)
            SY = 1000.*TRAKDC(J,I,13)
            IG = IRAKDC(J,I,10)
            PL = TRAKDC(J,I,5)
            PC = PDC(2,I,5)
            IQ = IRAKDC(J,I,16)
            WRITE(6,3) I,SX,X0,SY,Y0,IG,PL,PC,IQ
 77      CONTINUE
 88   CONTINUE
C---------------------------------------------------------------------
C     Format statements
C---------------------------------------------------------------------
 1    FORMAT(/,'         TRACK TYPE:',I2)
 2    FORMAT('   #  ALPHA    X0    BETA   Y0    S P-LAB  P-CM  FLAG')
 3    FORMAT(1X,I3,F7.1,F7.2,F7.1,F7.2,I3,2F6.1,2X,I3)
      RETURN
      END
+EOD.
C*********************************************************************
C
C                            M U D U M P
C
C*********************************************************************
+DECK,MUDUMP.
      SUBROUTINE MUDUMP
C---------------------------------------------------------------------
C    This routine dumps the contents in common /TRAKMU/.
C---------------------------------------------------------------------
+CDE,MYINFO.
+CDE,TRACK.
C---------------------------------------------------------------------
C     Loop over track type
C---------------------------------------------------------------------
      WRITE(6,*)' *******************************************************
     *******'
      DO 88 J=1,4
      WRITE(6,1) J
      WRITE(6,2)
C---------------------------------------------------------------------
C     Loop over tracks
C---------------------------------------------------------------------
         DO 77 I=1,NMU
            X0 = TRAKMU(J,I,12)
            Y0 = TRAKMU(J,I,14)
            SX = 1000.*TRAKMU(J,I,11)
            SY = 1000.*TRAKMU(J,I,13)
            IG = IRAKMU(J,I,10)
            PL = TRAKMU(J,I,5)
            PC = PMU(I,5)
            IQ = IRAKMU(J,I,9)
            IDC = IRAKMU(J,I,24)
            SIG = TRAKMU(J,I,23)
            R   = TRAKMU(J,I,7)
            CPA = TRAKMU(J,I,8)
            FACT=1.
            IF(J.LE.2) FACT=1000.
            EM = FACT*TRAKMU(J,I,20)
            WRITE(6,3) I,SX,X0,SY,Y0,IG,PL,PC,IQ,EM,IDC,SIG,R,CPA
 77      CONTINUE
 88   CONTINUE
C---------------------------------------------------------------------
C     Format statements
C---------------------------------------------------------------------
 1    FORMAT(/,'         TRACK TYPE:',I2)
 2    FORMAT('   #  ALPHA    X0    BETA   Y0    S P-LAB  P-CM  Q  ERROR
     *DC SIGMA    R   CPA')
 3    FORMAT(1X,I3,F7.1,F7.2,F7.1,F7.2,I3,F6.1,F6.2,I3,F7.1,I3,F7.1,
     *       F5.0,F6.0)
      RETURN
      END
+EOD.
C*********************************************************************
C
C                            N E W L A B
C
C*********************************************************************
+DECK,NEWLAB.
      SUBROUTINE NEWLAB
C---------------------------------------------------------------------
C    This routine fills the labels 50017 & 50027 from the
C    track bank commons in /TRAKMU/.
C---------------------------------------------------------------------
+CDE,MYINFO.
+CDE,TRACK.
      DIMENSION XBUF(1001)
C---------------------------------------------------------------------
C     Fill the muon DST label 50017
C---------------------------------------------------------------------
      CALL VZERO(XBUF,1001)
      XBUF(1) = FLOAT(NMU)
      LENGTH  = 4 * NMU * 25 + 1
      N       = 1
      DO 88 J=1,4
         DO 77 I=1,NMU
            DO 66 K=1,25
               N = N + 1
               XBUF(N) = TRAKMU(J,I,K)
 66         CONTINUE
 77      CONTINUE
 88   CONTINUE
      CALL LBSTOR(50017,XBUF,LENGTH,0,1)
C---------------------------------------------------------------------
C     Fill the muon DST label 50027
C---------------------------------------------------------------------
      CALL VZERO(XBUF,1001)
      LENGTH = NMU * 10
      N      = 0
      DO 78 I=1,NMU
         DO 67 K=1,10
            N = N + 1
            XBUF(N) = PMU(I,K)
 67      CONTINUE
 78   CONTINUE
      CALL LBSTOR(50027,XBUF,LENGTH,0,1)
      RETURN
      END
+EOD.
C*********************************************************************
C
C                            M U D S T
C
C*********************************************************************
+DECK,MUDST.
      SUBROUTINE MUDST(MUCUT)
C---------------------------------------------------------------------
C    This routine fills the track bank commons /TRAKMU/ from
C    label 50017 & 50027.
C---------------------------------------------------------------------
+CDE,HISTO.
+CDE,MYINFO.
+CDE,TRACK.
      DIMENSION XBUF(1001)
      LOGICAL MUCUT
      MUCUT =.FALSE.
C---------------------------------------------------------------------
C    Zero the track bank
C---------------------------------------------------------------------
      CALL VZERO(TRAKMU,1000)
      CALL VZERO(IRAKMU,1000)
      CALL VZERO(PMU,100)
      NMU   = 0
C---------------------------------------------------------------------
C     Unpack the muon DST label 50017
C---------------------------------------------------------------------
      LABEL  = 50017
      IF(LBLENG(LABEL).EQ.0) CALL LSTOP(LABEL)
      LENGTH = 1001
      CALL LBCOPY(LABEL,XBUF,LENGTH)
      NMU    = XBUF(1)
      IF(NMU.EQ.0) THEN
        MUCUT=.TRUE.
        RETURN
      ENDIF
      N = 1
      DO 88 J=1,4
         DO 77 I=1,NMU
            DO 66 K=1,25
               N = N + 1
               TRAKMU(J,I,K) = XBUF(N)
 66         CONTINUE
 77      CONTINUE
 88   CONTINUE
C---------------------------------------------------------------------
C     Unpack the muon DST label 50027
C---------------------------------------------------------------------
      CALL VZERO(XBUF,1001)
      LABEL  = 50027
      IF(LBLENG(LABEL).EQ.0) CALL LSTOP(LABEL)
      LENGTH   = NMU * 10
      CALL LBCOPY(LABEL,XBUF,LENGTH)
      N = 0
      DO 78 I=1,NMU
         DO 67 K=1,10
            N = N + 1
            PMU(I,K) = XBUF(N)
 67      CONTINUE
 78   CONTINUE
C---------------------------------------------------------------------
C    Number of hits in PC0 & PC1
C---------------------------------------------------------------------
      CALL HFILL(LH(1)+0,TRAKMU(1,1,6),0.,1.)
C---------------------------------------------------------------------
C    Plot a histogram with the # of tracks (NMU)
C---------------------------------------------------------------------
      IF(JH(1).NE.0) CALL HFILL(LH(1)+1,FLOAT(NMU),0.,1.)
C---------------------------------------------------------------------
C
C                     H i s t o g r a m s
C
C---------------------------------------------------------------------
      J = JH(1)
      IF(JH(1).EQ.0) GO TO 999
      DO 777 I=1,NMU
         IF(TRAKMU(1,I,5).EQ.0.) GO TO 777
         CALL HFILL(LH(1)+3,TRAKMU(J,I,11),0.,1.)
         CALL HFILL(LH(1)+4,TRAKMU(J,I,13),0.,1.)
         CALL HFILL(LH(1)+5,TRAKMU(J,I,17),0.,1.)
         CALL HFILL(LH(1)+6,TRAKMU(J,I,18),0.,1.)
         CALL HFILL(LH(1)+7,TRAKMU(J,I,19),0.,1.)
         CALL HFILL(LH(1)+8,TRAKMU(J,I,8),0.,1.)
         CALL HFILL(LH(1)+9,TRAKMU(J,I,8),TRAKMU(J,I,7),1.)
         CALL HFILL(LH(1)+10,TRAKMU(J,I,15),0.,1.)
         CALL HFILL(LH(1)+11,TRAKMU(J,I,4),0.,1.)
         CALL HFILL(LH(1)+12,TRAKMU(J,I,5),0.,1.)
         IF(TRAKMU(1,I,20).NE.0.) THEN
            OMEGA =TRAKMU(3,I,22)/TRAKMU(1,I,20)
            OMEGAX=TRAKMU(1,I,22)/TRAKMU(1,I,20)
            OMEGAY=TRAKMU(2,I,22)/TRAKMU(1,I,20)
            CALL HFILL(LH(1)+13,OMEGA,0.,1.)
            CALL HFILL(LH(1)+14,OMEGAX,0.,1.)
            CALL HFILL(LH(1)+15,OMEGAY,0.,1.)
         ENDIF
         CALL HFILL(LH(1)+16,TRAKMU(3,I,21),0.,1.)
         CALL HFILL(LH(1)+17,TRAKMU(3,I,20),0.,1.)
         CALL HFILL(LH(1)+18,PMU(I,5),0.,1.)
         CALL HFILL(LH(1)+19,PMU(I,7),0.,1.)
         CALL HFILL(LH(1)+20,PMU(I,8),0.,1.)
         CALL HFILL(LH(1)+21,PMU(I,10),0.,1.)
 777  CONTINUE
 999  CONTINUE
C---------------------------------------------------------------------
C    Cut
C---------------------------------------------------------------------
      IF(NMU.LT.2) THEN
        MUCUT=.TRUE.
        RETURN
      ENDIF
      NCUT(1,2)=NCUT(1,2)+1
      IF(TRAKMU(1,1,6).GT.20.) THEN
        MUCUT=.TRUE.
        RETURN
      ENDIF
      NCUT(1,3)=NCUT(1,3)+1
      RETURN
      END
+EOD.
C*********************************************************************
C
C                            P T R U E
C
C*********************************************************************
+DECK,PTRUE.
      SUBROUTINE PTRUE(I)
C---------------------------------------------------------------------
C
C   Corrects muon track parameters for multiple scattering using
C   a type of Branson plane method and calculates the energy loss
C   by using Richard-Serre formulae.
C
C---------------------------------------------------------------------
C
C In:  I                  :  Track #
C      TRK(1)             :  X0    measured in muon spectrometer
C      TRK(2)             :  Alpha measured in muon spectrometer
C      TRK(3)             :  Y0    measured in muon spectrometer
C      TRK(4)             :  Beta  measured in muon spectrometer
C
C Calculated:
C      ZBRAN              :  Z of Branson plane
C      PLOSS              :  Energy loss in the calorimeter
C
C Constants:
C   ITYPE(I)   :  CALORIMETER NUMBER I IS OF TYPE "ITYPE(I)" WHERE
C                 1=UCAL EM   2=UCAL HAD U/CU   3=UCAL HAD U
C                 4=ULAC EM   5=ULAC HAD
C   ZIN(I)     :  BEGINNING OF CALORIMETER NUMBER I
C   ZOU(I)     :  END OF CALORIMETER NUMBER I
C   ITYPE(I)   :  TYPE OF CALORIMETER I
C   XWID(I)    :  WIDTH OF CALORIMETER I
C   XU(I)      :  WIDTH  OF FULL URANIUM PART OF CALO I
C   WEIGHT(J,I):  WEIGHT OF MATERIAL J IN CAL. TYPE I
C   RADLEN(I)  :  THICKNESS IN NUMBER OF RADIATION LENGTH OF CAL. I
C   DEM        :  THICKNESS OF EM UCAL IN CM
C   DHD        :  THICKNESS OF HAD UCAL IN CM
C   DEMULA     :  THICKNESS OF EM ULAC IN CM
C   DHDULA     :  THICKNESS OF HAD ULAC IN CM
C   DVETO      :  THICKNESS OF VETO CAL. IN CM
C   DTOT       :  TOTAL THICKNESS IN CM IN CM
C
C---------------------------------------------------------------------
+CDE,MUSTAT,MYINFO.
+CDE,TRACK.
       DIMENSION ZIN(6),ZOU(6),XWID(6),XS(6),XU(6),WEIGHT(10,6),
     * RADLEN(5),ISTEP(6),ITYPE(6)
       DIMENSION TRK(4)
       DATA DEM,DHD,DEMULA,DHDULA,DVETO /5.3,74.7,30.33,110.795,40./
       DATA RADLEN  /6.382,85.994,119.206,18.445,133.525/
       DATA ISTEP   /8,80,8,80,20,20/
       DATA WEIGHT  /60*0./
       DATA ITYPE   /4,5,1,2,0,0/
       DATA XU      /3.5,0.,0.,10.,2.5,2.5/
       DATA XS      /0.,0.,0.,0.,10.,-10./
C---------------------------------------------------------------------
C
C                    Calculate the Branson plane
C
C---------------------------------------------------------------------
       DATA INIT    /0/
       IF(INIT.NE.0) GOTO 1
C---------------------------------------------------------------------
C    WEIGHT FOR UCAL, EM PART (TYPE = 1)
C---------------------------------------------------------------------
       WEIGHT(4,1) = 10.*.2/DEM
       RADLEN(1) = RADLEN(1)/DEM
C---------------------------------------------------------------------
C    WEIGHT FOR  U/CU CALO, HADRONIC PART (TYPE = 2)
C---------------------------------------------------------------------
       WEIGHT(4,2) = 76.*.3/DHD
       WEIGHT(5,2) = 38.*.5/DHD
       RADLEN(2) = RADLEN(2)/DHD
C---------------------------------------------------------------------
C    WEIGHT FOR  FULL U CALO, HADRONIC PART (TYPE = 3)
C---------------------------------------------------------------------
       WEIGHT(4,3) = 125.*.3/DHD
       RADLEN(3) = RADLEN(3)/DHD
C---------------------------------------------------------------------
C    WEIGHT FOR  ULAC CALO, EM PART (TYPE = 4)
C---------------------------------------------------------------------
       WEIGHT(4,4) = .154
       WEIGHT(6,4) = .476
       RADLEN(4) = RADLEN(4)/DEMULA
C---------------------------------------------------------------------
C    WEIGHT FOR  ULAC CALO, HAD PART (TYPE = 5)
C---------------------------------------------------------------------
       WEIGHT(4,5) = .365
       WEIGHT(6,5) = .441
       RADLEN(5) = RADLEN(5)/DHDULA
C---------------------------------------------------------------------
C    Total lenght of scattering medium
C---------------------------------------------------------------------
       DTOT = DEM+DHD+DVETO+DEMULA+DHDULA
C---------------------------------------------------------------------
C    The Branson plane
C---------------------------------------------------------------------
       ZBRAN  = 0.
       BNORM  = 0.
 
       ZIN(1) = ZULAC
       ZOU(1) = ZIN(1)+ DEMULA
       ZBRAN  = ZBRAN + (ZIN(1)+DEMULA/2.)*RADLEN(4)*DEMULA
       BNORM  = BNORM + RADLEN(4)*DEMULA
 
       ZIN(2) = ZOU(1)
       ZOU(2) = ZIN(2)+ DHDULA
       ZBRAN  = ZBRAN + (ZIN(2)+DHDULA/2.)*RADLEN(5)*DHDULA
       BNORM  = BNORM + RADLEN(5)*DHDULA
 
       ZIN(3) = ZBEAM
       ZOU(3) = ZIN(3)+ DEM
       ZBRAN  = ZBRAN + (ZIN(3)+DEM/2.)*RADLEN(1)*DEM
       BNORM  = BNORM + RADLEN(1)*DEM
 
       ZIN(4) = ZOU(3)
       ZOU(4) = ZIN(4)+ DHD
       ZBRAN  = ZBRAN + (ZIN(4)+DHD/2.)*RADLEN(3)*DHD
       BNORM  = BNORM + RADLEN(3)*DHD
 
       ZIN(5) = ZVETO
       ZOU(5) = ZIN(5)+ 20.
       ZIN(6) = ZOU(5)
       ZOU(6) = ZIN(6)+ 20.
       ZBRAN  = ZBRAN + (ZIN(5)+DVETO/2.)*RADLEN(2)*DVETO
       BNORM  = BNORM + RADLEN(2)*DVETO
 
       ZBRAN  = ZBRAN / BNORM
C---------------------------------------------------------------------
C   Get Zbest which is Z at the optimum place for estimation of
C   tracks coming from the target.
C   Reference: WA75/78 note 0119A by G. Carboni
C---------------------------------------------------------------------
       ZTOT    = ZOU(6)-ZIN(1)
       PPAR    = ( ZTOT/(ZBRAN-ZTARG) )**2 / 12.
       PPAR1   = 1./(1.+PPAR)
       ZBEST   = (ZBRAN - ZTARG)/PPAR1 + ZTARG
       PPAR2   = SQRT(PPAR/(1.+PPAR))
C---------------------------------------------------------------------
C   Print out the different stuff
C---------------------------------------------------------------------
       WRITE(6,*) ' TOTAL THICKNESS IN NUMBER OF RAD. LENGHT: ',BNORM
       WRITE(6,*) ' Z OF BRANSON PLANE:                       ',ZBRAN
       WRITE(6,*) ' Z OF BEST TRACK ESTIMATOR:                ',ZBEST
 
       INIT = 1
  1    CONTINUE
C---------------------------------------------------------------------
C
C               Calculate momentum via the Branson plane
C
C---------------------------------------------------------------------
       TRK(1) = TRAKMU(1,I,12)
       TRK(2) = TRAKMU(1,I,11)
       TRK(3) = TRAKMU(1,I,14)
       TRK(4) = TRAKMU(1,I,13)
 
       POLD    = TRAKMU(1,I,5)
       PLOSS   = 3.2
 
       THMS   = 0.
C---------------------------------------------------------------------
C   Get XBEST and YBEST by extrapolation of muon to ZBEST
C---------------------------------------------------------------------
       XBEST = TRK(1)+TRK(2)*ZBEST
       YBEST = TRK(3)+TRK(4)*ZBEST
C---------------------------------------------------------------------
C
C                  Make two iterations
C
C---------------------------------------------------------------------
C   1. Use the average energy loss to estimate the bending through
C      magcal, and determine energy loss along this track.
C   2. Use the energy loss calculated in the first iteration.
C---------------------------------------------------------------------
       DO 50 ITERA = 1,2
C---------------------------------------------------------------------
C   Track parameters in Y at target
C---------------------------------------------------------------------
          SYC  = YBEST / (ZBEST - ZTARG)
          Y0C  = -YBEST * ZTARG / (ZBEST - ZTARG)
C---------------------------------------------------------------------
C   Track parameters in Y after magcal
C---------------------------------------------------------------------
          SY   = SYC
          Y0   = Y0C
C---------------------------------------------------------------------
C   Track parameters in X at target
C---------------------------------------------------------------------
          XMM  = (ZBEST-ZM)*PKICKM/(POLD+PLOSS)*FLOAT(IRAKMU(1,I,10))
          SXC  = (XBEST-XMM)/(ZBEST-ZTARG)
          X0C  = -SXC * ZTARG
C---------------------------------------------------------------------
C   Track parameters in X after magcal
C---------------------------------------------------------------------
          XCOR = -(ZM-ZTARG)*PKICKM/(POLD+PLOSS)*FLOAT(IRAKMU(1,I,10))
          SX   = (XBEST-XCOR)/(ZBEST-ZTARG)
          X0   = XBEST-SX*ZBEST
C---------------------------------------------------------------------
C   Compute the multiple scattering angle
C---------------------------------------------------------------------
          FDEN = SQRT(TRK(2)**2+TRK(4)**2+1.)
          DEN  = SQRT(SX**2+SY**2+1.)
          DENC = SQRT(SXC**2+SYC**2+1.)
          CS   = (1.+TRK(2)*SX+TRK(4)*SY)/DEN/FDEN
          IF(CS.GT.1.) CS=1.
          THMS = ACOS(CS)
C---------------------------------------------------------------------
C    Compute the enery loss by using the estimated production angle
C    theta from DEN=1/COS(THETA). Step backwards from the spectro.:
C         VETO2->VETO1->BEAM(HD)->BEAM(EM)->ULAC(HD)->ULAC(EM)
C---------------------------------------------------------------------
          TRL   = 0.
          PNEW  = POLD
C---------------------------------------------------------------------
C
C                   Loop over all 6 calorimeters
C
C---------------------------------------------------------------------
          DO 100 ICALO = 6,1,-1
            ZSTEP = (ZOU(ICALO)-ZIN(ICALO))/FLOAT(ISTEP(ICALO))
C---------------------------------------------------------------------
C
C                       Step over each calorimeter
C
C---------------------------------------------------------------------
            DO 200 J = 1,ISTEP(ICALO)
               RL    = 0.
               ZZ    = ZOU(ICALO) - FLOAT(J)*ZSTEP
               XX    = ZZ*SX + XCOR
C---------------------------------------------------------------------
C     VETO CALORIMETERS: IRON INSERT(FEINS),AL PLATE(2.CM),EM,HD.
C---------------------------------------------------------------------
               IF(ICALO.GT.4) THEN
                  IF(ABS(XX-XS(ICALO)).LT.FEINS) THEN
                     PNEW = PNEW
     *             + (ELOSS(PNEW,2,1)+ELOSS(PNEW,2,2))
     *                *ZSTEP*DEN
                     RL = 1/1.76*ZSTEP*DEN
                     TRL = TRL + RL
                  ELSE IF(ABS(XX-XS(ICALO)).LT.(FEINS+2.)) THEN
                     PNEW = PNEW
     *             + (ELOSS(PNEW,1,1)+ELOSS(PNEW,1,2))
     *                *ZSTEP*DEN
                     RL = 1/8.893*ZSTEP*DEN
                     TRL = TRL + RL
                  ELSE IF(ABS(XX-XS(ICALO)).LT.(FEINS+2.+DEM)) THEN
                     PNEW = PNEW
     *             + (ELOSS(PNEW,4,1)+ELOSS(PNEW,4,2))
     *                *ZSTEP*DEN*WEIGHT(4,1)
                     RL = RADLEN(1)*ZSTEP*DEN
                     TRL = TRL + RL
                  ELSE IF(ABS(XX-XS(ICALO)).LT.(FEINS+2.+DEM+DHD)) THEN
                     PNEW = PNEW
     *             + (ELOSS(PNEW,4,1)+ELOSS(PNEW,4,2))
     *                *ZSTEP*DEN*WEIGHT(4,2)
     *             + (ELOSS(PNEW,5,1)+ELOSS(PNEW,5,2))
     *                *ZSTEP*DEN*WEIGHT(5,2)
                     RL = RADLEN(2)*ZSTEP*DEN
                     TRL = TRL + RL
                  END IF
C---------------------------------------------------------------------
C     UCAL
C---------------------------------------------------------------------
               ELSE IF(ICALO.GT.2) THEN
                  IF(ABS(XX-XS(ICALO)).GT.XU(ICALO).OR.
     *                    ITYPE(ICALO).EQ.1)              THEN
                     PNEW = PNEW
     *                    + (ELOSS(PNEW,4,1)+ELOSS(PNEW,4,2))
     *                    * ZSTEP*DEN*WEIGHT(4,ITYPE(ICALO))
     *                    + (ELOSS(PNEW,5,1)+ELOSS(PNEW,5,2))
     *                    * ZSTEP*DEN*WEIGHT(5,ITYPE(ICALO))
                     RL = RADLEN(ITYPE(ICALO))*ZSTEP*DEN
                     TRL = TRL + RL
                  ELSE
                     PNEW = PNEW
     *                    + (ELOSS(PNEW,4,1)+ELOSS(PNEW,4,2))
     *                    * ZSTEP*DEN*WEIGHT(4,3)
                     RL = RADLEN(3)*ZSTEP*DEN
                     TRL = TRL + RL
                  END IF
C---------------------------------------------------------------------
C     ULAC
C---------------------------------------------------------------------
               ELSE IF(ICALO.LE.2) THEN
                  IF(ABS(XX-XS(ICALO)).GT.XU(ICALO)) THEN
                     PNEW = PNEW
     *                    + (ELOSS(PNEW,4,1)+ELOSS(PNEW,4,2))
     *                    * ZSTEP*DEN*WEIGHT(4,ITYPE(ICALO))
     *                    + (ELOSS(PNEW,6,1)+ELOSS(PNEW,6,2))
     *                    * ZSTEP*DEN*WEIGHT(6,ITYPE(ICALO))
                     RL = RADLEN(ITYPE(ICALO))*ZSTEP*DEN
                     TRL = TRL + RL
                  END IF
               END IF
C---------------------------------------------------------------------
C
C               End of step loop
C
C---------------------------------------------------------------------
200         CONTINUE
C---------------------------------------------------------------------
C    Take into account the aluminium plate of the beam cal.
C---------------------------------------------------------------------
            IF(ICALO.EQ.3) THEN
               PNEW = PNEW
     *              + (ELOSS(PNEW,1,1)+ELOSS(PNEW,1,2)) *2.*DEN
               RL = 1/8.893*2.*DEN
               TRL = TRL + RL
            END IF
C---------------------------------------------------------------------
C    Take into account the tank etc in the ULAC
C---------------------------------------------------------------------
            IF(ICALO.EQ.1.OR.ICALO.EQ.2) THEN
               PNEW = PNEW
     *              + (ELOSS(PNEW,2,1)+ELOSS(PNEW,2,2)) *2.3*DEN
               RL = 1/1.76*2.3*DEN
C---------------------------------------------------------------------
C    Take into account the G10 in the ULAC
C---------------------------------------------------------------------
               IF(ICALO.EQ.1) THEN
                  PNEW = PNEW + .028
                  RL = RL + 2.67 + 1.
               ELSE IF(ICALO.EQ.2) THEN
                  PNEW = PNEW + .029
                  RL = RL + 2.29 + 1.
               END IF
               TRL = TRL + RL
            END IF
C---------------------------------------------------------------------
C
C               End of calorimeter loop
C
C---------------------------------------------------------------------
100      CONTINUE
       PLOSS = PNEW - POLD
C---------------------------------------------------------------------
C
C               End of iteration loop
C
C---------------------------------------------------------------------
50    CONTINUE
C---------------------------------------------------------------------
C    Track parameters at target
C---------------------------------------------------------------------
      TRAKMU(2,I,12) = X0C
      TRAKMU(2,I,14) = Y0C
      TRAKMU(2,I,11) = SXC
      TRAKMU(2,I,13) = SYC
C---------------------------------------------------------------------
C    Pz,Px,Py,PT,P at target after energy-loss correction
C---------------------------------------------------------------------
      TRAKMU(2,I,3) = PNEW/DENC
      TRAKMU(2,I,1) = TRAKMU(2,I,3) * SXC
      TRAKMU(2,I,2) = TRAKMU(2,I,3) * SYC
      TRAKMU(2,I,4) = SQRT(TRAKMU(2,I,1)**2 + TRAKMU(2,I,2)**2)
      TRAKMU(2,I,5) = SQRT(TRAKMU(2,I,4)**2 + TRAKMU(2,I,3)**2)
C---------------------------------------------------------------------
C    Track parameters after magcal
C---------------------------------------------------------------------
      TRAKMU(3,I,12) = X0
      TRAKMU(3,I,14) = Y0
      TRAKMU(3,I,11) = SX
      TRAKMU(3,I,13) = SY
C---------------------------------------------------------------------
C    Pz,Px,Py,PT,P after magcal and after energy-loss correction
C---------------------------------------------------------------------
      TRAKMU(3,I,3) = PNEW/DEN
      TRAKMU(3,I,1) = TRAKMU(3,I,3) * SX
      TRAKMU(3,I,2) = TRAKMU(3,I,3) * SY
      TRAKMU(3,I,4) = SQRT(TRAKMU(3,I,1)**2 + TRAKMU(3,I,2)**2)
      TRAKMU(3,I,5) = SQRT(TRAKMU(3,I,4)**2 + TRAKMU(3,I,3)**2)
C---------------------------------------------------------------------
C    Error (rms) on mult. scattering angle
C---------------------------------------------------------------------
      TRAKMU(1,I,20) = 0.0141*SQRT(TRL)*(1.+ALOG10(TRL)/9.)/PNEW
C---------------------------------------------------------------------
C    Error (rms) on track angles before dump
C---------------------------------------------------------------------
      TRAKMU(2,I,20) = PPAR2 * TRAKMU(1,I,20)
C---------------------------------------------------------------------
C    Energy loss in cal.
C---------------------------------------------------------------------
      TRAKMU(3,I,20) = PLOSS
C---------------------------------------------------------------------
C    Multiple scattering angle
C---------------------------------------------------------------------
      TRAKMU(3,I,22) = THMS
      RETURN
      END
+EOD.
C*********************************************************************
C
C                         E L O S S
C
C*********************************************************************
+DECK,ELOSS.
      FUNCTION ELOSS(P,MAT,KIND)
C---------------------------------------------------------------------
C
C       Computes the energy loss of a muon in various materials
C
C---------------------------------------------------------------------
C
C       ELOSS   =  ENERGY LOSS ( GeV/cm )
C       P       =  MOMENTUM    ( GeV )
C       MAT     =  1 :   Al
C               =  2 :   Fe
C               =  3 :   W
C               =  4 :   U
C               =  5 :   Cu
C               =  6 :   Liquid Argon
C       KIND    =  1 :   ionisation  dE/dx
C               =  2 :   "radiation" dE/dx (bremss.+pairs+nucl. int.)
C
C---------------------------------------------------------------------
      ELOSS = 0.
      IF(MAT.LT.1.OR.MAT.GT.6)  GOTO 99
      IF( KIND.EQ.1 )  ELOSS = ELOS1(P,MAT)
      IF( KIND.EQ.2 )  ELOSS = ELOS2(P,MAT)
  99  RETURN
      END
+EOD.
C*********************************************************************
C
C                         E L O S 1
C
C*********************************************************************
+DECK,ELOS1.
       FUNCTION ELOS1(P,MAT)
C---------------------------------------------------------------------
C
C     Computes the ionisation energy loss (in GeV/cm)
C     for a muon of momentum  P (in GeV)
C
C---------------------------------------------------------------------
C
C     AME    = ELECTRON MASS              (in eV)
C     AMU    = MUON     MASS              (in GeV)
C     ZMAT   = Z OF MATERIAL
C     AMAT   = A OF MATERIAL
C     RHO    = DENSITY                    (in grams/cm**3)
C     EI     = IONISATION POTENTIAL       (in eV)
C     D      =                            (in GeV/cm)
C
C---------------------------------------------------------------------
+CDE,MUSTAT.
      REAL   ZMAT(6), AMAT(6), RHO(6)
      REAL   EI(6),   D(6)
      REAL   EZ(6),   COB1(6), COP1(6), CON1(6)
 
      SAVE EI,D,AME,AMU,INIT
C---------------------------------------------------------------------
C      Values of AMAT, RHO and EI as quoted in CERN 71-18
C---------------------------------------------------------------------
      DATA   NMAT  /6/
      DATA   ZMAT  / 13., 26., 74., 92., 29., 18./
      DATA   AMAT  / 26.981, 55.847, 183.850, 238.030, 63.54, 39.95 /
      DATA   RHO   / 2.699, 7.860, 19.300, 18.680, 8.960, 1.4 /
      DATA   EI    / 163.0, 273.0, 748.0, 923.0, 303., 216. /
      DATA   AME   /.511E6/
      DATA   AMU   /.10566/
      DATA   INIT  /0/
 
      IF(INIT.NE.0) GOTO 10
         DO 5 M=1,NMAT
            D(M)   = .307E-3*(ZMAT(M)/AMAT(M))*RHO(M)
   5        CONTINUE
         INIT = 1
  10  CONTINUE
 
      EMU  = SQRT(P**2+AMU**2)
      GAM  = EMU/AMU
      GP   = 1./GAM**2
      GPP  = 1.-GP
      BET  = SQRT(1.-1./GAM**2)
      ARGD = SQRT(1.+2.*((AME/1.E9)/AMU)*SQRT(1.+(BET**2)*(GAM**2))
     *       +((AME/1.E9)/AMU)**2)
      ARG  = (2.*AME*((GAM*BET)**2)) / (EI(MAT)*ARGD)
C---------------------------------------------------------------------
C     Bethe-Bloch formula with density effect included
C---------------------------------------------------------------------
      ELOS1 = ( D(MAT) / (BET**2) ) * ( ALOG(ARG) - BET**2
     *        - DELTA(BET*GAM,MAT)/2. )
      RETURN
      END
+EOD.
C*********************************************************************
C
C                         E L O S 2
C
C*********************************************************************
+DECK,ELOS2.
       FUNCTION ELOS2(P,MAT)
C---------------------------------------------------------------------
C
C     Computes the part of energy loss (in GeV per cm) due to
C     bremsstrahlung, pair creation and nuclear interaction for
C     a muon of momentum P (in GeV).
C
C     Ref. : C. RICHARD-SERRE, CERN YELLOW REPORT no. 71-18
C
C---------------------------------------------------------------------
C
C     AVO    = AVOGADRO NUMBER
C     AME    = ELECTRON MASS                  (in GeV)
C     AMU    = MUON     MASS                  (in GeV)
C     RE     = CLASSICAL ELECTRON RADIUS      (in cm)
C     XSEC   = MUON PHOTO-NUCLEAR CROSS SECT. (in cm**2)
C     ZMAT   = Z OF MATERIAL
C     AMAT   = A OF MATERIAL
C     RHO    = DENSITY  (in grams/cm**3)
C
C---------------------------------------------------------------------
+CDE,MUSTAT.
      REAL   ZMAT(6), AMAT(6), RHO(6)
      REAL   EI(6),   D(6)
      REAL   EZ(6),   COB1(6), COP1(6), CON1(6)
 
      SAVE ZMAT,RHO,EZ,COB1,COP1,CON1,AMU,INIT
C---------------------------------------------------------------------
C   Values of A and of density as quoted in CERN 71-18
C---------------------------------------------------------------------
      DATA   NMAT  /6/
      DATA   ZMAT  / 13., 26., 74., 92., 26. ,18./
      DATA   AMAT  / 26.981, 55.847, 183.850, 238.030, 63.54, 39.95/
      DATA   RHO   / 2.699, 7.860, 19.300, 18.680, 8.960, 1.4 /
      DATA   AVO   /6.022E+23/
      DATA   AME   /.511E-3/
      DATA   AMU   /.10566/
      DATA   RE    /2.817938E-13/
      DATA   XSEC  /120.E-30/
      DATA   PI    /3.14159/
      DATA   INIT  /0/
 
      IF(INIT.NE.0) GOTO 10
         ALF = 1./137.
         DO 5 M=1,NMAT
            EZ(M)  = 28. - 0.36*ZMAT(M) + 0.002*ZMAT(M)**2
            Z2A = (ZMAT(M)**2)/AMAT(M)
            COB1(M) = 4. * ALF * (AVO*(RE**2)) * Z2A * (AME/AMU)**2
            COP1(M) = (ALF**2)/PI * Z2A * (AVO*(RE**2)) * (AME/AMU)
            CON1(M) = 2. * (AVO*XSEC) * (ALF/PI)
   5     CONTINUE
         INIT = 1
  10  CONTINUE
 
      ELOS2 = 0.
      E = SQRT(P**2+AMU**2) - AMU
      COB2 = ALOG( 12.*E*(ZMAT(MAT)**(-1./3.))/(5.*AMU) ) - 1./3.
      COP2 = 19.3 * ALOG(E/AMU) - 53.7
      IF(E.GT.EZ(MAT))
     *    COP2 = COP2 * ( 16./9.*ALOG(183.*(ZMAT(MAT)**(-1./3.))) + 1. )
     *           / ( 16./9.*ALOG(E/AMU) - 14./9. + ALOG(2.) )
      DEB = COB1(MAT) * COB2 * E
      DEP = COP1(MAT) * COP2 * E
      DEN = CON1(MAT) * E
      IF(DEB.LT.0.) DEB = 0.
      IF(DEP.LT.0.) DEP = 0.
      ELOS2 = RHO(MAT) * ( DEB + DEP + DEN )
 
      RETURN
      END
+EOD.
C*********************************************************************
C
C                         D E L T A
C
C*********************************************************************
+DECK,DELTA.
       FUNCTION DELTA(ETA,MAT)
C---------------------------------------------------------------------
C
C    Parametrisation of the density effect in the Bethe-Bloch formula
C    as a function of the ETA = BETA * GAMMA of the incident particle
C    for the following materials :
C
C    MAT  =  1 :  Al
C         =  2 :  Fe
C         =  3 :  W
C         =  4 :  U
C         =  5 :  Cu
C         =  6 :  Liquid Argon
C
C    Reference : C. Richard-Serre, CERN Yellow Report no. 71-18
C
C---------------------------------------------------------------------
       SAVE X0,X1,C,A,M
 
       REAL X0(6),X1(6),C(6),A(6),M(6)
       DATA X0 / .200, .200, .280, .077, .200, 200./
       DATA X1 /  3.0,  3.0,  3.0,  3.0, 3.0, 3.0 /
       DATA C  / -4.203, -4.200, -5.463, -5.939, -4.200, -4.200 /
       DATA A  / .149, .149, .207, .376, .149, .149 /
       DATA M  /  3.0,  3.0,  3.0, 2.515, 3.0, 3.0 /
 
       DELTA = 0.
       IF(MAT.LT.1.OR.MAT.GT.6) GOTO 99
       X = ALOG10(ETA)
       IF(X.LT.X0(MAT))         GOTO 99
       DELTA = 4.606*X + C(MAT)
       IF(X.LT.X1(MAT))  DELTA=DELTA + A(MAT)*((X1(MAT)-X)**M(MAT))
 
  99   RETURN
       END
+EOD.
C*********************************************************************
C
C                         D I S L P
C
C*********************************************************************
+DECK, DISLP.
      SUBROUTINE DISLP(A,B,C,X0,Y0,Z0,ALPHA,BETA,GAMMA,XC,YC,ZC,RC)
C---------------------------------------------------------------------
C
C    Take a point (A,B,C) and a line:  X=X0+ALPHA*T
C                                      Y=Y0+BETA*T
C                                      Z=Z0+GAMMA*T
C
C    and calculate the point (XC,YC,ZC) which lies on the line and
C    which is closest to point (A,B,C) and then calculate the
C    distance RC between these two points.
C
C---------------------------------------------------------------------
      XC=-100000000000.
      YC=-100000000000.
      ZC=-100000000000.
      RC=-100000000000.
      IF(ALPHA**2+BETA**2+GAMMA**2.EQ.0.) RETURN
      TC=(ALPHA*(A-X0)+BETA*(B-Y0)+GAMMA*(C-Z0))/(ALPHA**2+BETA**2+
     *    GAMMA**2)
      XC=X0+ALPHA*TC
      YC=Y0+BETA*TC
      ZC=Z0+GAMMA*TC
      RC=SQRT((A-XC)**2+(B-YC)**2+(C-ZC)**2)
      RETURN
      END
+EOD.
C*********************************************************************
C
C                         D I S L L
C
C*********************************************************************
+DECK, DISLL.
      SUBROUTINE DISLL
     *(X1,Y1,Z1,A1,B1,G1,X2,Y2,Z2,A2,B2,G2,XC,YC,ZC,RC,Z)
C---------------------------------------------------------------------
C
C    Take two lines:  X=X1+A1*T    X=X2+A2*L
C                     Y=Y1+B1*T    Y=Y2+B2*L
C                     Z=Z1+G1*T    Z=Z2+G2*L
C
C    and find the shortest distance (RC) between them and the point
C    (XC,YC,ZC) which lies in the middle.
C
C---------------------------------------------------------------------
      XC=-100000000000.
      YC=-100000000000.
      ZC=-100000000000.
      RC=-100000000000.
      Z =-100000000000.
      AA=A1*(X1-X2)+B1*(Y1-Y2)+G1*(Z1-Z2)
      BB=A1**2+B1**2+G1**2
      CC=A1*A2+B1*B2+G1*G2
      DD=A2*(X1-X2)+B2*(Y1-Y2)+G2*(Z1-Z2)
      EE=A2**2+B2**2+G2**2
      IF(EE*BB-CC*CC.EQ.0.) RETURN
      IF(BB.EQ.0.)          RETURN
      L=(DD*BB-CC*AA)/(EE*BB-CC*CC)
      T=(CC*L)/BB-AA
      XC1=X1+A1*T
      YC1=Y1+B1*T
      ZC1=Z1+G1*T
      XC2=X2+A2*L
      YC2=Y2+B2*L
      ZC2=Z2+G2*L
      XC=(XC1+XC2)/2.
      YC=(YC1+YC2)/2.
      ZC=(ZC1+ZC2)/2.
      RC=SQRT((XC1-XC2)**2+(YC1-YC2)**2+(ZC1-ZC2)**2)
      Z=ZC1
      RETURN
      END
+EOD.
C*********************************************************************
C
C                         L S T O P
C
C*********************************************************************
+DECK, LSTOP. Routine which stops the program if a label is missing
      SUBROUTINE LSTOP(LABEL)
C---------------------------------------------------------------------
C    Routine which stops the program if a label is missing
C---------------------------------------------------------------------
      DATA N /0/
      N=N+1
      WRITE(6,*) ' SHIT, the following label is missing:'
      WRITE(6,1) LABEL
      WRITE(6,*) ' If this continues the program will STOP'
 1    FORMAT(5X,I10)
      IF(N.GE.100) STOP
      RETURN
      END
+EOD.
C*********************************************************************
C
C                         L W A R N G
C
C*********************************************************************
+DECK, LWARNG. Routine which gives a warning if a label is missing
      SUBROUTINE LWARNG(LABEL)
C---------------------------------------------------------------------
C    Routine which gives a warning if a label is missing
C---------------------------------------------------------------------
      DATA N /0/
      N=N+1
      IF(N.LE.25) THEN
         WRITE(6,*) ' WARNING, the following label is missing:'
         WRITE(6,1) LABEL
      ENDIF
 1    FORMAT(5X,I10)
      IF(N.EQ.25) WRITE(6,*) 'This was the last WARNING'
      RETURN
      END
+EOD.
C*********************************************************************
C
C                         G S P O S
C
C*********************************************************************
+DECK, GSPOS.
      SUBROUTINE GSPOS
C---------------------------------------------------------------------
C     This dummy routine removes annoying print-out
C---------------------------------------------------------------------
      RETURN
      END
+EOD.
C*********************************************************************
C
C                         F R W R I T
C
C*********************************************************************
+DECK, FRWRIT. Subroutine to print Scalers (a modified Freja routine)
      SUBROUTINE FRWRIT
+CDE,FRSCLL.
+CDE,MYINFO.
      IF(YEAR.EQ.1987) THEN
         IF(SCAL(11).NE.0) B6EFF  = SCAL(82) / SCAL(11) * 100.
      ENDIF
      IF(SCAL(4).NE.0)  XTIM   = SCAL(13) / SCAL(4)  * 100.
      IF(SCAL(12).NE.0) XNRATE = SCAL(13) / SCAL(12) * 100.
      IF(SCAL(13).NE.0) XURATE = SCAL(17) / SCAL(13) * 100.
      IF(SCAL(1).NE.0) THEN
         SVRATE = SCAL(2)  / SCAL(1)  * 100.
         XVRAT  = SCAL(84) / SCAL(1)  * 100.
      ENDIF
      IF(BURSTS.NE.0) THEN
         BBUR   = SCAL(1)  / BURSTS
         TOMU   = SCAL(41) / BURSTS
         VFBCLK = SCAL(37) / BURSTS
         TRIVAX = SCAL(43) / BURSTS
         IF(YEAR.EQ.1987) THEN
            EFBEAM = SCAL(205) - SCAL(206) - SCAL(207) - SCAL(208)
         ELSE
            EFBEAM = SCAL(157) - SCAL(158) - SCAL(159) - SCAL(160)
         ENDIF
      ENDIF
      WRITE(6,*)' ***************************************************'
      WRITE(6,*)' **** Number of bursts was ',BURSTS,'    ****       '
      WRITE(6,*)' ***************************************************'
      WRITE(6,*)' ***************************************************'
      WRITE(6,*)' ****         Output from the scalers           ****'
      WRITE(6,*)' ***************************************************'
      WRITE(6,*)
      IF(YEAR.EQ.1987) THEN
         WRITE(6,*) '73:  B1A          ',SCAL(073)
         WRITE(6,*) '74:  B2B          ',SCAL(074)
         WRITE(6,*) '75:  B2A          ',SCAL(075)
      ENDIF
      WRITE(6,*) '80:  B6A          ',SCAL(080)
      WRITE(6,*) '81:  B6B          ',SCAL(081)
      WRITE(6,*) '82:  B6           ',SCAL(082)
      WRITE(6,*) ' 1:  B            ',SCAL(001)
      IF(YEAR.EQ.1987) THEN
         WRITE(6,*) '11:  B1*B2        ',SCAL(011)
         WRITE(6,*) '209: B  ev. read  ',SCAL(209)
      ELSE
         WRITE(6,*) '161: B  ev. read  ',SCAL(161)
      ENDIF
      WRITE(6,*)
      WRITE(6,*) 'B  per burst      ',BBUR
      IF(YEAR.EQ.1987) THEN
         WRITE(6,1) B6EFF
 1       FORMAT(1X,'B6 eff. = B6/B1*B2',F10.0,'%')
      ENDIF
      WRITE(6,*)
      WRITE(6,*) '76:  B3A          ',SCAL(076)
      WRITE(6,*) '77:  B3B          ',SCAL(077)
      WRITE(6,*) '85:  B7A          ',SCAL(085)
      WRITE(6,*) '86:  B7B          ',SCAL(086)
      WRITE(6,*) ' 2:  SV           ',SCAL(002)
      WRITE(6,*) '84:  LV           ',SCAL(084)
      WRITE(6,*)
      WRITE(6,2) SVRATE
 2    FORMAT(1X,'SV rate = SV/B    ',F10.0,'%')
      WRITE(6,3) XVRAT
 3    FORMAT(1X,'LV rate = LV/B    ',F10.0,'%')
      WRITE(6,*)
      WRITE(6,*) ' 4:  INT          ',SCAL(004)
      IF(YEAR.EQ.1987) THEN
         WRITE(6,*) '211: INT ev. read ',SCAL(211)
      ELSE
         WRITE(6,*) '163: INT ev. read ',SCAL(163)
      ENDIF
      WRITE(6,*) '10:  VB           ',SCAL(010)
      IF(YEAR.EQ.1987) THEN
         WRITE(6,*) '210: VB  ev. read ',SCAL(210)
      ELSE
         WRITE(6,*) '162: VB  ev. read ',SCAL(162)
      ENDIF
      WRITE(6,*) '12:  STR          ',SCAL(012)
      IF(YEAR.EQ.1987) THEN
         WRITE(6,*) '205: STR ev. read ',SCAL(205)
      ELSE
         WRITE(6,*) '157: STR ev. read ',SCAL(157)
      ENDIF
      WRITE(6,*) ' 7:  MU 1         ',SCAL(007)
      WRITE(6,*) ' 8:  MU 2         ',SCAL(008)
      WRITE(6,*) '13:  VINTP        ',SCAL(013)
      WRITE(6,*) '14:  MTP          ',SCAL(014)
      WRITE(6,*) '16:  MU1P         ',SCAL(016)
      WRITE(6,*) '17:  MU2P         ',SCAL(017)
      WRITE(6,*)
      WRITE(6,4) XTIM
 4    FORMAT(1X,'Live t. =VINTP/INT',F10.1,'%')
      WRITE(6,5) XNRATE
 5    FORMAT(1X,'Int rate=VINTP/STR',F10.1,'%')
      WRITE(6,6) XURATE
 6    FORMAT(1X,'Mu rate=MU2P/VINTP',F10.2,'%')
      WRITE(6,*)
      WRITE(6,*) '41:  T/O MU       ',SCAL(041)
      WRITE(6,*) '37:  VFB CLK      ',SCAL(037)
      IF(YEAR.EQ.1987) THEN
         WRITE(6,*) '213: VFB CLK ev. r',SCAL(213)
      ELSE
         WRITE(6,*) '165: VFB CLK ev. r',SCAL(165)
      ENDIF
      WRITE(6,*) '43:  TRIG. VAX    ',SCAL(043)
      WRITE(6,*)
      WRITE(6,*) 'T/O MU per burst  ',TOMU
      WRITE(6,*) 'VFB CLK per burst ',VFBCLK
      WRITE(6,*) 'TRIG VAX per burst',TRIVAX
      WRITE(6,*)
      IF(YEAR.EQ.1987) THEN
         WRITE(6,*) '205: STR          ',SCAL(205)
         WRITE(6,*) '206: STR*T2B      ',SCAL(206)
         WRITE(6,*) '207: MT*notT2B    ',SCAL(207)
         WRITE(6,*) '208: (LI+LB)*PRE  ',SCAL(208)
      ELSE
         WRITE(6,*) '157: STR          ',SCAL(157)
         WRITE(6,*) '158: STR*T2B      ',SCAL(158)
         WRITE(6,*) '159: MT*notT2B    ',SCAL(159)
         WRITE(6,*) '160: (LI+LB)*PRE  ',SCAL(160)
      ENDIF
      WRITE(6,*)
      WRITE(6,*) 'Effective beam    ',EFBEAM
      WRITE(6,*)
      RETURN
      END
+EOD.
C*********************************************************************
C
C                         G S R O T M
C
C*********************************************************************
+DECK, GSROTM.
      SUBROUTINE GSROTM
C---------------------------------------------------------------------
C     This dummy routine removes annoying print-out
C---------------------------------------------------------------------
      RETURN
      END
+EOD.
C*********************************************************************
C
C                         Z D E T E C
C
C*********************************************************************
+DECK,ZDETEC.
      SUBROUTINE ZDETEC
+CDE,MYINFO.
      IF(YEAR.EQ.1987) THEN
         XTARG = -0.0035
         YTARG = -0.0080
         ZTARG = 2.0
      ENDIF
      IF(YEAR.EQ.1988) THEN
         XTARG = -0.0009
         YTARG = -0.0092
         ZTARG = 0.78
      ENDIF
      ZM    = 158.23
      ZSCIN = 363.6
      ZULAC = 384.2
      ZBEAM = 579.0
      ZVETO = 719.0
      RETURN
      END
+EOD.
C*********************************************************************
C
C                         G E O D A T
C
C*********************************************************************
+DECK, GEODAT.
      SUBROUTINE GEODAT
+CDE,MUGEOC,MYINFO.
      COMMON/GECOM/ JPLUS(64),JCOO(64),ZJPL(64),JNMWIR(64),SJTPW(64),
     *         SNJCOO(64),CSJCOO(64),PJSZRO(64),SHIFTX(32),SHIFTY(32)
C---------------------------------------------------------------------
C   This routine reads in data describing the mu spectrometer into
C   common MUGEOC
C---------------------------------------------------------------------
      DO 10 I = 1,32
         IPLUS(I) = JPLUS(I)
         ICOO(I)  = JCOO(I)
         ZPL(I)   = ZJPL(I)
         NMWIR(I) = JNMWIR(I)
         STPWIR(I)= SJTPW(I)
         SNCOO(I) = SNJCOO(I)
         CSCOO(I) = CSJCOO(I)
         POSZRO(I)= PJSZRO(I)
   10 CONTINUE
      RETURN
      END
+EOD.
C*********************************************************************
C
C                         G E D A T A
C
C*********************************************************************
+DECK, GEDATA. MUON BLOCK DATA USED BY SUBR. GEODAT
      BLOCK DATA
+CDE,MUGEOC,MYINFO.
      COMMON/GECOM/ JPLUS(64),JCOO(64),ZJPL(64),JNMWIR(64),SJTPW(64),
     *         SNJCOO(64),CSJCOO(64),PJSZRO(64),SHIFTX(32),SHIFTY(32)
C---------------------------------------------------------------------
C   This routine reads in data describing the mu spectrometer into
C   common MUGEOC
C---------------------------------------------------------------------
      DATA JPLUS  / 64*1 /
      DATA JCOO   /0,1,3,   0,1,3,
     2             0,2,1,3,2,0,
     3             0,2,1,3,2,0,
     4             0,2,1,3,2,0,
     5             0,0,2,1,
     6             0,2,3,0,
     7              32*0/
      DATA ZJPL /
     1  769.49 , 771.69 , 773.89 , 793.475, 795.675, 797.875,
     2  966.47 , 971.43 , 976.39 , 981.35 , 986.31 , 991.27 ,
     3 1228.425,1230.225,1232.025,1233.825,1235.625,1237.425,
     4 1310.147,1311.947,1313.747,1315.547,1317.347,1319.147,
     5 1443.345,1445.745,1448.145, 1450.545,
     6 1663.54,1665.940,1668.340,1670.74,
     7 32*0./
      DATA JNMWIR  /6*512,
     2       6*448,
     3        896, 864,1024,1024,864,1024,
     4       1024, 864,1024,1024,864,1024,
     5       1408,1152,1344,1792,
     6       1408,1344,1792,1408,
     7       32*0/
      DATA SJTPW /0.3,-0.3,-0.3,0.3,-0.3,-0.3,26*0.3,32*0./
      DATA SNJCOO /0.,.866,.866,0.,.866,.866,
     2       0.,1.,.7071,.7071,1.,0.,
     3       0.,1.,.7071,.7071,1.,0.,
     4       0.,1.,.2462,.2462,1.,0.,
     5       0.,0.,1.,.8,
     6       0.,1.,.8,0.,
     7       32*0./
      DATA CSJCOO /1.,.5,-.5,1.,.5,-.5,
     2       1.,0.,.7071,-.7071,0.,1.,
     3       1.,0.,.7071,-.7071,0.,1.,
     4       1.,0.,.9692,-.9692,0.,1.,
     5       1.,1.,0.,.6,
     6       1.,0.,-.6,1.,
     7       32*0./
      DATA PJSZRO / -76.663,  77.321,  77.334,
     1              -76.487,  76.776,  76.611,
     2     -67.045, -67.211, -67.175, -67.217, -67.277, -66.987,
     3    -134.136,-129.3  ,-153.269,-153.430,-129.298,-153.336,
     4    -153.429,-129.384,-153.415,-153.447,-129.384,-153.43 ,
     5    -210.901,-172.502,-201.216,-268.374,
     6    -210.88 ,-201.242,-268.586,-210.878,
     7  32*0./
      DATA SHIFTX / 3*0.  ,3*.011,26*0./
      DATA SHIFTY / 3*.034,29*0.       /
      END
+EOD.
C*********************************************************************
C
C                         K I D A T A
C
C*********************************************************************
+DECK, KIDATA. BLOCK DATA TO INITIALIZE KINEMATIC CONSTANTS
      BLOCK DATA
+CDE,KINEM.
      DATA EM/0.0005110034/,  EEM/0.0010220068/, MUM/0.10565932/,
     *     MUMUM/0.21131864/, PIM/0.1395673/,    KAM/0.493667/,
     *     PRM/0.9382796/,    ROM/0.769/
      DATA PI/3.141592654/,   PI2/6.283185307/
      END
+EOD.
C*********************************************************************
C
C                         S P D A T A
C
C*********************************************************************
+DECK, SPDATA. BLOCK DATA TO INITIALIZE SCINT. PAD
      BLOCK DATA
C---------------------------------------------------------------------
C
C    General describtion of physical setup of detectors:
C
C    The scintillator pad detector uses 80 PM based scintillator
C    detectors. These generate 80 pulse height signals which are read
C    out in LeCroy 2282 charge ADC's (actually the signal for the ADC
C    is taken from the last dynode of the PM).
C    The anode signals go to discriminators and then to fanout
C    modules for the electron correlation logic.
C    From the pattern of the fanout modules, which is also read
C    at each event, it is possible to determine which discriminators
C    have fired.
C
C---------------------------------------------------------------------
+CDE,MYSPAD.
C---------------------------------------------------------------------
C     Fill arrays with super pad look-up table
C---------------------------------------------------------------------
      DATA ITEMP/0,1,5,6,7,11,12,13,2,3,4,8,9,10,14,15,
     *17,18,19,20,23,24,25,26,16,21,22,27,28,33,38,43,
     *29,30,31,32,34,35,36,37,39,40,41,42,44,45,46,47,
     *48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,
     *64,65,69,70,71,75,76,77,66,67,68,72,73,74,78,79,
     *81,82,83,84,87,88,89,90,80,85,86,91,92,97,102,107,
     *93,94,95,96,98,99,100,101,103,104,105,106,108,109,110,111,
     *112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,
     *128,129,133,134,135,139,140,141,130,131,132,136,137,138,142,143,
     *145,146,147,148,151,152,153,154,144,149,150,155,156,161,166,171,
     *157,158,159,160,162,163,164,165,167,168,169,170,172,173,174,175,
     *176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,
     *192,193,197,198,199,203,204,205,194,195,196,200,201,202,206,207,
     *209,210,211,212,215,216,217,218,208,213,214,219,220,225,230,235,
     *221,222,223,224,226,227,228,229,231,232,233,234,236,237,238,239,
     *240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255/
C---------------------------------------------------------------------
C     Fill arrays with scint. pad look-up table
C---------------------------------------------------------------------
      DATA ISCLOC/
     *   0, 1, 5, 6, 7, 8, 9,10, 2, 3, 4, 2, 3, 4,10, 3
     * ,11,11,10,10,12,12,13,13, 4, 3, 4,14,14,14,14,14
     * ,12,12,13,13,12,12,13,13,12,12,13,13,15,15,16,16
     * ,17,15,15,16,17,15,16,17,15,16,17,18,19,18,19,18
     * ,20,21,25,26,27,28,29,30,22,23,24,22,23,24,30,23
     * ,31,31,30,30,32,32,33,33,24,23,24,34,34,34,34,34
     * ,32,32,33,33,32,32,33,33,32,32,33,33,35,35,36,36
     * ,37,35,35,36,37,35,36,37,35,36,37,38,39,38,39,38
     * ,40,41,45,46,47,48,49,50,42,43,44,42,43,44,50,43
     * ,51,51,50,50,52,52,53,53,44,43,44,54,54,54,54,54
     * ,52,52,53,53,52,52,53,53,52,52,53,53,55,55,56,56
     * ,57,55,55,56,57,55,56,57,55,56,57,58,59,58,59,58
     * ,60,61,65,66,67,68,69,70,62,63,64,62,63,64,70,63
     * ,71,71,70,70,72,72,73,73,64,63,64,74,74,74,74,74
     * ,72,72,73,73,72,72,73,73,72,72,73,73,75,75,76,76
     * ,77,75,75,76,77,75,76,77,75,76,77,78,79,78,79,78/
C---------------------------------------------------------------------
C   Location of ADC data in event buffer = JWDPM(I)
C   where I is the scintillator number + 1
C   since scintillators are numbered 0 - 79
C---------------------------------------------------------------------
      DATA JWDPM /
     * 49,50,51,52,53,54,89,56,57,58,59,60,61,62,91,64,65,66,67,68,
     * 11, 9,25,17,15, 3,27, 5,23, 7,13,35,31,21,19,22,24,16,43,14,
     * 18, 2,38,46,29,30,26, 6,37, 4,34,47,42,20, 8,48,44,39,10,28,
     * 69,70,71,87,88,72,73,74,90,76,77,78,79,80,81,82,83,84,85,86  /
C---------------------------------------------------------------------
C     Fill arrays with positions of scintillator pads
C---------------------------------------------------------------------
      DATA XSCIL /
     *   3.7,  7.4, 11.5, 16.6, 24.0,  0.0,  3.7,  7.4,  0.0,  3.7,
     *   7.4,  0.0,  0.0,  7.4, 16.6,  0.0,  7.4, 16.6,  0.0,  7.4,
     *  -7.4,-11.5,-16.6,-24.0,-31.4, -3.7, -7.4,-11.5, -3.7, -7.4,
     * -16.6, -7.4, -7.4,-16.6,-27.8, -7.4,-16.6,-24.0, -7.4,-16.6,
     *  -7.4,-11.5,-16.6,-24.0,-31.4, -3.7, -7.4,-11.5, -3.7, -7.4,
     * -16.6, -7.4, -7.4,-16.6,-27.8, -7.4,-16.6,-24.0, -7.4,-16.6,
     *   3.7,  7.4, 11.5, 16.6, 24.0,  0.0,  3.7,  7.4,  0.0,  3.7,
     *   7.4,  0.0,  0.0,  7.4, 16.6,  0.0,  7.4, 16.6,  0.0,  7.4  /
      DATA XSCIH /
     *   7.4, 11.5, 16.6, 24.0, 31.4,  3.7,  7.4, 11.5,  3.7,  7.4,
     *  16.6,  7.4,  7.4, 16.6, 27.8,  7.4, 16.6, 24.0,  7.4, 16.6,
     *  -3.7, -7.4,-11.5,-16.6,-24.0,  0.0, -3.7, -7.4,  0.0, -3.7,
     *  -7.4,  0.0,  0.0, -7.4,-16.6,  0.0, -7.4,-16.6,  0.0, -7.4,
     *  -3.7, -7.4,-11.5,-16.6,-24.0,  0.0, -3.7, -7.4,  0.0, -3.7,
     *  -7.4,  0.0,  0.0, -7.4,-16.6,  0.0, -7.4,-16.6,  0.0, -7.4,
     *   7.4, 11.5, 16.6, 24.0, 31.4,  3.7,  7.4, 11.5,  3.7,  7.4,
     *  16.6,  7.4,  7.4, 16.6, 27.8,  7.4, 16.6, 24.0,  7.4, 16.6  /
      DATA YSCIL /
     *   0.0,  0.0,  0.0,  0.0,  0.0,  1.8,  1.8,  1.8,  3.7,  3.7,
     *   3.7,  5.5,  7.4,  7.4,  7.4, 14.8, 14.8, 14.8, 22.2, 22.2,
     *   0.0,  0.0,  0.0,  0.0,  0.0,  1.8,  1.8,  1.8,  3.7,  3.7,
     *   3.7,  5.5,  7.4,  7.4,  7.4, 14.8, 14.8, 14.8, 22.2, 22.2,
     *  -1.8, -1.8, -3.7, -7.4, -7.4, -3.7, -3.7, -3.7, -5.5, -5.5,
     *  -7.4, -7.4,-14.8,-14.8,-14.8,-22.2,-22.2,-22.2,-29.6,-29.6,
     *  -1.8, -1.8, -3.7, -7.4, -7.4, -3.7, -3.7, -3.7, -5.5, -5.5,
     *  -7.4, -7.4,-14.8,-14.8,-14.8,-22.2,-22.2,-22.2,-29.6,-29.6  /
      DATA YSCIH /
     *   1.8,  1.8,  3.7,  7.4,  7.4,  3.7,  3.7,  3.7,  5.5,  5.5,
     *   7.4,  7.4, 14.8, 14.8, 14.8, 22.2, 22.2, 22.2, 29.6, 29.6,
     *   1.8,  1.8,  3.7,  7.4,  7.4,  3.7,  3.7,  3.7,  5.5,  5.5,
     *   7.4,  7.4, 14.8, 14.8, 14.8, 22.2, 22.2, 22.2, 29.6, 29.6,
     *   0.0,  0.0,  0.0,  0.0,  0.0, -1.8, -1.8, -1.8, -3.7, -3.7,
     *  -3.7, -5.5, -7.4, -7.4, -7.4,-14.8,-14.8,-14.8,-22.2,-22.2,
     *   0.0,  0.0,  0.0,  0.0,  0.0, -1.8, -1.8, -1.8, -3.7, -3.7,
     *  -3.7, -5.5, -7.4, -7.4, -7.4,-14.8,-14.8,-14.8,-22.2,-22.2  /
C---------------------------------------------------------------------
C     Fill arrays with ADC cuts
C---------------------------------------------------------------------
      DATA ICUT /
     *   130,  140,  130,  390,  360,  100,  180,  180,  140,  110,
     *   280,  140,  320,  200,  100,  300,  210,  360,  220,  390,
     *   120,  120,  100,  280,  200,  180,  150,  160,  130,  140,
     *   360,  120,  240,  320,  320,  100,  280,  220,  260,  200,
     *   120,  150,  130,  280,  260,  160,  160,  160,  170,  130,
     *   340,  120,  240,  280,  390,  240,  280,  360,  240,  300,
     *   150,  160,  150,  360,  360,  110,  150,  150,  170,  170,
     *   360,  160,  240,  280,  340,  340,  280,  390,  390,  300  /
      DATA JCUT /
     *   320,  360,  320, 1110, 1110,  220,  460,  440,  340,  270,
     *   600,  340,  780,  520, 1000,  750,  690,  840,  620, 1020,
     *   360,  330,  310,  700,  540,  400,  330,  410,  350,  340,
     *   810,  340,  640,  760,  740, 1000,  680,  560,  720,  600,
     *   340,  320,  330,  680,  660,  380,  370,  340,  400,  330,
     *   740,  310,  660,  700,  980,  620,  780,  820,  660,  700,
     *   390,  410,  360,  860,  900,  290,  330,  340,  410,  410,
     *   800,  390,  550,  700,  780,  820,  680,  960,  870,  660  /
C--------------------------------------------------------------------
C     Fill arrays with ADCS' channels shift
C--------------------------------------------------------------------
      DATA ISHIF /
     *   70,   110,  90,   90,   60,   120,  60,   100,  130,  120,
     *   140,  170,  120,  200,  20,   90,   30,   90,   100,  30,
     *   70,   90,   120,  80,   120,  120,  130,  110,  80,   200,
     *   210,  120,  160,  100,  120,  180,  0,    120,  60,   100,
     *   150,  130,  120,  120,  120,  120,  100,  120,  120,  100,
     *   140,  70,   140,  140,  50,   100,  140,  100,  60,   100,
     *   130,  150,  60,   120,  120,  170,  150,  50,   100,  10,
     *   80,   110,  120,  100,  100,  240,  80,   60,   79,   60   /
C---------------------------------------------------------------------
C     Fill arrays to determine histogram size
C---------------------------------------------------------------------
      DATA IHIST /
     *     1,    1,    1,    3,    3,    1,    2,    2,    1,    1,
     *     2,    1,    2,    2,    2,    3,    3,    3,    2,    3,
     *     1,    1,    1,    2,    2,    2,    1,    1,    1,    1,
     *     3,    2,    2,    2,    2,    2,    2,    2,    2,    2,
     *     1,    1,    1,    2,    2,    2,    1,    1,    1,    1,
     *     2,    1,    2,    2,    3,    2,    2,    2,    2,    2,
     *     1,    1,    1,    2,    3,    1,    1,    1,    1,    1,
     *     2,    1,    2,    2,    2,    2,    2,    3,    3,    2  /
      END
+EOD.
+QUIT.
C*********************************************************************
